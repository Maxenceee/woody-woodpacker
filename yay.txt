
woody_woodpacker:     file format elf64-x86-64


Disassembly of section .init:

0000000000002000 <_init>:
    2000:	f3 0f 1e fa          	endbr64 
    2004:	48 83 ec 08          	sub    $0x8,%rsp
    2008:	48 8b 05 d9 9f 00 00 	mov    0x9fd9(%rip),%rax        # bfe8 <__gmon_start__@Base>
    200f:	48 85 c0             	test   %rax,%rax
    2012:	74 02                	je     2016 <_init+0x16>
    2014:	ff d0                	call   *%rax
    2016:	48 83 c4 08          	add    $0x8,%rsp
    201a:	c3                   	ret    

Disassembly of section .plt:

0000000000002020 <free@plt-0x10>:
    2020:	ff 35 fa 9e 00 00    	push   0x9efa(%rip)        # bf20 <_GLOBAL_OFFSET_TABLE_+0x8>
    2026:	ff 25 fc 9e 00 00    	jmp    *0x9efc(%rip)        # bf28 <_GLOBAL_OFFSET_TABLE_+0x10>
    202c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000002030 <free@plt>:
    2030:	ff 25 fa 9e 00 00    	jmp    *0x9efa(%rip)        # bf30 <free@GLIBC_2.2.5>
    2036:	68 00 00 00 00       	push   $0x0
    203b:	e9 e0 ff ff ff       	jmp    2020 <_init+0x20>

0000000000002040 <putchar@plt>:
    2040:	ff 25 f2 9e 00 00    	jmp    *0x9ef2(%rip)        # bf38 <putchar@GLIBC_2.2.5>
    2046:	68 01 00 00 00       	push   $0x1
    204b:	e9 d0 ff ff ff       	jmp    2020 <_init+0x20>

0000000000002050 <puts@plt>:
    2050:	ff 25 ea 9e 00 00    	jmp    *0x9eea(%rip)        # bf40 <puts@GLIBC_2.2.5>
    2056:	68 02 00 00 00       	push   $0x2
    205b:	e9 c0 ff ff ff       	jmp    2020 <_init+0x20>

0000000000002060 <write@plt>:
    2060:	ff 25 e2 9e 00 00    	jmp    *0x9ee2(%rip)        # bf48 <write@GLIBC_2.2.5>
    2066:	68 03 00 00 00       	push   $0x3
    206b:	e9 b0 ff ff ff       	jmp    2020 <_init+0x20>

0000000000002070 <strlen@plt>:
    2070:	ff 25 da 9e 00 00    	jmp    *0x9eda(%rip)        # bf50 <strlen@GLIBC_2.2.5>
    2076:	68 04 00 00 00       	push   $0x4
    207b:	e9 a0 ff ff ff       	jmp    2020 <_init+0x20>

0000000000002080 <__stack_chk_fail@plt>:
    2080:	ff 25 d2 9e 00 00    	jmp    *0x9ed2(%rip)        # bf58 <__stack_chk_fail@GLIBC_2.4>
    2086:	68 05 00 00 00       	push   $0x5
    208b:	e9 90 ff ff ff       	jmp    2020 <_init+0x20>

0000000000002090 <strchr@plt>:
    2090:	ff 25 ca 9e 00 00    	jmp    *0x9eca(%rip)        # bf60 <strchr@GLIBC_2.2.5>
    2096:	68 06 00 00 00       	push   $0x6
    209b:	e9 80 ff ff ff       	jmp    2020 <_init+0x20>

00000000000020a0 <printf@plt>:
    20a0:	ff 25 c2 9e 00 00    	jmp    *0x9ec2(%rip)        # bf68 <printf@GLIBC_2.2.5>
    20a6:	68 07 00 00 00       	push   $0x7
    20ab:	e9 70 ff ff ff       	jmp    2020 <_init+0x20>

00000000000020b0 <lseek@plt>:
    20b0:	ff 25 ba 9e 00 00    	jmp    *0x9eba(%rip)        # bf70 <lseek@GLIBC_2.2.5>
    20b6:	68 08 00 00 00       	push   $0x8
    20bb:	e9 60 ff ff ff       	jmp    2020 <_init+0x20>

00000000000020c0 <close@plt>:
    20c0:	ff 25 b2 9e 00 00    	jmp    *0x9eb2(%rip)        # bf78 <close@GLIBC_2.2.5>
    20c6:	68 09 00 00 00       	push   $0x9
    20cb:	e9 50 ff ff ff       	jmp    2020 <_init+0x20>

00000000000020d0 <dprintf@plt>:
    20d0:	ff 25 aa 9e 00 00    	jmp    *0x9eaa(%rip)        # bf80 <dprintf@GLIBC_2.2.5>
    20d6:	68 0a 00 00 00       	push   $0xa
    20db:	e9 40 ff ff ff       	jmp    2020 <_init+0x20>

00000000000020e0 <read@plt>:
    20e0:	ff 25 a2 9e 00 00    	jmp    *0x9ea2(%rip)        # bf88 <read@GLIBC_2.2.5>
    20e6:	68 0b 00 00 00       	push   $0xb
    20eb:	e9 30 ff ff ff       	jmp    2020 <_init+0x20>

00000000000020f0 <calloc@plt>:
    20f0:	ff 25 9a 9e 00 00    	jmp    *0x9e9a(%rip)        # bf90 <calloc@GLIBC_2.2.5>
    20f6:	68 0c 00 00 00       	push   $0xc
    20fb:	e9 20 ff ff ff       	jmp    2020 <_init+0x20>

0000000000002100 <fprintf@plt>:
    2100:	ff 25 92 9e 00 00    	jmp    *0x9e92(%rip)        # bf98 <fprintf@GLIBC_2.2.5>
    2106:	68 0d 00 00 00       	push   $0xd
    210b:	e9 10 ff ff ff       	jmp    2020 <_init+0x20>

0000000000002110 <strtol@plt>:
    2110:	ff 25 8a 9e 00 00    	jmp    *0x9e8a(%rip)        # bfa0 <strtol@GLIBC_2.2.5>
    2116:	68 0e 00 00 00       	push   $0xe
    211b:	e9 00 ff ff ff       	jmp    2020 <_init+0x20>

0000000000002120 <malloc@plt>:
    2120:	ff 25 82 9e 00 00    	jmp    *0x9e82(%rip)        # bfa8 <malloc@GLIBC_2.2.5>
    2126:	68 0f 00 00 00       	push   $0xf
    212b:	e9 f0 fe ff ff       	jmp    2020 <_init+0x20>

0000000000002130 <memmove@plt>:
    2130:	ff 25 7a 9e 00 00    	jmp    *0x9e7a(%rip)        # bfb0 <memmove@GLIBC_2.2.5>
    2136:	68 10 00 00 00       	push   $0x10
    213b:	e9 e0 fe ff ff       	jmp    2020 <_init+0x20>

0000000000002140 <open@plt>:
    2140:	ff 25 72 9e 00 00    	jmp    *0x9e72(%rip)        # bfb8 <open@GLIBC_2.2.5>
    2146:	68 11 00 00 00       	push   $0x11
    214b:	e9 d0 fe ff ff       	jmp    2020 <_init+0x20>

0000000000002150 <sprintf@plt>:
    2150:	ff 25 6a 9e 00 00    	jmp    *0x9e6a(%rip)        # bfc0 <sprintf@GLIBC_2.2.5>
    2156:	68 12 00 00 00       	push   $0x12
    215b:	e9 c0 fe ff ff       	jmp    2020 <_init+0x20>

0000000000002160 <exit@plt>:
    2160:	ff 25 62 9e 00 00    	jmp    *0x9e62(%rip)        # bfc8 <exit@GLIBC_2.2.5>
    2166:	68 13 00 00 00       	push   $0x13
    216b:	e9 b0 fe ff ff       	jmp    2020 <_init+0x20>

0000000000002170 <fwrite@plt>:
    2170:	ff 25 5a 9e 00 00    	jmp    *0x9e5a(%rip)        # bfd0 <fwrite@GLIBC_2.2.5>
    2176:	68 14 00 00 00       	push   $0x14
    217b:	e9 a0 fe ff ff       	jmp    2020 <_init+0x20>

Disassembly of section .plt.got:

0000000000002180 <__cxa_finalize@plt>:
    2180:	ff 25 72 9e 00 00    	jmp    *0x9e72(%rip)        # bff8 <__cxa_finalize@GLIBC_2.2.5>
    2186:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

0000000000002190 <_start>:
    2190:	f3 0f 1e fa          	endbr64 
    2194:	31 ed                	xor    %ebp,%ebp
    2196:	49 89 d1             	mov    %rdx,%r9
    2199:	5e                   	pop    %rsi
    219a:	48 89 e2             	mov    %rsp,%rdx
    219d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    21a1:	50                   	push   %rax
    21a2:	54                   	push   %rsp
    21a3:	45 31 c0             	xor    %r8d,%r8d
    21a6:	31 c9                	xor    %ecx,%ecx
    21a8:	48 8d 3d da 57 00 00 	lea    0x57da(%rip),%rdi        # 7989 <main>
    21af:	ff 15 23 9e 00 00    	call   *0x9e23(%rip)        # bfd8 <__libc_start_main@GLIBC_2.34>
    21b5:	f4                   	hlt    
    21b6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    21bd:	00 00 00 

00000000000021c0 <deregister_tm_clones>:
    21c0:	48 8d 3d f1 b1 00 00 	lea    0xb1f1(%rip),%rdi        # d3b8 <__TMC_END__>
    21c7:	48 8d 05 ea b1 00 00 	lea    0xb1ea(%rip),%rax        # d3b8 <__TMC_END__>
    21ce:	48 39 f8             	cmp    %rdi,%rax
    21d1:	74 15                	je     21e8 <deregister_tm_clones+0x28>
    21d3:	48 8b 05 06 9e 00 00 	mov    0x9e06(%rip),%rax        # bfe0 <_ITM_deregisterTMCloneTable@Base>
    21da:	48 85 c0             	test   %rax,%rax
    21dd:	74 09                	je     21e8 <deregister_tm_clones+0x28>
    21df:	ff e0                	jmp    *%rax
    21e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    21e8:	c3                   	ret    
    21e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000021f0 <register_tm_clones>:
    21f0:	48 8d 3d c1 b1 00 00 	lea    0xb1c1(%rip),%rdi        # d3b8 <__TMC_END__>
    21f7:	48 8d 35 ba b1 00 00 	lea    0xb1ba(%rip),%rsi        # d3b8 <__TMC_END__>
    21fe:	48 29 fe             	sub    %rdi,%rsi
    2201:	48 89 f0             	mov    %rsi,%rax
    2204:	48 c1 ee 3f          	shr    $0x3f,%rsi
    2208:	48 c1 f8 03          	sar    $0x3,%rax
    220c:	48 01 c6             	add    %rax,%rsi
    220f:	48 d1 fe             	sar    %rsi
    2212:	74 14                	je     2228 <register_tm_clones+0x38>
    2214:	48 8b 05 d5 9d 00 00 	mov    0x9dd5(%rip),%rax        # bff0 <_ITM_registerTMCloneTable@Base>
    221b:	48 85 c0             	test   %rax,%rax
    221e:	74 08                	je     2228 <register_tm_clones+0x38>
    2220:	ff e0                	jmp    *%rax
    2222:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    2228:	c3                   	ret    
    2229:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000002230 <__do_global_dtors_aux>:
    2230:	f3 0f 1e fa          	endbr64 
    2234:	80 3d 8d b1 00 00 00 	cmpb   $0x0,0xb18d(%rip)        # d3c8 <completed.0>
    223b:	75 2b                	jne    2268 <__do_global_dtors_aux+0x38>
    223d:	55                   	push   %rbp
    223e:	48 83 3d b2 9d 00 00 	cmpq   $0x0,0x9db2(%rip)        # bff8 <__cxa_finalize@GLIBC_2.2.5>
    2245:	00 
    2246:	48 89 e5             	mov    %rsp,%rbp
    2249:	74 0c                	je     2257 <__do_global_dtors_aux+0x27>
    224b:	48 8b 3d b6 9d 00 00 	mov    0x9db6(%rip),%rdi        # c008 <__dso_handle>
    2252:	e8 29 ff ff ff       	call   2180 <__cxa_finalize@plt>
    2257:	e8 64 ff ff ff       	call   21c0 <deregister_tm_clones>
    225c:	c6 05 65 b1 00 00 01 	movb   $0x1,0xb165(%rip)        # d3c8 <completed.0>
    2263:	5d                   	pop    %rbp
    2264:	c3                   	ret    
    2265:	0f 1f 00             	nopl   (%rax)
    2268:	c3                   	ret    
    2269:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000002270 <frame_dummy>:
    2270:	f3 0f 1e fa          	endbr64 
    2274:	e9 77 ff ff ff       	jmp    21f0 <register_tm_clones>

0000000000002279 <br_get_date>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

uint64_t	br_get_date(t_binary_reader *this)
{
    2279:	f3 0f 1e fa          	endbr64 
    227d:	55                   	push   %rbp
    227e:	48 89 e5             	mov    %rsp,%rbp
    2281:	53                   	push   %rbx
    2282:	48 83 ec 28          	sub    $0x28,%rsp
    2286:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t	mac_time;

	mac_time = this->get_uint32(this) * 0x100000000 + this->get_uint32(this);
    228a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    228e:	48 8b 50 38          	mov    0x38(%rax),%rdx
    2292:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    2296:	48 89 c7             	mov    %rax,%rdi
    2299:	ff d2                	call   *%rdx
    229b:	89 c0                	mov    %eax,%eax
    229d:	48 c1 e0 20          	shl    $0x20,%rax
    22a1:	48 89 c3             	mov    %rax,%rbx
    22a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    22a8:	48 8b 50 38          	mov    0x38(%rax),%rdx
    22ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    22b0:	48 89 c7             	mov    %rax,%rdi
    22b3:	ff d2                	call   *%rdx
    22b5:	89 c0                	mov    %eax,%eax
    22b7:	48 01 d8             	add    %rbx,%rax
    22ba:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return (mac_time);
    22be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
    22c2:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    22c6:	c9                   	leave  
    22c7:	c3                   	ret    

00000000000022c8 <br_get_fixed>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

int32_t	br_get_fixed(t_binary_reader *this)
{
    22c8:	f3 0f 1e fa          	endbr64 
    22cc:	55                   	push   %rbp
    22cd:	48 89 e5             	mov    %rsp,%rbp
    22d0:	48 83 ec 10          	sub    $0x10,%rsp
    22d4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (this->get_int32(this) / (1 << 16));
    22d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    22dc:	48 8b 50 50          	mov    0x50(%rax),%rdx
    22e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    22e4:	48 89 c7             	mov    %rax,%rdi
    22e7:	ff d2                	call   *%rdx
    22e9:	8d 90 ff ff 00 00    	lea    0xffff(%rax),%edx
    22ef:	85 c0                	test   %eax,%eax
    22f1:	0f 48 c2             	cmovs  %edx,%eax
    22f4:	c1 f8 10             	sar    $0x10,%eax
}
    22f7:	c9                   	leave  
    22f8:	c3                   	ret    

00000000000022f9 <br_get_fword>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

int16_t	br_get_fword(t_binary_reader *this)
{
    22f9:	f3 0f 1e fa          	endbr64 
    22fd:	55                   	push   %rbp
    22fe:	48 89 e5             	mov    %rsp,%rbp
    2301:	48 83 ec 10          	sub    $0x10,%rsp
    2305:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (this->get_int16(this));
    2309:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    230d:	48 8b 50 48          	mov    0x48(%rax),%rdx
    2311:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2315:	48 89 c7             	mov    %rax,%rdi
    2318:	ff d2                	call   *%rdx
}
    231a:	c9                   	leave  
    231b:	c3                   	ret    

000000000000231c <br_get_int16>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

int16_t	br_get_int16(t_binary_reader *this)
{
    231c:	f3 0f 1e fa          	endbr64 
    2320:	55                   	push   %rbp
    2321:	48 89 e5             	mov    %rsp,%rbp
    2324:	48 83 ec 20          	sub    $0x20,%rsp
    2328:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int16_t	res;

	res = this->get_uint16(this);
    232c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2330:	48 8b 50 30          	mov    0x30(%rax),%rdx
    2334:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2338:	48 89 c7             	mov    %rax,%rdi
    233b:	ff d2                	call   *%rdx
    233d:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	if (res & 0x8000)
    2341:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%rbp)
		res -= (1 << 16);
	return (res);
    2346:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
    234a:	c9                   	leave  
    234b:	c3                   	ret    

000000000000234c <br_seek>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

uint32_t	br_seek(t_binary_reader *this, uint32_t pos)
{
    234c:	f3 0f 1e fa          	endbr64 
    2350:	55                   	push   %rbp
    2351:	48 89 e5             	mov    %rsp,%rbp
    2354:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    2358:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t	old_pos;

	old_pos = this->_pos;
    235b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    235f:	8b 00                	mov    (%rax),%eax
    2361:	89 45 fc             	mov    %eax,-0x4(%rbp)
	this->_pos = pos;
    2364:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2368:	8b 55 e4             	mov    -0x1c(%rbp),%edx
    236b:	89 10                	mov    %edx,(%rax)
	return (old_pos);
    236d:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    2370:	5d                   	pop    %rbp
    2371:	c3                   	ret    

0000000000002372 <br_tell>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

uint32_t	br_tell(t_binary_reader *this)
{
    2372:	f3 0f 1e fa          	endbr64 
    2376:	55                   	push   %rbp
    2377:	48 89 e5             	mov    %rsp,%rbp
    237a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (this->_pos);
    237e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2382:	8b 00                	mov    (%rax),%eax
}
    2384:	5d                   	pop    %rbp
    2385:	c3                   	ret    

0000000000002386 <br_get_unicode_string>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

char	*br_get_unicode_string(t_binary_reader *this, uint16_t length)
{
    2386:	f3 0f 1e fa          	endbr64 
    238a:	55                   	push   %rbp
    238b:	48 89 e5             	mov    %rsp,%rbp
    238e:	48 83 ec 20          	sub    $0x20,%rsp
    2392:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    2396:	89 f0                	mov    %esi,%eax
    2398:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	int		i;
	char	*res;

	res = malloc((length + 1) * sizeof(char));
    239c:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
    23a0:	83 c0 01             	add    $0x1,%eax
    23a3:	48 98                	cltq   
    23a5:	48 89 c7             	mov    %rax,%rdi
    23a8:	e8 73 fd ff ff       	call   2120 <malloc@plt>
    23ad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!res)
    23b1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    23b6:	75 07                	jne    23bf <br_get_unicode_string+0x39>
		return (NULL);
    23b8:	b8 00 00 00 00       	mov    $0x0,%eax
    23bd:	eb 52                	jmp    2411 <br_get_unicode_string+0x8b>
	i = -1;
    23bf:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%rbp)
	while (++i < length / 2)
    23c6:	eb 22                	jmp    23ea <br_get_unicode_string+0x64>
		res[i] = this->get_uint16(this);
    23c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    23cc:	48 8b 50 30          	mov    0x30(%rax),%rdx
    23d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    23d4:	48 89 c7             	mov    %rax,%rdi
    23d7:	ff d2                	call   *%rdx
    23d9:	89 c2                	mov    %eax,%edx
    23db:	8b 45 f4             	mov    -0xc(%rbp),%eax
    23de:	48 63 c8             	movslq %eax,%rcx
    23e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    23e5:	48 01 c8             	add    %rcx,%rax
    23e8:	88 10                	mov    %dl,(%rax)
	while (++i < length / 2)
    23ea:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
    23ee:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
    23f2:	66 d1 e8             	shr    %ax
    23f5:	0f b7 c0             	movzwl %ax,%eax
    23f8:	39 45 f4             	cmp    %eax,-0xc(%rbp)
    23fb:	7c cb                	jl     23c8 <br_get_unicode_string+0x42>
	res[i] = 0;
    23fd:	8b 45 f4             	mov    -0xc(%rbp),%eax
    2400:	48 63 d0             	movslq %eax,%rdx
    2403:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2407:	48 01 d0             	add    %rdx,%rax
    240a:	c6 00 00             	movb   $0x0,(%rax)
	return (res);
    240d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    2411:	c9                   	leave  
    2412:	c3                   	ret    

0000000000002413 <br_get_int32>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

int32_t	br_get_int32(t_binary_reader *this)
{
    2413:	f3 0f 1e fa          	endbr64 
    2417:	55                   	push   %rbp
    2418:	48 89 e5             	mov    %rsp,%rbp
    241b:	53                   	push   %rbx
    241c:	48 83 ec 18          	sub    $0x18,%rsp
    2420:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	if (this->endian == READER_LITTLE_ENDIAN)
    2424:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2428:	8b 40 14             	mov    0x14(%rax),%eax
    242b:	83 f8 01             	cmp    $0x1,%eax
    242e:	75 61                	jne    2491 <br_get_int32+0x7e>
	{
		return ((this->get_uint8(this))
    2430:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2434:	48 8b 50 28          	mov    0x28(%rax),%rdx
    2438:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    243c:	48 89 c7             	mov    %rax,%rdi
    243f:	ff d2                	call   *%rdx
    2441:	0f b6 d8             	movzbl %al,%ebx
			| (this->get_uint8(this) << 8)
    2444:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2448:	48 8b 50 28          	mov    0x28(%rax),%rdx
    244c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2450:	48 89 c7             	mov    %rax,%rdi
    2453:	ff d2                	call   *%rdx
    2455:	0f b6 c0             	movzbl %al,%eax
    2458:	c1 e0 08             	shl    $0x8,%eax
    245b:	09 c3                	or     %eax,%ebx
			| (this->get_uint8(this) << 16)
    245d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2461:	48 8b 50 28          	mov    0x28(%rax),%rdx
    2465:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2469:	48 89 c7             	mov    %rax,%rdi
    246c:	ff d2                	call   *%rdx
    246e:	0f b6 c0             	movzbl %al,%eax
    2471:	c1 e0 10             	shl    $0x10,%eax
    2474:	09 c3                	or     %eax,%ebx
			| (this->get_uint8(this) << 24));
    2476:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    247a:	48 8b 50 28          	mov    0x28(%rax),%rdx
    247e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2482:	48 89 c7             	mov    %rax,%rdi
    2485:	ff d2                	call   *%rdx
    2487:	0f b6 c0             	movzbl %al,%eax
    248a:	c1 e0 18             	shl    $0x18,%eax
    248d:	09 d8                	or     %ebx,%eax
    248f:	eb 61                	jmp    24f2 <br_get_int32+0xdf>
	}
	return ((this->get_uint8(this) << 24)
    2491:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2495:	48 8b 50 28          	mov    0x28(%rax),%rdx
    2499:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    249d:	48 89 c7             	mov    %rax,%rdi
    24a0:	ff d2                	call   *%rdx
    24a2:	0f b6 c0             	movzbl %al,%eax
    24a5:	c1 e0 18             	shl    $0x18,%eax
    24a8:	89 c3                	mov    %eax,%ebx
		| (this->get_uint8(this) << 16)
    24aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    24ae:	48 8b 50 28          	mov    0x28(%rax),%rdx
    24b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    24b6:	48 89 c7             	mov    %rax,%rdi
    24b9:	ff d2                	call   *%rdx
    24bb:	0f b6 c0             	movzbl %al,%eax
    24be:	c1 e0 10             	shl    $0x10,%eax
    24c1:	09 c3                	or     %eax,%ebx
		| (this->get_uint8(this) << 8)
    24c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    24c7:	48 8b 50 28          	mov    0x28(%rax),%rdx
    24cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    24cf:	48 89 c7             	mov    %rax,%rdi
    24d2:	ff d2                	call   *%rdx
    24d4:	0f b6 c0             	movzbl %al,%eax
    24d7:	c1 e0 08             	shl    $0x8,%eax
    24da:	09 c3                	or     %eax,%ebx
		| (this->get_uint8(this)));
    24dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    24e0:	48 8b 50 28          	mov    0x28(%rax),%rdx
    24e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    24e8:	48 89 c7             	mov    %rax,%rdi
    24eb:	ff d2                	call   *%rdx
    24ed:	0f b6 c0             	movzbl %al,%eax
    24f0:	09 d8                	or     %ebx,%eax
}
    24f2:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    24f6:	c9                   	leave  
    24f7:	c3                   	ret    

00000000000024f8 <br_get_int64>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

int64_t	br_get_int64(t_binary_reader *this)
{
    24f8:	f3 0f 1e fa          	endbr64 
    24fc:	55                   	push   %rbp
    24fd:	48 89 e5             	mov    %rsp,%rbp
    2500:	53                   	push   %rbx
    2501:	48 83 ec 18          	sub    $0x18,%rsp
    2505:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	if (this->endian == READER_LITTLE_ENDIAN)
    2509:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    250d:	8b 40 14             	mov    0x14(%rax),%eax
    2510:	83 f8 01             	cmp    $0x1,%eax
    2513:	75 2f                	jne    2544 <br_get_int64+0x4c>
	{
		return (this->get_uint32(this) | ((uint64_t)this->get_uint32(this) << 32));
    2515:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2519:	48 8b 50 38          	mov    0x38(%rax),%rdx
    251d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2521:	48 89 c7             	mov    %rax,%rdi
    2524:	ff d2                	call   *%rdx
    2526:	89 c3                	mov    %eax,%ebx
    2528:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    252c:	48 8b 50 38          	mov    0x38(%rax),%rdx
    2530:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2534:	48 89 c7             	mov    %rax,%rdi
    2537:	ff d2                	call   *%rdx
    2539:	89 c0                	mov    %eax,%eax
    253b:	48 c1 e0 20          	shl    $0x20,%rax
    253f:	48 09 d8             	or     %rbx,%rax
    2542:	eb 30                	jmp    2574 <br_get_int64+0x7c>
	}
	return (((uint64_t)this->get_uint32(this) << 32) | this->get_uint32(this));
    2544:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2548:	48 8b 50 38          	mov    0x38(%rax),%rdx
    254c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2550:	48 89 c7             	mov    %rax,%rdi
    2553:	ff d2                	call   *%rdx
    2555:	89 c0                	mov    %eax,%eax
    2557:	48 c1 e0 20          	shl    $0x20,%rax
    255b:	48 89 c3             	mov    %rax,%rbx
    255e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2562:	48 8b 50 38          	mov    0x38(%rax),%rdx
    2566:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    256a:	48 89 c7             	mov    %rax,%rdi
    256d:	ff d2                	call   *%rdx
    256f:	89 c0                	mov    %eax,%eax
    2571:	48 09 d8             	or     %rbx,%rax
}
    2574:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    2578:	c9                   	leave  
    2579:	c3                   	ret    

000000000000257a <br_get_uint16>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

uint16_t	br_get_uint16(t_binary_reader *this)
{
    257a:	f3 0f 1e fa          	endbr64 
    257e:	55                   	push   %rbp
    257f:	48 89 e5             	mov    %rsp,%rbp
    2582:	53                   	push   %rbx
    2583:	48 83 ec 18          	sub    $0x18,%rsp
    2587:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	if (this->endian == READER_LITTLE_ENDIAN)
    258b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    258f:	8b 40 14             	mov    0x14(%rax),%eax
    2592:	83 f8 01             	cmp    $0x1,%eax
    2595:	75 2f                	jne    25c6 <br_get_uint16+0x4c>
	{
		return (this->get_uint8(this) | (this->get_uint8(this) << 8));
    2597:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    259b:	48 8b 50 28          	mov    0x28(%rax),%rdx
    259f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    25a3:	48 89 c7             	mov    %rax,%rdi
    25a6:	ff d2                	call   *%rdx
    25a8:	0f b6 d8             	movzbl %al,%ebx
    25ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    25af:	48 8b 50 28          	mov    0x28(%rax),%rdx
    25b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    25b7:	48 89 c7             	mov    %rax,%rdi
    25ba:	ff d2                	call   *%rdx
    25bc:	0f b6 c0             	movzbl %al,%eax
    25bf:	c1 e0 08             	shl    $0x8,%eax
    25c2:	09 d8                	or     %ebx,%eax
    25c4:	eb 2f                	jmp    25f5 <br_get_uint16+0x7b>
	}
	return ((this->get_uint8(this) << 8) | this->get_uint8(this));
    25c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    25ca:	48 8b 50 28          	mov    0x28(%rax),%rdx
    25ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    25d2:	48 89 c7             	mov    %rax,%rdi
    25d5:	ff d2                	call   *%rdx
    25d7:	0f b6 c0             	movzbl %al,%eax
    25da:	c1 e0 08             	shl    $0x8,%eax
    25dd:	89 c3                	mov    %eax,%ebx
    25df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    25e3:	48 8b 50 28          	mov    0x28(%rax),%rdx
    25e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    25eb:	48 89 c7             	mov    %rax,%rdi
    25ee:	ff d2                	call   *%rdx
    25f0:	0f b6 c0             	movzbl %al,%eax
    25f3:	09 d8                	or     %ebx,%eax
}
    25f5:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    25f9:	c9                   	leave  
    25fa:	c3                   	ret    

00000000000025fb <br_get_uint32>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

uint32_t	br_get_uint32(t_binary_reader *this)
{
    25fb:	f3 0f 1e fa          	endbr64 
    25ff:	55                   	push   %rbp
    2600:	48 89 e5             	mov    %rsp,%rbp
    2603:	53                   	push   %rbx
    2604:	48 83 ec 18          	sub    $0x18,%rsp
    2608:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	if (this->endian == READER_LITTLE_ENDIAN)
    260c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2610:	8b 40 14             	mov    0x14(%rax),%eax
    2613:	83 f8 01             	cmp    $0x1,%eax
    2616:	75 61                	jne    2679 <br_get_uint32+0x7e>
	{
		return ((this->get_uint8(this))
    2618:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    261c:	48 8b 50 28          	mov    0x28(%rax),%rdx
    2620:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2624:	48 89 c7             	mov    %rax,%rdi
    2627:	ff d2                	call   *%rdx
    2629:	0f b6 d8             	movzbl %al,%ebx
			| (this->get_uint8(this) << 8)
    262c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2630:	48 8b 50 28          	mov    0x28(%rax),%rdx
    2634:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2638:	48 89 c7             	mov    %rax,%rdi
    263b:	ff d2                	call   *%rdx
    263d:	0f b6 c0             	movzbl %al,%eax
    2640:	c1 e0 08             	shl    $0x8,%eax
    2643:	09 c3                	or     %eax,%ebx
			| (this->get_uint8(this) << 16)
    2645:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2649:	48 8b 50 28          	mov    0x28(%rax),%rdx
    264d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2651:	48 89 c7             	mov    %rax,%rdi
    2654:	ff d2                	call   *%rdx
    2656:	0f b6 c0             	movzbl %al,%eax
    2659:	c1 e0 10             	shl    $0x10,%eax
    265c:	09 c3                	or     %eax,%ebx
			| (this->get_uint8(this) << 24));
    265e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2662:	48 8b 50 28          	mov    0x28(%rax),%rdx
    2666:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    266a:	48 89 c7             	mov    %rax,%rdi
    266d:	ff d2                	call   *%rdx
    266f:	0f b6 c0             	movzbl %al,%eax
    2672:	c1 e0 18             	shl    $0x18,%eax
    2675:	09 d8                	or     %ebx,%eax
    2677:	eb 61                	jmp    26da <br_get_uint32+0xdf>
	}
	return ((this->get_uint8(this) << 24)
    2679:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    267d:	48 8b 50 28          	mov    0x28(%rax),%rdx
    2681:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2685:	48 89 c7             	mov    %rax,%rdi
    2688:	ff d2                	call   *%rdx
    268a:	0f b6 c0             	movzbl %al,%eax
    268d:	c1 e0 18             	shl    $0x18,%eax
    2690:	89 c3                	mov    %eax,%ebx
		| (this->get_uint8(this) << 16)
    2692:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2696:	48 8b 50 28          	mov    0x28(%rax),%rdx
    269a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    269e:	48 89 c7             	mov    %rax,%rdi
    26a1:	ff d2                	call   *%rdx
    26a3:	0f b6 c0             	movzbl %al,%eax
    26a6:	c1 e0 10             	shl    $0x10,%eax
    26a9:	09 c3                	or     %eax,%ebx
		| (this->get_uint8(this) << 8)
    26ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    26af:	48 8b 50 28          	mov    0x28(%rax),%rdx
    26b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    26b7:	48 89 c7             	mov    %rax,%rdi
    26ba:	ff d2                	call   *%rdx
    26bc:	0f b6 c0             	movzbl %al,%eax
    26bf:	c1 e0 08             	shl    $0x8,%eax
    26c2:	09 c3                	or     %eax,%ebx
		| (this->get_uint8(this)));
    26c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    26c8:	48 8b 50 28          	mov    0x28(%rax),%rdx
    26cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    26d0:	48 89 c7             	mov    %rax,%rdi
    26d3:	ff d2                	call   *%rdx
    26d5:	0f b6 c0             	movzbl %al,%eax
    26d8:	09 d8                	or     %ebx,%eax
}
    26da:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    26de:	c9                   	leave  
    26df:	c3                   	ret    

00000000000026e0 <br_set_endian>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

void	br_set_endian(t_binary_reader *this, int endian)
{
    26e0:	f3 0f 1e fa          	endbr64 
    26e4:	55                   	push   %rbp
    26e5:	48 89 e5             	mov    %rsp,%rbp
    26e8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    26ec:	89 75 f4             	mov    %esi,-0xc(%rbp)
	this->endian = endian;
    26ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    26f3:	8b 55 f4             	mov    -0xc(%rbp),%edx
    26f6:	89 50 14             	mov    %edx,0x14(%rax)
}
    26f9:	90                   	nop
    26fa:	5d                   	pop    %rbp
    26fb:	c3                   	ret    

00000000000026fc <br_slice>:

#include "reader/binary_reader.h"

t_binary_reader	*br_slice(t_binary_reader *this, uint32_t start,
	uint32_t length)
{
    26fc:	f3 0f 1e fa          	endbr64 
    2700:	55                   	push   %rbp
    2701:	48 89 e5             	mov    %rsp,%rbp
    2704:	48 83 ec 20          	sub    $0x20,%rsp
    2708:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    270c:	89 75 e4             	mov    %esi,-0x1c(%rbp)
    270f:	89 55 e0             	mov    %edx,-0x20(%rbp)
	t_binary_reader	*reader;

	reader = ft_calloc(1, sizeof(t_binary_reader));
    2712:	be b0 00 00 00       	mov    $0xb0,%esi
    2717:	bf 01 00 00 00       	mov    $0x1,%edi
    271c:	e8 ed 08 00 00       	call   300e <ft_calloc>
    2721:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!reader)
    2725:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    272a:	75 07                	jne    2733 <br_slice+0x37>
		return (NULL);
    272c:	b8 00 00 00 00       	mov    $0x0,%eax
    2731:	eb 6a                	jmp    279d <br_slice+0xa1>
	reader->data = malloc(length * sizeof(char));
    2733:	8b 45 e0             	mov    -0x20(%rbp),%eax
    2736:	48 89 c7             	mov    %rax,%rdi
    2739:	e8 e2 f9 ff ff       	call   2120 <malloc@plt>
    273e:	48 89 c2             	mov    %rax,%rdx
    2741:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2745:	48 89 50 08          	mov    %rdx,0x8(%rax)
	if (!reader->data)
    2749:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    274d:	48 8b 40 08          	mov    0x8(%rax),%rax
    2751:	48 85 c0             	test   %rax,%rax
    2754:	75 13                	jne    2769 <br_slice+0x6d>
		return (free(reader), NULL);
    2756:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    275a:	48 89 c7             	mov    %rax,%rdi
    275d:	e8 ce f8 ff ff       	call   2030 <free@plt>
    2762:	b8 00 00 00 00       	mov    $0x0,%eax
    2767:	eb 34                	jmp    279d <br_slice+0xa1>
	ft_memcpy(reader->data, this->data + start, length);
    2769:	8b 55 e0             	mov    -0x20(%rbp),%edx
    276c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2770:	48 8b 48 08          	mov    0x8(%rax),%rcx
    2774:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    2777:	48 01 c1             	add    %rax,%rcx
    277a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    277e:	48 8b 40 08          	mov    0x8(%rax),%rax
    2782:	48 89 ce             	mov    %rcx,%rsi
    2785:	48 89 c7             	mov    %rax,%rdi
    2788:	e8 94 0e 00 00       	call   3621 <ft_memcpy>
	init_binary_reader(reader);
    278d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2791:	48 89 c7             	mov    %rax,%rdi
    2794:	e8 6f 04 00 00       	call   2c08 <init_binary_reader>
	return (reader);
    2799:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    279d:	c9                   	leave  
    279e:	c3                   	ret    

000000000000279f <br_get_string>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

char	*br_get_string(t_binary_reader *this, uint16_t length)
{
    279f:	f3 0f 1e fa          	endbr64 
    27a3:	55                   	push   %rbp
    27a4:	48 89 e5             	mov    %rsp,%rbp
    27a7:	48 83 ec 20          	sub    $0x20,%rsp
    27ab:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    27af:	89 f0                	mov    %esi,%eax
    27b1:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	int		i;
	char	*res;

	res = malloc((length + 1) * sizeof(char));
    27b5:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
    27b9:	83 c0 01             	add    $0x1,%eax
    27bc:	48 98                	cltq   
    27be:	48 89 c7             	mov    %rax,%rdi
    27c1:	e8 5a f9 ff ff       	call   2120 <malloc@plt>
    27c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!res)
    27ca:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    27cf:	75 07                	jne    27d8 <br_get_string+0x39>
		return (NULL);
    27d1:	b8 00 00 00 00       	mov    $0x0,%eax
    27d6:	eb 4c                	jmp    2824 <br_get_string+0x85>
	i = -1;
    27d8:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%rbp)
	while (++i < length)
    27df:	eb 22                	jmp    2803 <br_get_string+0x64>
		res[i] = this->get_uint8(this);
    27e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    27e5:	48 8b 50 28          	mov    0x28(%rax),%rdx
    27e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    27ed:	48 89 c7             	mov    %rax,%rdi
    27f0:	ff d2                	call   *%rdx
    27f2:	89 c2                	mov    %eax,%edx
    27f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
    27f7:	48 63 c8             	movslq %eax,%rcx
    27fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    27fe:	48 01 c8             	add    %rcx,%rax
    2801:	88 10                	mov    %dl,(%rax)
	while (++i < length)
    2803:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
    2807:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
    280b:	39 45 f4             	cmp    %eax,-0xc(%rbp)
    280e:	7c d1                	jl     27e1 <br_get_string+0x42>
	res[i] = 0;
    2810:	8b 45 f4             	mov    -0xc(%rbp),%eax
    2813:	48 63 d0             	movslq %eax,%rdx
    2816:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    281a:	48 01 d0             	add    %rdx,%rax
    281d:	c6 00 00             	movb   $0x0,(%rax)
	return (res);
    2820:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    2824:	c9                   	leave  
    2825:	c3                   	ret    

0000000000002826 <br_get_rstring>:

char	*br_get_rstring(t_binary_reader *this)
{
    2826:	f3 0f 1e fa          	endbr64 
    282a:	55                   	push   %rbp
    282b:	48 89 e5             	mov    %rsp,%rbp
    282e:	48 83 ec 30          	sub    $0x30,%rsp
    2832:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    2836:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    283d:	00 00 
    283f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    2843:	31 c0                	xor    %eax,%eax
	uint8_t	c;
	uint8_t	*res;
	int		i = 0;
    2845:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	res = ft_calloc(1, sizeof(char));
    284c:	be 01 00 00 00       	mov    $0x1,%esi
    2851:	bf 01 00 00 00       	mov    $0x1,%edi
    2856:	e8 b3 07 00 00       	call   300e <ft_calloc>
    285b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while ((c = this->get_uint8(this)) != 0)
    285f:	eb 2e                	jmp    288f <br_get_rstring+0x69>
	{
		res = ft_memjoin(res, &c, i, 1);
    2861:	8b 55 ec             	mov    -0x14(%rbp),%edx
    2864:	48 8d 75 eb          	lea    -0x15(%rbp),%rsi
    2868:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    286c:	b9 01 00 00 00       	mov    $0x1,%ecx
    2871:	48 89 c7             	mov    %rax,%rdi
    2874:	e8 c1 01 00 00       	call   2a3a <ft_memjoin>
    2879:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (!res)
    287d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
    2882:	75 07                	jne    288b <br_get_rstring+0x65>
			return (NULL);
    2884:	b8 00 00 00 00       	mov    $0x0,%eax
    2889:	eb 3c                	jmp    28c7 <br_get_rstring+0xa1>
		i++;
    288b:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
	while ((c = this->get_uint8(this)) != 0)
    288f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    2893:	48 8b 50 28          	mov    0x28(%rax),%rdx
    2897:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    289b:	48 89 c7             	mov    %rax,%rdi
    289e:	ff d2                	call   *%rdx
    28a0:	88 45 eb             	mov    %al,-0x15(%rbp)
    28a3:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
    28a7:	84 c0                	test   %al,%al
    28a9:	75 b6                	jne    2861 <br_get_rstring+0x3b>
	}
	return ((char *)ft_memjoin(res, (uint8_t *)"\0", i, 1));
    28ab:	8b 55 ec             	mov    -0x14(%rbp),%edx
    28ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    28b2:	b9 01 00 00 00       	mov    $0x1,%ecx
    28b7:	48 8d 35 46 57 00 00 	lea    0x5746(%rip),%rsi        # 8004 <_IO_stdin_used+0x4>
    28be:	48 89 c7             	mov    %rax,%rdi
    28c1:	e8 74 01 00 00       	call   2a3a <ft_memjoin>
    28c6:	90                   	nop
}
    28c7:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    28cb:	64 48 2b 0c 25 28 00 	sub    %fs:0x28,%rcx
    28d2:	00 00 
    28d4:	74 05                	je     28db <br_get_rstring+0xb5>
    28d6:	e8 a5 f7 ff ff       	call   2080 <__stack_chk_fail@plt>
    28db:	c9                   	leave  
    28dc:	c3                   	ret    

00000000000028dd <br_get_uint8>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

uint8_t	br_get_uint8(t_binary_reader *this)
{
    28dd:	f3 0f 1e fa          	endbr64 
    28e1:	55                   	push   %rbp
    28e2:	48 89 e5             	mov    %rsp,%rbp
    28e5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (this->_pos >= this->size)
    28e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    28ed:	8b 10                	mov    (%rax),%edx
    28ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    28f3:	8b 40 10             	mov    0x10(%rax),%eax
    28f6:	39 c2                	cmp    %eax,%edx
    28f8:	72 07                	jb     2901 <br_get_uint8+0x24>
		return (0);
    28fa:	b8 00 00 00 00       	mov    $0x0,%eax
    28ff:	eb 1f                	jmp    2920 <br_get_uint8+0x43>
	return (this->data[this->_pos++]);
    2901:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2905:	48 8b 70 08          	mov    0x8(%rax),%rsi
    2909:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    290d:	8b 00                	mov    (%rax),%eax
    290f:	8d 48 01             	lea    0x1(%rax),%ecx
    2912:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    2916:	89 0a                	mov    %ecx,(%rdx)
    2918:	89 c0                	mov    %eax,%eax
    291a:	48 01 f0             	add    %rsi,%rax
    291d:	0f b6 00             	movzbl (%rax),%eax
}
    2920:	5d                   	pop    %rbp
    2921:	c3                   	ret    

0000000000002922 <br_get_bytes>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

size_t	br_get_bytes(t_binary_reader *this, char *target, size_t length)
{
    2922:	f3 0f 1e fa          	endbr64 
    2926:	55                   	push   %rbp
    2927:	48 89 e5             	mov    %rsp,%rbp
    292a:	48 83 ec 30          	sub    $0x30,%rsp
    292e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    2932:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    2936:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t	i = 0;
    293a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    2941:	00 

	if (!target)
    2942:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
    2947:	75 06                	jne    294f <br_get_bytes+0x2d>
		return (i);
    2949:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    294d:	eb 67                	jmp    29b6 <br_get_bytes+0x94>
	if (this->_pos + length > this->size)
    294f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2953:	8b 00                	mov    (%rax),%eax
    2955:	89 c2                	mov    %eax,%edx
    2957:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    295b:	48 01 c2             	add    %rax,%rdx
    295e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2962:	8b 40 10             	mov    0x10(%rax),%eax
    2965:	89 c0                	mov    %eax,%eax
    2967:	48 39 c2             	cmp    %rax,%rdx
    296a:	76 3c                	jbe    29a8 <br_get_bytes+0x86>
		length = this->size - this->_pos;
    296c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2970:	8b 50 10             	mov    0x10(%rax),%edx
    2973:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2977:	8b 00                	mov    (%rax),%eax
    2979:	29 c2                	sub    %eax,%edx
    297b:	89 d0                	mov    %edx,%eax
    297d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	for (; i < length; i++)
    2981:	eb 25                	jmp    29a8 <br_get_bytes+0x86>
	{
		target[i] = this->get_uint8(this);
    2983:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2987:	48 8b 50 28          	mov    0x28(%rax),%rdx
    298b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    298f:	48 89 c7             	mov    %rax,%rdi
    2992:	ff d2                	call   *%rdx
    2994:	89 c2                	mov    %eax,%edx
    2996:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
    299a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    299e:	48 01 c8             	add    %rcx,%rax
    29a1:	88 10                	mov    %dl,(%rax)
	for (; i < length; i++)
    29a3:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
    29a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    29ac:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
    29b0:	72 d1                	jb     2983 <br_get_bytes+0x61>
	}
	return (i);
    29b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    29b6:	c9                   	leave  
    29b7:	c3                   	ret    

00000000000029b8 <br_get_uint64>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

uint64_t	br_get_uint64(t_binary_reader *this)
{
    29b8:	f3 0f 1e fa          	endbr64 
    29bc:	55                   	push   %rbp
    29bd:	48 89 e5             	mov    %rsp,%rbp
    29c0:	53                   	push   %rbx
    29c1:	48 83 ec 18          	sub    $0x18,%rsp
    29c5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	if (this->endian == READER_LITTLE_ENDIAN)
    29c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    29cd:	8b 40 14             	mov    0x14(%rax),%eax
    29d0:	83 f8 01             	cmp    $0x1,%eax
    29d3:	75 2f                	jne    2a04 <br_get_uint64+0x4c>
	{
		return (this->get_uint32(this) | ((uint64_t)this->get_uint32(this) << 32));
    29d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    29d9:	48 8b 50 38          	mov    0x38(%rax),%rdx
    29dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    29e1:	48 89 c7             	mov    %rax,%rdi
    29e4:	ff d2                	call   *%rdx
    29e6:	89 c3                	mov    %eax,%ebx
    29e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    29ec:	48 8b 50 38          	mov    0x38(%rax),%rdx
    29f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    29f4:	48 89 c7             	mov    %rax,%rdi
    29f7:	ff d2                	call   *%rdx
    29f9:	89 c0                	mov    %eax,%eax
    29fb:	48 c1 e0 20          	shl    $0x20,%rax
    29ff:	48 09 d8             	or     %rbx,%rax
    2a02:	eb 30                	jmp    2a34 <br_get_uint64+0x7c>
	}
	return (((uint64_t)this->get_uint32(this) << 32) | this->get_uint32(this));
    2a04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2a08:	48 8b 50 38          	mov    0x38(%rax),%rdx
    2a0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2a10:	48 89 c7             	mov    %rax,%rdi
    2a13:	ff d2                	call   *%rdx
    2a15:	89 c0                	mov    %eax,%eax
    2a17:	48 c1 e0 20          	shl    $0x20,%rax
    2a1b:	48 89 c3             	mov    %rax,%rbx
    2a1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2a22:	48 8b 50 38          	mov    0x38(%rax),%rdx
    2a26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2a2a:	48 89 c7             	mov    %rax,%rdi
    2a2d:	ff d2                	call   *%rdx
    2a2f:	89 c0                	mov    %eax,%eax
    2a31:	48 09 d8             	or     %rbx,%rax
}
    2a34:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    2a38:	c9                   	leave  
    2a39:	c3                   	ret    

0000000000002a3a <ft_memjoin>:

#include "reader/binary_reader.h"

unsigned char	*ft_memjoin(unsigned char *s1, unsigned char *s2,
	uint32_t size, uint32_t length)
{
    2a3a:	f3 0f 1e fa          	endbr64 
    2a3e:	55                   	push   %rbp
    2a3f:	48 89 e5             	mov    %rsp,%rbp
    2a42:	48 83 ec 30          	sub    $0x30,%rsp
    2a46:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    2a4a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    2a4e:	89 55 dc             	mov    %edx,-0x24(%rbp)
    2a51:	89 4d d8             	mov    %ecx,-0x28(%rbp)
	unsigned char	*str;

	if (!s1)
    2a54:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    2a59:	75 0e                	jne    2a69 <ft_memjoin+0x2f>
		s1 = (unsigned char *)malloc(sizeof(unsigned char));
    2a5b:	bf 01 00 00 00       	mov    $0x1,%edi
    2a60:	e8 bb f6 ff ff       	call   2120 <malloc@plt>
    2a65:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (!s1)
    2a69:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    2a6e:	75 0a                	jne    2a7a <ft_memjoin+0x40>
		return (NULL);
    2a70:	b8 00 00 00 00       	mov    $0x0,%eax
    2a75:	e9 8c 00 00 00       	jmp    2b06 <ft_memjoin+0xcc>
	if (!s2)
    2a7a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
    2a7f:	75 13                	jne    2a94 <ft_memjoin+0x5a>
		return (free(s1), NULL);
    2a81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2a85:	48 89 c7             	mov    %rax,%rdi
    2a88:	e8 a3 f5 ff ff       	call   2030 <free@plt>
    2a8d:	b8 00 00 00 00       	mov    $0x0,%eax
    2a92:	eb 72                	jmp    2b06 <ft_memjoin+0xcc>
	str = malloc(sizeof(unsigned char) * (size + length));
    2a94:	8b 55 dc             	mov    -0x24(%rbp),%edx
    2a97:	8b 45 d8             	mov    -0x28(%rbp),%eax
    2a9a:	01 d0                	add    %edx,%eax
    2a9c:	89 c0                	mov    %eax,%eax
    2a9e:	48 89 c7             	mov    %rax,%rdi
    2aa1:	e8 7a f6 ff ff       	call   2120 <malloc@plt>
    2aa6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!str)
    2aaa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    2aaf:	75 13                	jne    2ac4 <ft_memjoin+0x8a>
		return (free(s1), NULL);
    2ab1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2ab5:	48 89 c7             	mov    %rax,%rdi
    2ab8:	e8 73 f5 ff ff       	call   2030 <free@plt>
    2abd:	b8 00 00 00 00       	mov    $0x0,%eax
    2ac2:	eb 42                	jmp    2b06 <ft_memjoin+0xcc>
	ft_memcpy(str, s1, size);
    2ac4:	8b 55 dc             	mov    -0x24(%rbp),%edx
    2ac7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
    2acb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2acf:	48 89 ce             	mov    %rcx,%rsi
    2ad2:	48 89 c7             	mov    %rax,%rdi
    2ad5:	e8 47 0b 00 00       	call   3621 <ft_memcpy>
	ft_memcpy(str + size, s2, length);
    2ada:	8b 55 d8             	mov    -0x28(%rbp),%edx
    2add:	8b 4d dc             	mov    -0x24(%rbp),%ecx
    2ae0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2ae4:	48 01 c1             	add    %rax,%rcx
    2ae7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    2aeb:	48 89 c6             	mov    %rax,%rsi
    2aee:	48 89 cf             	mov    %rcx,%rdi
    2af1:	e8 2b 0b 00 00       	call   3621 <ft_memcpy>
	free(s1);
    2af6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2afa:	48 89 c7             	mov    %rax,%rdi
    2afd:	e8 2e f5 ff ff       	call   2030 <free@plt>
	return (str);
    2b02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    2b06:	c9                   	leave  
    2b07:	c3                   	ret    

0000000000002b08 <ft_read_file>:
/* ************************************************************************** */

#include "reader/binary_reader.h"

unsigned char	*ft_read_file(int fd, unsigned char *file, uint32_t *rsize)
{
    2b08:	f3 0f 1e fa          	endbr64 
    2b0c:	55                   	push   %rbp
    2b0d:	48 89 e5             	mov    %rsp,%rbp
    2b10:	48 83 ec 30          	sub    $0x30,%rsp
    2b14:	89 7d ec             	mov    %edi,-0x14(%rbp)
    2b17:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    2b1b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	unsigned char	*buff;
	int				read_bytes;
	uint32_t		size;

	size = 0;
    2b1f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	buff = ft_calloc((BUFFER_SIZE + 1), sizeof(unsigned char));
    2b26:	be 01 00 00 00       	mov    $0x1,%esi
    2b2b:	bf 01 04 00 00       	mov    $0x401,%edi
    2b30:	e8 d9 04 00 00       	call   300e <ft_calloc>
    2b35:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!buff)
    2b39:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    2b3e:	75 0a                	jne    2b4a <ft_read_file+0x42>
		return (NULL);
    2b40:	b8 00 00 00 00       	mov    $0x0,%eax
    2b45:	e9 bc 00 00 00       	jmp    2c06 <ft_read_file+0xfe>
	read_bytes = 1;
    2b4a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%rbp)
	lseek(fd, 0, SEEK_SET);
    2b51:	8b 45 ec             	mov    -0x14(%rbp),%eax
    2b54:	ba 00 00 00 00       	mov    $0x0,%edx
    2b59:	be 00 00 00 00       	mov    $0x0,%esi
    2b5e:	89 c7                	mov    %eax,%edi
    2b60:	e8 4b f5 ff ff       	call   20b0 <lseek@plt>
	while (read_bytes != 0)
    2b65:	eb 7c                	jmp    2be3 <ft_read_file+0xdb>
	{
		read_bytes = read(fd, buff, BUFFER_SIZE);
    2b67:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    2b6b:	8b 45 ec             	mov    -0x14(%rbp),%eax
    2b6e:	ba 00 04 00 00       	mov    $0x400,%edx
    2b73:	48 89 ce             	mov    %rcx,%rsi
    2b76:	89 c7                	mov    %eax,%edi
    2b78:	e8 63 f5 ff ff       	call   20e0 <read@plt>
    2b7d:	89 45 f0             	mov    %eax,-0x10(%rbp)
		if (read_bytes == -1)
    2b80:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%rbp)
    2b84:	75 13                	jne    2b99 <ft_read_file+0x91>
			return (free(buff), NULL);
    2b86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2b8a:	48 89 c7             	mov    %rax,%rdi
    2b8d:	e8 9e f4 ff ff       	call   2030 <free@plt>
    2b92:	b8 00 00 00 00       	mov    $0x0,%eax
    2b97:	eb 6d                	jmp    2c06 <ft_read_file+0xfe>
		buff[read_bytes] = '\0';
    2b99:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2b9c:	48 63 d0             	movslq %eax,%rdx
    2b9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2ba3:	48 01 d0             	add    %rdx,%rax
    2ba6:	c6 00 00             	movb   $0x0,(%rax)
		file = ft_memjoin(file, buff, size, read_bytes);
    2ba9:	8b 4d f0             	mov    -0x10(%rbp),%ecx
    2bac:	8b 55 f4             	mov    -0xc(%rbp),%edx
    2baf:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
    2bb3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    2bb7:	48 89 c7             	mov    %rax,%rdi
    2bba:	e8 7b fe ff ff       	call   2a3a <ft_memjoin>
    2bbf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if (!file)
    2bc3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
    2bc8:	75 13                	jne    2bdd <ft_read_file+0xd5>
			return (free(buff), NULL);
    2bca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2bce:	48 89 c7             	mov    %rax,%rdi
    2bd1:	e8 5a f4 ff ff       	call   2030 <free@plt>
    2bd6:	b8 00 00 00 00       	mov    $0x0,%eax
    2bdb:	eb 29                	jmp    2c06 <ft_read_file+0xfe>
		size += read_bytes;
    2bdd:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2be0:	01 45 f4             	add    %eax,-0xc(%rbp)
	while (read_bytes != 0)
    2be3:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
    2be7:	0f 85 7a ff ff ff    	jne    2b67 <ft_read_file+0x5f>
	}
	*rsize = size;
    2bed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    2bf1:	8b 55 f4             	mov    -0xc(%rbp),%edx
    2bf4:	89 10                	mov    %edx,(%rax)
	free(buff);
    2bf6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2bfa:	48 89 c7             	mov    %rax,%rdi
    2bfd:	e8 2e f4 ff ff       	call   2030 <free@plt>
	return (file);
    2c02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
    2c06:	c9                   	leave  
    2c07:	c3                   	ret    

0000000000002c08 <init_binary_reader>:
/* ************************************************************************** */

#include "binary_reader.h"

void	init_binary_reader(t_binary_reader *reader)
{
    2c08:	f3 0f 1e fa          	endbr64 
    2c0c:	55                   	push   %rbp
    2c0d:	48 89 e5             	mov    %rsp,%rbp
    2c10:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	reader->seek = &br_seek;
    2c14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c18:	48 8d 15 2d f7 ff ff 	lea    -0x8d3(%rip),%rdx        # 234c <br_seek>
    2c1f:	48 89 50 18          	mov    %rdx,0x18(%rax)
	reader->tell = &br_tell;
    2c23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c27:	48 8d 15 44 f7 ff ff 	lea    -0x8bc(%rip),%rdx        # 2372 <br_tell>
    2c2e:	48 89 50 20          	mov    %rdx,0x20(%rax)
	reader->get_uint8 = &br_get_uint8;
    2c32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c36:	48 8d 15 a0 fc ff ff 	lea    -0x360(%rip),%rdx        # 28dd <br_get_uint8>
    2c3d:	48 89 50 28          	mov    %rdx,0x28(%rax)
	reader->get_uint16 = &br_get_uint16;
    2c41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c45:	48 8d 15 2e f9 ff ff 	lea    -0x6d2(%rip),%rdx        # 257a <br_get_uint16>
    2c4c:	48 89 50 30          	mov    %rdx,0x30(%rax)
	reader->get_uint32 = &br_get_uint32;
    2c50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c54:	48 8d 15 a0 f9 ff ff 	lea    -0x660(%rip),%rdx        # 25fb <br_get_uint32>
    2c5b:	48 89 50 38          	mov    %rdx,0x38(%rax)
	reader->get_uint64 = &br_get_uint64;
    2c5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c63:	48 8d 15 4e fd ff ff 	lea    -0x2b2(%rip),%rdx        # 29b8 <br_get_uint64>
    2c6a:	48 89 50 40          	mov    %rdx,0x40(%rax)
	reader->get_int16 = &br_get_int16;
    2c6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c72:	48 8d 15 a3 f6 ff ff 	lea    -0x95d(%rip),%rdx        # 231c <br_get_int16>
    2c79:	48 89 50 48          	mov    %rdx,0x48(%rax)
	reader->get_int32 = &br_get_int32;
    2c7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c81:	48 8d 15 8b f7 ff ff 	lea    -0x875(%rip),%rdx        # 2413 <br_get_int32>
    2c88:	48 89 50 50          	mov    %rdx,0x50(%rax)
	reader->get_int64 = &br_get_int64;
    2c8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c90:	48 8d 15 61 f8 ff ff 	lea    -0x79f(%rip),%rdx        # 24f8 <br_get_int64>
    2c97:	48 89 50 58          	mov    %rdx,0x58(%rax)
	reader->get_fword = &br_get_fword;
    2c9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2c9f:	48 8d 15 53 f6 ff ff 	lea    -0x9ad(%rip),%rdx        # 22f9 <br_get_fword>
    2ca6:	48 89 50 60          	mov    %rdx,0x60(%rax)
	reader->get_fixed = &br_get_fixed;
    2caa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2cae:	48 8d 15 13 f6 ff ff 	lea    -0x9ed(%rip),%rdx        # 22c8 <br_get_fixed>
    2cb5:	48 89 50 70          	mov    %rdx,0x70(%rax)
	reader->get_string = &br_get_string;
    2cb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2cbd:	48 8d 15 db fa ff ff 	lea    -0x525(%rip),%rdx        # 279f <br_get_string>
    2cc4:	48 89 50 78          	mov    %rdx,0x78(%rax)
	reader->get_rstring = &br_get_rstring;
    2cc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2ccc:	48 8d 15 53 fb ff ff 	lea    -0x4ad(%rip),%rdx        # 2826 <br_get_rstring>
    2cd3:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
	reader->get_unicode_string = &br_get_unicode_string;
    2cda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2cde:	48 8d 15 a1 f6 ff ff 	lea    -0x95f(%rip),%rdx        # 2386 <br_get_unicode_string>
    2ce5:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	reader->get_bytes = &br_get_bytes;
    2cec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2cf0:	48 8d 15 2b fc ff ff 	lea    -0x3d5(%rip),%rdx        # 2922 <br_get_bytes>
    2cf7:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
	reader->get_date = &br_get_date;
    2cfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2d02:	48 8d 15 70 f5 ff ff 	lea    -0xa90(%rip),%rdx        # 2279 <br_get_date>
    2d09:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	reader->slice = &br_slice;
    2d10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2d14:	48 8d 15 e1 f9 ff ff 	lea    -0x61f(%rip),%rdx        # 26fc <br_slice>
    2d1b:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
	reader->set_endian = &br_set_endian;
    2d22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2d26:	48 8d 15 b3 f9 ff ff 	lea    -0x64d(%rip),%rdx        # 26e0 <br_set_endian>
    2d2d:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
    2d34:	90                   	nop
    2d35:	5d                   	pop    %rbp
    2d36:	c3                   	ret    

0000000000002d37 <delete_binary_reader>:

void	delete_binary_reader(t_binary_reader *this)
{
    2d37:	f3 0f 1e fa          	endbr64 
    2d3b:	55                   	push   %rbp
    2d3c:	48 89 e5             	mov    %rsp,%rbp
    2d3f:	48 83 ec 10          	sub    $0x10,%rsp
    2d43:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (!this)
    2d47:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    2d4c:	74 33                	je     2d81 <delete_binary_reader+0x4a>
		return ;
	if (this->data)
    2d4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2d52:	48 8b 40 08          	mov    0x8(%rax),%rax
    2d56:	48 85 c0             	test   %rax,%rax
    2d59:	74 10                	je     2d6b <delete_binary_reader+0x34>
		free(this->data);
    2d5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2d5f:	48 8b 40 08          	mov    0x8(%rax),%rax
    2d63:	48 89 c7             	mov    %rax,%rdi
    2d66:	e8 c5 f2 ff ff       	call   2030 <free@plt>
	free(this);
    2d6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2d6f:	48 89 c7             	mov    %rax,%rdi
    2d72:	e8 b9 f2 ff ff       	call   2030 <free@plt>
	this = NULL;
    2d77:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    2d7e:	00 
    2d7f:	eb 01                	jmp    2d82 <delete_binary_reader+0x4b>
		return ;
    2d81:	90                   	nop
}
    2d82:	c9                   	leave  
    2d83:	c3                   	ret    

0000000000002d84 <new_binary_reader>:

t_binary_reader	*new_binary_reader(int fd)
{
    2d84:	f3 0f 1e fa          	endbr64 
    2d88:	55                   	push   %rbp
    2d89:	48 89 e5             	mov    %rsp,%rbp
    2d8c:	48 83 ec 20          	sub    $0x20,%rsp
    2d90:	89 7d ec             	mov    %edi,-0x14(%rbp)
	t_binary_reader	*reader;

	reader = ft_calloc(1, sizeof(t_binary_reader));
    2d93:	be b0 00 00 00       	mov    $0xb0,%esi
    2d98:	bf 01 00 00 00       	mov    $0x1,%edi
    2d9d:	e8 6c 02 00 00       	call   300e <ft_calloc>
    2da2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!reader)
    2da6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    2dab:	75 07                	jne    2db4 <new_binary_reader+0x30>
		return (NULL);
    2dad:	b8 00 00 00 00       	mov    $0x0,%eax
    2db2:	eb 55                	jmp    2e09 <new_binary_reader+0x85>
	reader->data = ft_read_file(fd, reader->data, &reader->size);
    2db4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2db8:	48 8d 50 10          	lea    0x10(%rax),%rdx
    2dbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2dc0:	48 8b 48 08          	mov    0x8(%rax),%rcx
    2dc4:	8b 45 ec             	mov    -0x14(%rbp),%eax
    2dc7:	48 89 ce             	mov    %rcx,%rsi
    2dca:	89 c7                	mov    %eax,%edi
    2dcc:	e8 37 fd ff ff       	call   2b08 <ft_read_file>
    2dd1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    2dd5:	48 89 42 08          	mov    %rax,0x8(%rdx)
	if (!reader->data)
    2dd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2ddd:	48 8b 40 08          	mov    0x8(%rax),%rax
    2de1:	48 85 c0             	test   %rax,%rax
    2de4:	75 13                	jne    2df9 <new_binary_reader+0x75>
		return (free(reader), NULL);
    2de6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2dea:	48 89 c7             	mov    %rax,%rdi
    2ded:	e8 3e f2 ff ff       	call   2030 <free@plt>
    2df2:	b8 00 00 00 00       	mov    $0x0,%eax
    2df7:	eb 10                	jmp    2e09 <new_binary_reader+0x85>
	init_binary_reader(reader);
    2df9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2dfd:	48 89 c7             	mov    %rax,%rdi
    2e00:	e8 03 fe ff ff       	call   2c08 <init_binary_reader>
	return (reader);
    2e05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    2e09:	c9                   	leave  
    2e0a:	c3                   	ret    

0000000000002e0b <ft_ctoi>:
/* ************************************************************************** */

#include "utils.h"

int	ft_ctoi(const char str)
{
    2e0b:	f3 0f 1e fa          	endbr64 
    2e0f:	55                   	push   %rbp
    2e10:	48 89 e5             	mov    %rsp,%rbp
    2e13:	89 f8                	mov    %edi,%eax
    2e15:	88 45 ec             	mov    %al,-0x14(%rbp)
	unsigned long int	nbr;

	nbr = 0;
    2e18:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    2e1f:	00 
	if ((char)str == '-')
    2e20:	80 7d ec 2d          	cmpb   $0x2d,-0x14(%rbp)
    2e24:	75 07                	jne    2e2d <ft_ctoi+0x22>
		return (-1);
    2e26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    2e2b:	eb 34                	jmp    2e61 <ft_ctoi+0x56>
	if ((char)str >= '0' && (char)str <= '9')
    2e2d:	80 7d ec 2f          	cmpb   $0x2f,-0x14(%rbp)
    2e31:	7e 2a                	jle    2e5d <ft_ctoi+0x52>
    2e33:	80 7d ec 39          	cmpb   $0x39,-0x14(%rbp)
    2e37:	7f 24                	jg     2e5d <ft_ctoi+0x52>
		nbr = nbr * 10 + ((char)str - '0');
    2e39:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    2e3d:	48 89 d0             	mov    %rdx,%rax
    2e40:	48 c1 e0 02          	shl    $0x2,%rax
    2e44:	48 01 d0             	add    %rdx,%rax
    2e47:	48 01 c0             	add    %rax,%rax
    2e4a:	48 89 c2             	mov    %rax,%rdx
    2e4d:	0f be 45 ec          	movsbl -0x14(%rbp),%eax
    2e51:	83 e8 30             	sub    $0x30,%eax
    2e54:	48 98                	cltq   
    2e56:	48 01 d0             	add    %rdx,%rax
    2e59:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return (nbr);
    2e5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    2e61:	5d                   	pop    %rbp
    2e62:	c3                   	ret    

0000000000002e63 <ft_atoi>:

int	ft_atoi(const char *str)
{
    2e63:	f3 0f 1e fa          	endbr64 
    2e67:	55                   	push   %rbp
    2e68:	48 89 e5             	mov    %rsp,%rbp
    2e6b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int					i;
	unsigned long int	nbr;
	int					sign;

	i = 0;
    2e6f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	nbr = 0;
    2e76:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    2e7d:	00 
	sign = 0;
    2e7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (!str)
    2e85:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    2e8a:	75 0e                	jne    2e9a <ft_atoi+0x37>
		return (0);
    2e8c:	b8 00 00 00 00       	mov    $0x0,%eax
    2e91:	e9 08 01 00 00       	jmp    2f9e <ft_atoi+0x13b>
	while ((str[i] >= 9 && str[i] <= 13) || str[i] == ' ')
		i++;
    2e96:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
	while ((str[i] >= 9 && str[i] <= 13) || str[i] == ' ')
    2e9a:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2e9d:	48 63 d0             	movslq %eax,%rdx
    2ea0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2ea4:	48 01 d0             	add    %rdx,%rax
    2ea7:	0f b6 00             	movzbl (%rax),%eax
    2eaa:	3c 08                	cmp    $0x8,%al
    2eac:	7e 14                	jle    2ec2 <ft_atoi+0x5f>
    2eae:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2eb1:	48 63 d0             	movslq %eax,%rdx
    2eb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2eb8:	48 01 d0             	add    %rdx,%rax
    2ebb:	0f b6 00             	movzbl (%rax),%eax
    2ebe:	3c 0d                	cmp    $0xd,%al
    2ec0:	7e d4                	jle    2e96 <ft_atoi+0x33>
    2ec2:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2ec5:	48 63 d0             	movslq %eax,%rdx
    2ec8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2ecc:	48 01 d0             	add    %rdx,%rax
    2ecf:	0f b6 00             	movzbl (%rax),%eax
    2ed2:	3c 20                	cmp    $0x20,%al
    2ed4:	74 c0                	je     2e96 <ft_atoi+0x33>
	if ((char)str[i] == '-' || (char)str[i] == '+')
    2ed6:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2ed9:	48 63 d0             	movslq %eax,%rdx
    2edc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2ee0:	48 01 d0             	add    %rdx,%rax
    2ee3:	0f b6 00             	movzbl (%rax),%eax
    2ee6:	3c 2d                	cmp    $0x2d,%al
    2ee8:	74 14                	je     2efe <ft_atoi+0x9b>
    2eea:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2eed:	48 63 d0             	movslq %eax,%rdx
    2ef0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2ef4:	48 01 d0             	add    %rdx,%rax
    2ef7:	0f b6 00             	movzbl (%rax),%eax
    2efa:	3c 2b                	cmp    $0x2b,%al
    2efc:	75 59                	jne    2f57 <ft_atoi+0xf4>
		if ((char)str[i++] == '-')
    2efe:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2f01:	8d 50 01             	lea    0x1(%rax),%edx
    2f04:	89 55 f0             	mov    %edx,-0x10(%rbp)
    2f07:	48 63 d0             	movslq %eax,%rdx
    2f0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2f0e:	48 01 d0             	add    %rdx,%rax
    2f11:	0f b6 00             	movzbl (%rax),%eax
    2f14:	3c 2d                	cmp    $0x2d,%al
    2f16:	75 3f                	jne    2f57 <ft_atoi+0xf4>
			sign++;
    2f18:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	while ((char)str[i] >= '0' && (char)str[i] <= '9')
    2f1c:	eb 39                	jmp    2f57 <ft_atoi+0xf4>
		nbr = nbr * 10 + ((char)str[i++] - '0');
    2f1e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    2f22:	48 89 d0             	mov    %rdx,%rax
    2f25:	48 c1 e0 02          	shl    $0x2,%rax
    2f29:	48 01 d0             	add    %rdx,%rax
    2f2c:	48 01 c0             	add    %rax,%rax
    2f2f:	48 89 c1             	mov    %rax,%rcx
    2f32:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2f35:	8d 50 01             	lea    0x1(%rax),%edx
    2f38:	89 55 f0             	mov    %edx,-0x10(%rbp)
    2f3b:	48 63 d0             	movslq %eax,%rdx
    2f3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2f42:	48 01 d0             	add    %rdx,%rax
    2f45:	0f b6 00             	movzbl (%rax),%eax
    2f48:	0f be c0             	movsbl %al,%eax
    2f4b:	83 e8 30             	sub    $0x30,%eax
    2f4e:	48 98                	cltq   
    2f50:	48 01 c8             	add    %rcx,%rax
    2f53:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((char)str[i] >= '0' && (char)str[i] <= '9')
    2f57:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2f5a:	48 63 d0             	movslq %eax,%rdx
    2f5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2f61:	48 01 d0             	add    %rdx,%rax
    2f64:	0f b6 00             	movzbl (%rax),%eax
    2f67:	3c 2f                	cmp    $0x2f,%al
    2f69:	7e 14                	jle    2f7f <ft_atoi+0x11c>
    2f6b:	8b 45 f0             	mov    -0x10(%rbp),%eax
    2f6e:	48 63 d0             	movslq %eax,%rdx
    2f71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    2f75:	48 01 d0             	add    %rdx,%rax
    2f78:	0f b6 00             	movzbl (%rax),%eax
    2f7b:	3c 39                	cmp    $0x39,%al
    2f7d:	7e 9f                	jle    2f1e <ft_atoi+0xbb>
	if (sign % 2 == 1)
    2f7f:	8b 45 f4             	mov    -0xc(%rbp),%eax
    2f82:	99                   	cltd   
    2f83:	c1 ea 1f             	shr    $0x1f,%edx
    2f86:	01 d0                	add    %edx,%eax
    2f88:	83 e0 01             	and    $0x1,%eax
    2f8b:	29 d0                	sub    %edx,%eax
    2f8d:	83 f8 01             	cmp    $0x1,%eax
    2f90:	75 08                	jne    2f9a <ft_atoi+0x137>
		return (nbr * -1);
    2f92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2f96:	f7 d8                	neg    %eax
    2f98:	eb 04                	jmp    2f9e <ft_atoi+0x13b>
	return (nbr);
    2f9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    2f9e:	5d                   	pop    %rbp
    2f9f:	c3                   	ret    

0000000000002fa0 <ft_memset>:
/* ************************************************************************** */

#include "utils.h"

void	*ft_memset(void *b, int c, size_t len)
{
    2fa0:	f3 0f 1e fa          	endbr64 
    2fa4:	55                   	push   %rbp
    2fa5:	48 89 e5             	mov    %rsp,%rbp
    2fa8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    2fac:	89 75 e4             	mov    %esi,-0x1c(%rbp)
    2faf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t	i;

	i = 0;
    2fb3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    2fba:	00 
	while (i < len)
    2fbb:	eb 15                	jmp    2fd2 <ft_memset+0x32>
	{
		((char *)b)[i] = (unsigned char)c;
    2fbd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    2fc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2fc5:	48 01 d0             	add    %rdx,%rax
    2fc8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
    2fcb:	88 10                	mov    %dl,(%rax)
		i++;
    2fcd:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	while (i < len)
    2fd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2fd6:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
    2fda:	72 e1                	jb     2fbd <ft_memset+0x1d>
	}
	return (b);
    2fdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
    2fe0:	5d                   	pop    %rbp
    2fe1:	c3                   	ret    

0000000000002fe2 <ft_bzero>:

void	ft_bzero(void *s, size_t n)
{
    2fe2:	f3 0f 1e fa          	endbr64 
    2fe6:	55                   	push   %rbp
    2fe7:	48 89 e5             	mov    %rsp,%rbp
    2fea:	48 83 ec 10          	sub    $0x10,%rsp
    2fee:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    2ff2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	ft_memset(s, '\0', n);
    2ff6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
    2ffa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    2ffe:	be 00 00 00 00       	mov    $0x0,%esi
    3003:	48 89 c7             	mov    %rax,%rdi
    3006:	e8 95 ff ff ff       	call   2fa0 <ft_memset>
}
    300b:	90                   	nop
    300c:	c9                   	leave  
    300d:	c3                   	ret    

000000000000300e <ft_calloc>:
/* ************************************************************************** */

#include "utils.h"

void	*ft_calloc(size_t count, size_t size)
{
    300e:	f3 0f 1e fa          	endbr64 
    3012:	55                   	push   %rbp
    3013:	48 89 e5             	mov    %rsp,%rbp
    3016:	48 83 ec 20          	sub    $0x20,%rsp
    301a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    301e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	void	*ptr;

	if (count == 0 || size == 0)
    3022:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    3027:	74 07                	je     3030 <ft_calloc+0x22>
    3029:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
    302e:	75 10                	jne    3040 <ft_calloc+0x32>
	{
		count = 1;
    3030:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
    3037:	00 
		size = 1;
    3038:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
    303f:	00 
	}
	if (SIZE_MAX / count < size)
    3040:	b9 00 00 00 00       	mov    $0x0,%ecx
    3045:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3049:	48 f7 65 e8          	mulq   -0x18(%rbp)
    304d:	71 05                	jno    3054 <ft_calloc+0x46>
    304f:	b9 01 00 00 00       	mov    $0x1,%ecx
    3054:	48 89 c8             	mov    %rcx,%rax
    3057:	48 85 c0             	test   %rax,%rax
    305a:	74 07                	je     3063 <ft_calloc+0x55>
		return (NULL);
    305c:	b8 00 00 00 00       	mov    $0x0,%eax
    3061:	eb 3b                	jmp    309e <ft_calloc+0x90>
	ptr = malloc(count * size);
    3063:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3067:	48 0f af 45 e0       	imul   -0x20(%rbp),%rax
    306c:	48 89 c7             	mov    %rax,%rdi
    306f:	e8 ac f0 ff ff       	call   2120 <malloc@plt>
    3074:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (ptr)
    3078:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    307d:	74 1b                	je     309a <ft_calloc+0x8c>
		ft_bzero(ptr, count * size);
    307f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3083:	48 0f af 45 e0       	imul   -0x20(%rbp),%rax
    3088:	48 89 c2             	mov    %rax,%rdx
    308b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    308f:	48 89 d6             	mov    %rdx,%rsi
    3092:	48 89 c7             	mov    %rax,%rdi
    3095:	e8 48 ff ff ff       	call   2fe2 <ft_bzero>
	return (ptr);
    309a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    309e:	c9                   	leave  
    309f:	c3                   	ret    

00000000000030a0 <ft_error>:

#include "utils.h"
#include "pcolors.h"

int	ft_error(const char *str)
{
    30a0:	f3 0f 1e fa          	endbr64 
    30a4:	55                   	push   %rbp
    30a5:	48 89 e5             	mov    %rsp,%rbp
    30a8:	48 83 ec 20          	sub    $0x20,%rsp
    30ac:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int	r;

	r = 0;
    30b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	r += write(2, B_RED, 8);
    30b7:	ba 08 00 00 00       	mov    $0x8,%edx
    30bc:	48 8d 35 43 4f 00 00 	lea    0x4f43(%rip),%rsi        # 8006 <_IO_stdin_used+0x6>
    30c3:	bf 02 00 00 00       	mov    $0x2,%edi
    30c8:	e8 93 ef ff ff       	call   2060 <write@plt>
    30cd:	89 c2                	mov    %eax,%edx
    30cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
    30d2:	01 d0                	add    %edx,%eax
    30d4:	89 45 fc             	mov    %eax,-0x4(%rbp)
	r += write(2, str, ft_strlen(str));
    30d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    30db:	48 89 c7             	mov    %rax,%rdi
    30de:	e8 fa 03 00 00       	call   34dd <ft_strlen>
    30e3:	48 89 c2             	mov    %rax,%rdx
    30e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    30ea:	48 89 c6             	mov    %rax,%rsi
    30ed:	bf 02 00 00 00       	mov    $0x2,%edi
    30f2:	e8 69 ef ff ff       	call   2060 <write@plt>
    30f7:	89 c2                	mov    %eax,%edx
    30f9:	8b 45 fc             	mov    -0x4(%rbp),%eax
    30fc:	01 d0                	add    %edx,%eax
    30fe:	89 45 fc             	mov    %eax,-0x4(%rbp)
	r += write(2, RESET, 4);
    3101:	ba 04 00 00 00       	mov    $0x4,%edx
    3106:	48 8d 35 01 4f 00 00 	lea    0x4f01(%rip),%rsi        # 800e <_IO_stdin_used+0xe>
    310d:	bf 02 00 00 00       	mov    $0x2,%edi
    3112:	e8 49 ef ff ff       	call   2060 <write@plt>
    3117:	89 c2                	mov    %eax,%edx
    3119:	8b 45 fc             	mov    -0x4(%rbp),%eax
    311c:	01 d0                	add    %edx,%eax
    311e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return (r);
    3121:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    3124:	c9                   	leave  
    3125:	c3                   	ret    

0000000000003126 <ft_error_msg>:

int	ft_error_msg(const char *str, const char *msg)
{
    3126:	f3 0f 1e fa          	endbr64 
    312a:	55                   	push   %rbp
    312b:	48 89 e5             	mov    %rsp,%rbp
    312e:	48 83 ec 20          	sub    $0x20,%rsp
    3132:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    3136:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int	r;

	r = 0;
    313a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	r += write(2, B_RED, 8);
    3141:	ba 08 00 00 00       	mov    $0x8,%edx
    3146:	48 8d 35 b9 4e 00 00 	lea    0x4eb9(%rip),%rsi        # 8006 <_IO_stdin_used+0x6>
    314d:	bf 02 00 00 00       	mov    $0x2,%edi
    3152:	e8 09 ef ff ff       	call   2060 <write@plt>
    3157:	89 c2                	mov    %eax,%edx
    3159:	8b 45 fc             	mov    -0x4(%rbp),%eax
    315c:	01 d0                	add    %edx,%eax
    315e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	r += write(2, str, ft_strlen(str));
    3161:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3165:	48 89 c7             	mov    %rax,%rdi
    3168:	e8 70 03 00 00       	call   34dd <ft_strlen>
    316d:	48 89 c2             	mov    %rax,%rdx
    3170:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3174:	48 89 c6             	mov    %rax,%rsi
    3177:	bf 02 00 00 00       	mov    $0x2,%edi
    317c:	e8 df ee ff ff       	call   2060 <write@plt>
    3181:	89 c2                	mov    %eax,%edx
    3183:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3186:	01 d0                	add    %edx,%eax
    3188:	89 45 fc             	mov    %eax,-0x4(%rbp)
	r += write(2, ": ", 2);
    318b:	ba 02 00 00 00       	mov    $0x2,%edx
    3190:	48 8d 35 7c 4e 00 00 	lea    0x4e7c(%rip),%rsi        # 8013 <_IO_stdin_used+0x13>
    3197:	bf 02 00 00 00       	mov    $0x2,%edi
    319c:	e8 bf ee ff ff       	call   2060 <write@plt>
    31a1:	89 c2                	mov    %eax,%edx
    31a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
    31a6:	01 d0                	add    %edx,%eax
    31a8:	89 45 fc             	mov    %eax,-0x4(%rbp)
	r += write(2, msg, ft_strlen(msg));
    31ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    31af:	48 89 c7             	mov    %rax,%rdi
    31b2:	e8 26 03 00 00       	call   34dd <ft_strlen>
    31b7:	48 89 c2             	mov    %rax,%rdx
    31ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    31be:	48 89 c6             	mov    %rax,%rsi
    31c1:	bf 02 00 00 00       	mov    $0x2,%edi
    31c6:	e8 95 ee ff ff       	call   2060 <write@plt>
    31cb:	89 c2                	mov    %eax,%edx
    31cd:	8b 45 fc             	mov    -0x4(%rbp),%eax
    31d0:	01 d0                	add    %edx,%eax
    31d2:	89 45 fc             	mov    %eax,-0x4(%rbp)
	r += write(2, "\n", 1);
    31d5:	ba 01 00 00 00       	mov    $0x1,%edx
    31da:	48 8d 35 35 4e 00 00 	lea    0x4e35(%rip),%rsi        # 8016 <_IO_stdin_used+0x16>
    31e1:	bf 02 00 00 00       	mov    $0x2,%edi
    31e6:	e8 75 ee ff ff       	call   2060 <write@plt>
    31eb:	89 c2                	mov    %eax,%edx
    31ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
    31f0:	01 d0                	add    %edx,%eax
    31f2:	89 45 fc             	mov    %eax,-0x4(%rbp)
	r += write(2, RESET, 4);
    31f5:	ba 04 00 00 00       	mov    $0x4,%edx
    31fa:	48 8d 35 0d 4e 00 00 	lea    0x4e0d(%rip),%rsi        # 800e <_IO_stdin_used+0xe>
    3201:	bf 02 00 00 00       	mov    $0x2,%edi
    3206:	e8 55 ee ff ff       	call   2060 <write@plt>
    320b:	89 c2                	mov    %eax,%edx
    320d:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3210:	01 d0                	add    %edx,%eax
    3212:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return (r);
    3215:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    3218:	c9                   	leave  
    3219:	c3                   	ret    

000000000000321a <ft_warning>:

int	ft_warning(const char *str)
{
    321a:	f3 0f 1e fa          	endbr64 
    321e:	55                   	push   %rbp
    321f:	48 89 e5             	mov    %rsp,%rbp
    3222:	48 83 ec 20          	sub    $0x20,%rsp
    3226:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int	r;

	r = 0;
    322a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	r += write(2, B_YELLOW, 8);
    3231:	ba 08 00 00 00       	mov    $0x8,%edx
    3236:	48 8d 35 db 4d 00 00 	lea    0x4ddb(%rip),%rsi        # 8018 <_IO_stdin_used+0x18>
    323d:	bf 02 00 00 00       	mov    $0x2,%edi
    3242:	e8 19 ee ff ff       	call   2060 <write@plt>
    3247:	89 c2                	mov    %eax,%edx
    3249:	8b 45 fc             	mov    -0x4(%rbp),%eax
    324c:	01 d0                	add    %edx,%eax
    324e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	r += write(2, str, ft_strlen(str));
    3251:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3255:	48 89 c7             	mov    %rax,%rdi
    3258:	e8 80 02 00 00       	call   34dd <ft_strlen>
    325d:	48 89 c2             	mov    %rax,%rdx
    3260:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3264:	48 89 c6             	mov    %rax,%rsi
    3267:	bf 02 00 00 00       	mov    $0x2,%edi
    326c:	e8 ef ed ff ff       	call   2060 <write@plt>
    3271:	89 c2                	mov    %eax,%edx
    3273:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3276:	01 d0                	add    %edx,%eax
    3278:	89 45 fc             	mov    %eax,-0x4(%rbp)
	r += write(2, RESET, 4);
    327b:	ba 04 00 00 00       	mov    $0x4,%edx
    3280:	48 8d 35 87 4d 00 00 	lea    0x4d87(%rip),%rsi        # 800e <_IO_stdin_used+0xe>
    3287:	bf 02 00 00 00       	mov    $0x2,%edi
    328c:	e8 cf ed ff ff       	call   2060 <write@plt>
    3291:	89 c2                	mov    %eax,%edx
    3293:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3296:	01 d0                	add    %edx,%eax
    3298:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return (r);
    329b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    329e:	c9                   	leave  
    329f:	c3                   	ret    

00000000000032a0 <ft_info>:

int	ft_info(const char *str)
{
    32a0:	f3 0f 1e fa          	endbr64 
    32a4:	55                   	push   %rbp
    32a5:	48 89 e5             	mov    %rsp,%rbp
    32a8:	48 83 ec 10          	sub    $0x10,%rsp
    32ac:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (printf("%s%s%s", B_YELLOW, str, RESET));
    32b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    32b4:	48 8d 0d 53 4d 00 00 	lea    0x4d53(%rip),%rcx        # 800e <_IO_stdin_used+0xe>
    32bb:	48 89 c2             	mov    %rax,%rdx
    32be:	48 8d 35 53 4d 00 00 	lea    0x4d53(%rip),%rsi        # 8018 <_IO_stdin_used+0x18>
    32c5:	48 8d 3d 54 4d 00 00 	lea    0x4d54(%rip),%rdi        # 8020 <_IO_stdin_used+0x20>
    32cc:	b8 00 00 00 00       	mov    $0x0,%eax
    32d1:	e8 ca ed ff ff       	call   20a0 <printf@plt>
}
    32d6:	c9                   	leave  
    32d7:	c3                   	ret    

00000000000032d8 <ft_abs>:
/* ************************************************************************** */

#include "utils.h"

static int	ft_abs(int nbr)
{
    32d8:	f3 0f 1e fa          	endbr64 
    32dc:	55                   	push   %rbp
    32dd:	48 89 e5             	mov    %rsp,%rbp
    32e0:	89 7d fc             	mov    %edi,-0x4(%rbp)
	if (nbr < 0)
    32e3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
    32e7:	79 07                	jns    32f0 <ft_abs+0x18>
		return (-nbr);
    32e9:	8b 45 fc             	mov    -0x4(%rbp),%eax
    32ec:	f7 d8                	neg    %eax
    32ee:	eb 03                	jmp    32f3 <ft_abs+0x1b>
	return (nbr);
    32f0:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    32f3:	5d                   	pop    %rbp
    32f4:	c3                   	ret    

00000000000032f5 <ft_strrev>:

static void	ft_strrev(char *str)
{
    32f5:	f3 0f 1e fa          	endbr64 
    32f9:	55                   	push   %rbp
    32fa:	48 89 e5             	mov    %rsp,%rbp
    32fd:	48 83 ec 30          	sub    $0x30,%rsp
    3301:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	size_t	length;
	size_t	i;
	char	tmp;

	length = ft_strlen(str);
    3305:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3309:	48 89 c7             	mov    %rax,%rdi
    330c:	e8 cc 01 00 00       	call   34dd <ft_strlen>
    3311:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	i = 0;
    3315:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    331c:	00 
	while (i < length >> 1)
    331d:	eb 52                	jmp    3371 <ft_strrev+0x7c>
	{
		tmp = str[i];
    331f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    3323:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    3327:	48 01 d0             	add    %rdx,%rax
    332a:	0f b6 00             	movzbl (%rax),%eax
    332d:	88 45 ef             	mov    %al,-0x11(%rbp)
		str[i] = str[length - i - 1];
    3330:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3334:	48 2b 45 f0          	sub    -0x10(%rbp),%rax
    3338:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    333c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3340:	48 01 d0             	add    %rdx,%rax
    3343:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
    3347:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
    334b:	48 01 ca             	add    %rcx,%rdx
    334e:	0f b6 00             	movzbl (%rax),%eax
    3351:	88 02                	mov    %al,(%rdx)
		str[length - i - 1] = tmp;
    3353:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3357:	48 2b 45 f0          	sub    -0x10(%rbp),%rax
    335b:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    335f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3363:	48 01 c2             	add    %rax,%rdx
    3366:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
    336a:	88 02                	mov    %al,(%rdx)
		i++;
    336c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
	while (i < length >> 1)
    3371:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3375:	48 d1 e8             	shr    %rax
    3378:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
    337c:	72 a1                	jb     331f <ft_strrev+0x2a>
	}
}
    337e:	90                   	nop
    337f:	90                   	nop
    3380:	c9                   	leave  
    3381:	c3                   	ret    

0000000000003382 <get_num_len>:

static int	get_num_len(int num)
{
    3382:	f3 0f 1e fa          	endbr64 
    3386:	55                   	push   %rbp
    3387:	48 89 e5             	mov    %rsp,%rbp
    338a:	48 83 ec 18          	sub    $0x18,%rsp
    338e:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int	count;

	count = 0;
    3391:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	num = ft_abs(num);
    3398:	8b 45 ec             	mov    -0x14(%rbp),%eax
    339b:	89 c7                	mov    %eax,%edi
    339d:	e8 36 ff ff ff       	call   32d8 <ft_abs>
    33a2:	89 45 ec             	mov    %eax,-0x14(%rbp)
	while (num != 0)
    33a5:	eb 24                	jmp    33cb <get_num_len+0x49>
	{
		num = num / 10;
    33a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
    33aa:	48 63 d0             	movslq %eax,%rdx
    33ad:	48 69 d2 67 66 66 66 	imul   $0x66666667,%rdx,%rdx
    33b4:	48 c1 ea 20          	shr    $0x20,%rdx
    33b8:	c1 fa 02             	sar    $0x2,%edx
    33bb:	c1 f8 1f             	sar    $0x1f,%eax
    33be:	89 c1                	mov    %eax,%ecx
    33c0:	89 d0                	mov    %edx,%eax
    33c2:	29 c8                	sub    %ecx,%eax
    33c4:	89 45 ec             	mov    %eax,-0x14(%rbp)
		count++;
    33c7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	while (num != 0)
    33cb:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
    33cf:	75 d6                	jne    33a7 <get_num_len+0x25>
	}
	if (count == 0)
    33d1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
    33d5:	75 07                	jne    33de <get_num_len+0x5c>
		count = 1;
    33d7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
	return (count);
    33de:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    33e1:	c9                   	leave  
    33e2:	c3                   	ret    

00000000000033e3 <ft_itoa>:

char	*ft_itoa(int n)
{
    33e3:	f3 0f 1e fa          	endbr64 
    33e7:	55                   	push   %rbp
    33e8:	48 89 e5             	mov    %rsp,%rbp
    33eb:	48 83 ec 30          	sub    $0x30,%rsp
    33ef:	89 7d dc             	mov    %edi,-0x24(%rbp)
	char	*str;
	int		is_neg;
	size_t	length;

	is_neg = (n < 0);
    33f2:	8b 45 dc             	mov    -0x24(%rbp),%eax
    33f5:	c1 e8 1f             	shr    $0x1f,%eax
    33f8:	0f b6 c0             	movzbl %al,%eax
    33fb:	89 45 ec             	mov    %eax,-0x14(%rbp)
	str = malloc((get_num_len(n) + 1 + is_neg) * sizeof(*str));
    33fe:	8b 45 dc             	mov    -0x24(%rbp),%eax
    3401:	89 c7                	mov    %eax,%edi
    3403:	e8 7a ff ff ff       	call   3382 <get_num_len>
    3408:	8d 50 01             	lea    0x1(%rax),%edx
    340b:	8b 45 ec             	mov    -0x14(%rbp),%eax
    340e:	01 d0                	add    %edx,%eax
    3410:	48 98                	cltq   
    3412:	48 89 c7             	mov    %rax,%rdi
    3415:	e8 06 ed ff ff       	call   2120 <malloc@plt>
    341a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!str)
    341e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    3423:	75 0a                	jne    342f <ft_itoa+0x4c>
		return (NULL);
    3425:	b8 00 00 00 00       	mov    $0x0,%eax
    342a:	e9 ac 00 00 00       	jmp    34db <ft_itoa+0xf8>
	if (n == 0)
    342f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
    3433:	75 07                	jne    343c <ft_itoa+0x59>
		str[0] = '0';
    3435:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3439:	c6 00 30             	movb   $0x30,(%rax)
	length = 0;
    343c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    3443:	00 
	while (n != 0)
    3444:	eb 6b                	jmp    34b1 <ft_itoa+0xce>
	{
		str[length++] = '0' + ft_abs(n % 10);
    3446:	8b 4d dc             	mov    -0x24(%rbp),%ecx
    3449:	48 63 c1             	movslq %ecx,%rax
    344c:	48 69 c0 67 66 66 66 	imul   $0x66666667,%rax,%rax
    3453:	48 c1 e8 20          	shr    $0x20,%rax
    3457:	c1 f8 02             	sar    $0x2,%eax
    345a:	89 ce                	mov    %ecx,%esi
    345c:	c1 fe 1f             	sar    $0x1f,%esi
    345f:	29 f0                	sub    %esi,%eax
    3461:	89 c2                	mov    %eax,%edx
    3463:	89 d0                	mov    %edx,%eax
    3465:	c1 e0 02             	shl    $0x2,%eax
    3468:	01 d0                	add    %edx,%eax
    346a:	01 c0                	add    %eax,%eax
    346c:	29 c1                	sub    %eax,%ecx
    346e:	89 ca                	mov    %ecx,%edx
    3470:	89 d7                	mov    %edx,%edi
    3472:	e8 61 fe ff ff       	call   32d8 <ft_abs>
    3477:	8d 48 30             	lea    0x30(%rax),%ecx
    347a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    347e:	48 8d 50 01          	lea    0x1(%rax),%rdx
    3482:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
    3486:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    348a:	48 01 d0             	add    %rdx,%rax
    348d:	89 ca                	mov    %ecx,%edx
    348f:	88 10                	mov    %dl,(%rax)
		n = (n / 10);
    3491:	8b 45 dc             	mov    -0x24(%rbp),%eax
    3494:	48 63 d0             	movslq %eax,%rdx
    3497:	48 69 d2 67 66 66 66 	imul   $0x66666667,%rdx,%rdx
    349e:	48 c1 ea 20          	shr    $0x20,%rdx
    34a2:	c1 fa 02             	sar    $0x2,%edx
    34a5:	c1 f8 1f             	sar    $0x1f,%eax
    34a8:	89 c1                	mov    %eax,%ecx
    34aa:	89 d0                	mov    %edx,%eax
    34ac:	29 c8                	sub    %ecx,%eax
    34ae:	89 45 dc             	mov    %eax,-0x24(%rbp)
	while (n != 0)
    34b1:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
    34b5:	75 8f                	jne    3446 <ft_itoa+0x63>
	}
	if (is_neg)
    34b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
    34bb:	74 0e                	je     34cb <ft_itoa+0xe8>
		str[length] = '-';
    34bd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    34c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    34c5:	48 01 d0             	add    %rdx,%rax
    34c8:	c6 00 2d             	movb   $0x2d,(%rax)
	ft_strrev(str);
    34cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    34cf:	48 89 c7             	mov    %rax,%rdi
    34d2:	e8 1e fe ff ff       	call   32f5 <ft_strrev>
	return (str);
    34d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    34db:	c9                   	leave  
    34dc:	c3                   	ret    

00000000000034dd <ft_strlen>:
/* ************************************************************************** */

#include "utils.h"

size_t	ft_strlen(const char *str)
{
    34dd:	f3 0f 1e fa          	endbr64 
    34e1:	55                   	push   %rbp
    34e2:	48 89 e5             	mov    %rsp,%rbp
    34e5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	size_t	count;

	count = 0;
    34e9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    34f0:	00 
	if (!str)
    34f1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    34f6:	75 0b                	jne    3503 <ft_strlen+0x26>
		return (count);
    34f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    34fc:	eb 1b                	jmp    3519 <ft_strlen+0x3c>
	while (str[count])
		count++;
    34fe:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	while (str[count])
    3503:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    3507:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    350b:	48 01 d0             	add    %rdx,%rax
    350e:	0f b6 00             	movzbl (%rax),%eax
    3511:	84 c0                	test   %al,%al
    3513:	75 e9                	jne    34fe <ft_strlen+0x21>
	return (count);
    3515:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    3519:	5d                   	pop    %rbp
    351a:	c3                   	ret    

000000000000351b <ft_tablen>:

int	ft_tablen(char **str)
{
    351b:	f3 0f 1e fa          	endbr64 
    351f:	55                   	push   %rbp
    3520:	48 89 e5             	mov    %rsp,%rbp
    3523:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int	count;

	count = -1;
    3527:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
	while (str[++count])
    352e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    3532:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3535:	48 98                	cltq   
    3537:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    353e:	00 
    353f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3543:	48 01 d0             	add    %rdx,%rax
    3546:	48 8b 00             	mov    (%rax),%rax
    3549:	48 85 c0             	test   %rax,%rax
    354c:	75 e0                	jne    352e <ft_tablen+0x13>
		;
	return (count);
    354e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    3551:	5d                   	pop    %rbp
    3552:	c3                   	ret    

0000000000003553 <ft_ljoin>:

#include "utils.h"

void	*ft_ljoin(void *s1, void *s2,
	unsigned int size, unsigned int length)
{
    3553:	f3 0f 1e fa          	endbr64 
    3557:	55                   	push   %rbp
    3558:	48 89 e5             	mov    %rsp,%rbp
    355b:	48 83 ec 30          	sub    $0x30,%rsp
    355f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    3563:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    3567:	89 55 dc             	mov    %edx,-0x24(%rbp)
    356a:	89 4d d8             	mov    %ecx,-0x28(%rbp)
	void	*str;

	if (!s1)
    356d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    3572:	75 0e                	jne    3582 <ft_ljoin+0x2f>
		s1 = (void *)malloc(sizeof(void *));
    3574:	bf 08 00 00 00       	mov    $0x8,%edi
    3579:	e8 a2 eb ff ff       	call   2120 <malloc@plt>
    357e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (!s1)
    3582:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    3587:	75 0a                	jne    3593 <ft_ljoin+0x40>
		return (NULL);
    3589:	b8 00 00 00 00       	mov    $0x0,%eax
    358e:	e9 8c 00 00 00       	jmp    361f <ft_ljoin+0xcc>
	if (!s2)
    3593:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
    3598:	75 13                	jne    35ad <ft_ljoin+0x5a>
		return (free(s1), NULL);
    359a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    359e:	48 89 c7             	mov    %rax,%rdi
    35a1:	e8 8a ea ff ff       	call   2030 <free@plt>
    35a6:	b8 00 00 00 00       	mov    $0x0,%eax
    35ab:	eb 72                	jmp    361f <ft_ljoin+0xcc>
	str = malloc(sizeof(void) * (size + length));
    35ad:	8b 55 dc             	mov    -0x24(%rbp),%edx
    35b0:	8b 45 d8             	mov    -0x28(%rbp),%eax
    35b3:	01 d0                	add    %edx,%eax
    35b5:	89 c0                	mov    %eax,%eax
    35b7:	48 89 c7             	mov    %rax,%rdi
    35ba:	e8 61 eb ff ff       	call   2120 <malloc@plt>
    35bf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!str)
    35c3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    35c8:	75 13                	jne    35dd <ft_ljoin+0x8a>
		return (free(s1), NULL);
    35ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    35ce:	48 89 c7             	mov    %rax,%rdi
    35d1:	e8 5a ea ff ff       	call   2030 <free@plt>
    35d6:	b8 00 00 00 00       	mov    $0x0,%eax
    35db:	eb 42                	jmp    361f <ft_ljoin+0xcc>
	ft_memcpy(str, s1, size);
    35dd:	8b 55 dc             	mov    -0x24(%rbp),%edx
    35e0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
    35e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    35e8:	48 89 ce             	mov    %rcx,%rsi
    35eb:	48 89 c7             	mov    %rax,%rdi
    35ee:	e8 2e 00 00 00       	call   3621 <ft_memcpy>
	ft_memcpy(str + size, s2, length);
    35f3:	8b 55 d8             	mov    -0x28(%rbp),%edx
    35f6:	8b 4d dc             	mov    -0x24(%rbp),%ecx
    35f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    35fd:	48 01 c1             	add    %rax,%rcx
    3600:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3604:	48 89 c6             	mov    %rax,%rsi
    3607:	48 89 cf             	mov    %rcx,%rdi
    360a:	e8 12 00 00 00       	call   3621 <ft_memcpy>
	free(s1);
    360f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3613:	48 89 c7             	mov    %rax,%rdi
    3616:	e8 15 ea ff ff       	call   2030 <free@plt>
	return (str);
    361b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    361f:	c9                   	leave  
    3620:	c3                   	ret    

0000000000003621 <ft_memcpy>:
/* ************************************************************************** */

#include "utils.h"

void	*ft_memcpy(void *dst, const void *src, size_t n)
{
    3621:	f3 0f 1e fa          	endbr64 
    3625:	55                   	push   %rbp
    3626:	48 89 e5             	mov    %rsp,%rbp
    3629:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    362d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    3631:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t	i;
	void	*lst_dst;

	if (n == 0 || dst == src)
    3635:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
    363a:	74 0a                	je     3646 <ft_memcpy+0x25>
    363c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3640:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
    3644:	75 06                	jne    364c <ft_memcpy+0x2b>
		return (dst);
    3646:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    364a:	eb 40                	jmp    368c <ft_memcpy+0x6b>
	i = 0;
    364c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    3653:	00 
	lst_dst = dst;
    3654:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3658:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while (i < n)
    365c:	eb 20                	jmp    367e <ft_memcpy+0x5d>
	{
		((char *)dst)[i] = ((char *)src)[i];
    365e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    3662:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    3666:	48 01 d0             	add    %rdx,%rax
    3669:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
    366d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
    3671:	48 01 ca             	add    %rcx,%rdx
    3674:	0f b6 00             	movzbl (%rax),%eax
    3677:	88 02                	mov    %al,(%rdx)
		i++;
    3679:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
	while (i < n)
    367e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    3682:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
    3686:	72 d6                	jb     365e <ft_memcpy+0x3d>
	}
	return (lst_dst);
    3688:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    368c:	5d                   	pop    %rbp
    368d:	c3                   	ret    

000000000000368e <ft_max>:
/* ************************************************************************** */

#include "utils.h"

int	ft_max(int a, int b)
{
    368e:	f3 0f 1e fa          	endbr64 
    3692:	55                   	push   %rbp
    3693:	48 89 e5             	mov    %rsp,%rbp
    3696:	89 7d fc             	mov    %edi,-0x4(%rbp)
    3699:	89 75 f8             	mov    %esi,-0x8(%rbp)
	if (a < b)
    369c:	8b 45 fc             	mov    -0x4(%rbp),%eax
    369f:	3b 45 f8             	cmp    -0x8(%rbp),%eax
    36a2:	7d 05                	jge    36a9 <ft_max+0x1b>
		return (b);
    36a4:	8b 45 f8             	mov    -0x8(%rbp),%eax
    36a7:	eb 03                	jmp    36ac <ft_max+0x1e>
	return (a);
    36a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    36ac:	5d                   	pop    %rbp
    36ad:	c3                   	ret    

00000000000036ae <ft_min>:

int	ft_min(int a, int b)
{
    36ae:	f3 0f 1e fa          	endbr64 
    36b2:	55                   	push   %rbp
    36b3:	48 89 e5             	mov    %rsp,%rbp
    36b6:	89 7d fc             	mov    %edi,-0x4(%rbp)
    36b9:	89 75 f8             	mov    %esi,-0x8(%rbp)
	if (a > b)
    36bc:	8b 45 fc             	mov    -0x4(%rbp),%eax
    36bf:	3b 45 f8             	cmp    -0x8(%rbp),%eax
    36c2:	7e 05                	jle    36c9 <ft_min+0x1b>
		return (b);
    36c4:	8b 45 f8             	mov    -0x8(%rbp),%eax
    36c7:	eb 03                	jmp    36cc <ft_min+0x1e>
	return (a);
    36c9:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    36cc:	5d                   	pop    %rbp
    36cd:	c3                   	ret    

00000000000036ce <ft_fmax>:

float	ft_fmax(float a, float b)
{
    36ce:	f3 0f 1e fa          	endbr64 
    36d2:	55                   	push   %rbp
    36d3:	48 89 e5             	mov    %rsp,%rbp
    36d6:	f3 0f 11 45 fc       	movss  %xmm0,-0x4(%rbp)
    36db:	f3 0f 11 4d f8       	movss  %xmm1,-0x8(%rbp)
	if (a < b)
    36e0:	f3 0f 10 45 f8       	movss  -0x8(%rbp),%xmm0
    36e5:	0f 2f 45 fc          	comiss -0x4(%rbp),%xmm0
    36e9:	76 07                	jbe    36f2 <ft_fmax+0x24>
		return (b);
    36eb:	f3 0f 10 45 f8       	movss  -0x8(%rbp),%xmm0
    36f0:	eb 05                	jmp    36f7 <ft_fmax+0x29>
	return (a);
    36f2:	f3 0f 10 45 fc       	movss  -0x4(%rbp),%xmm0
}
    36f7:	5d                   	pop    %rbp
    36f8:	c3                   	ret    

00000000000036f9 <ft_fmin>:

float	ft_fmin(float a, float b)
{
    36f9:	f3 0f 1e fa          	endbr64 
    36fd:	55                   	push   %rbp
    36fe:	48 89 e5             	mov    %rsp,%rbp
    3701:	f3 0f 11 45 fc       	movss  %xmm0,-0x4(%rbp)
    3706:	f3 0f 11 4d f8       	movss  %xmm1,-0x8(%rbp)
	if (a > b)
    370b:	f3 0f 10 45 fc       	movss  -0x4(%rbp),%xmm0
    3710:	0f 2f 45 f8          	comiss -0x8(%rbp),%xmm0
    3714:	76 07                	jbe    371d <ft_fmin+0x24>
		return (b);
    3716:	f3 0f 10 45 f8       	movss  -0x8(%rbp),%xmm0
    371b:	eb 05                	jmp    3722 <ft_fmin+0x29>
	return (a);
    371d:	f3 0f 10 45 fc       	movss  -0x4(%rbp),%xmm0
}
    3722:	5d                   	pop    %rbp
    3723:	c3                   	ret    

0000000000003724 <ft_strchr>:
/* ************************************************************************** */

#include "utils.h"

char	*ft_strchr(char *s, int c)
{
    3724:	f3 0f 1e fa          	endbr64 
    3728:	55                   	push   %rbp
    3729:	48 89 e5             	mov    %rsp,%rbp
    372c:	48 83 ec 20          	sub    $0x20,%rsp
    3730:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    3734:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int		i;

	i = 0;
    3737:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if (!s)
    373e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    3743:	75 07                	jne    374c <ft_strchr+0x28>
		return (NULL);
    3745:	b8 00 00 00 00       	mov    $0x0,%eax
    374a:	eb 5e                	jmp    37aa <ft_strchr+0x86>
	if (c == '\0')
    374c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
    3750:	75 3f                	jne    3791 <ft_strchr+0x6d>
		return ((char *)&s[ft_strlen(s)]);
    3752:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3756:	48 89 c7             	mov    %rax,%rdi
    3759:	e8 7f fd ff ff       	call   34dd <ft_strlen>
    375e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    3762:	48 01 d0             	add    %rdx,%rax
    3765:	eb 43                	jmp    37aa <ft_strchr+0x86>
	while (s[i] != '\0')
	{
		if (s[i] == (char) c)
    3767:	8b 45 fc             	mov    -0x4(%rbp),%eax
    376a:	48 63 d0             	movslq %eax,%rdx
    376d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3771:	48 01 d0             	add    %rdx,%rax
    3774:	0f b6 00             	movzbl (%rax),%eax
    3777:	8b 55 e4             	mov    -0x1c(%rbp),%edx
    377a:	38 d0                	cmp    %dl,%al
    377c:	75 0f                	jne    378d <ft_strchr+0x69>
			return ((char *)&s[i]);
    377e:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3781:	48 63 d0             	movslq %eax,%rdx
    3784:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3788:	48 01 d0             	add    %rdx,%rax
    378b:	eb 1d                	jmp    37aa <ft_strchr+0x86>
		i++;
    378d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	while (s[i] != '\0')
    3791:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3794:	48 63 d0             	movslq %eax,%rdx
    3797:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    379b:	48 01 d0             	add    %rdx,%rax
    379e:	0f b6 00             	movzbl (%rax),%eax
    37a1:	84 c0                	test   %al,%al
    37a3:	75 c2                	jne    3767 <ft_strchr+0x43>
	}
	return (NULL);
    37a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    37aa:	c9                   	leave  
    37ab:	c3                   	ret    

00000000000037ac <ft_strmultichr>:

int	ft_strmultichr(char *str, char *chrlst)
{
    37ac:	f3 0f 1e fa          	endbr64 
    37b0:	55                   	push   %rbp
    37b1:	48 89 e5             	mov    %rsp,%rbp
    37b4:	48 83 ec 20          	sub    $0x20,%rsp
    37b8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    37bc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int		i;
	char	*ptr;

	i = 0;
    37c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	ptr = NULL;
    37c7:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    37ce:	00 
	if (!str)
    37cf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    37d4:	75 07                	jne    37dd <ft_strmultichr+0x31>
		return (1);
    37d6:	b8 01 00 00 00       	mov    $0x1,%eax
    37db:	eb 76                	jmp    3853 <ft_strmultichr+0xa7>
	if ((str == NULL && chrlst == NULL) || ft_strlen(str) == 0)
    37dd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    37e2:	75 07                	jne    37eb <ft_strmultichr+0x3f>
    37e4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
    37e9:	74 11                	je     37fc <ft_strmultichr+0x50>
    37eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    37ef:	48 89 c7             	mov    %rax,%rdi
    37f2:	e8 e6 fc ff ff       	call   34dd <ft_strlen>
    37f7:	48 85 c0             	test   %rax,%rax
    37fa:	75 3e                	jne    383a <ft_strmultichr+0x8e>
		return (0);
    37fc:	b8 00 00 00 00       	mov    $0x0,%eax
    3801:	eb 50                	jmp    3853 <ft_strmultichr+0xa7>
	while (str[i])
	{
		ptr = ft_strchr(chrlst, str[i]);
    3803:	8b 45 f4             	mov    -0xc(%rbp),%eax
    3806:	48 63 d0             	movslq %eax,%rdx
    3809:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    380d:	48 01 d0             	add    %rdx,%rax
    3810:	0f b6 00             	movzbl (%rax),%eax
    3813:	0f be d0             	movsbl %al,%edx
    3816:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    381a:	89 d6                	mov    %edx,%esi
    381c:	48 89 c7             	mov    %rax,%rdi
    381f:	e8 00 ff ff ff       	call   3724 <ft_strchr>
    3824:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (!ptr)
    3828:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    382d:	75 07                	jne    3836 <ft_strmultichr+0x8a>
			return (0);
    382f:	b8 00 00 00 00       	mov    $0x0,%eax
    3834:	eb 1d                	jmp    3853 <ft_strmultichr+0xa7>
		i++;
    3836:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	while (str[i])
    383a:	8b 45 f4             	mov    -0xc(%rbp),%eax
    383d:	48 63 d0             	movslq %eax,%rdx
    3840:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3844:	48 01 d0             	add    %rdx,%rax
    3847:	0f b6 00             	movzbl (%rax),%eax
    384a:	84 c0                	test   %al,%al
    384c:	75 b5                	jne    3803 <ft_strmultichr+0x57>
	}
	return (1);
    384e:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3853:	c9                   	leave  
    3854:	c3                   	ret    

0000000000003855 <ft_replace>:
/* ************************************************************************** */

#include "utils.h"

void	ft_replace(char *src, char to_rep, char set)
{
    3855:	f3 0f 1e fa          	endbr64 
    3859:	55                   	push   %rbp
    385a:	48 89 e5             	mov    %rsp,%rbp
    385d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    3861:	89 f1                	mov    %esi,%ecx
    3863:	89 d0                	mov    %edx,%eax
    3865:	89 ca                	mov    %ecx,%edx
    3867:	88 55 e4             	mov    %dl,-0x1c(%rbp)
    386a:	88 45 e0             	mov    %al,-0x20(%rbp)
	int	i;

	i = -1;
    386d:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
	while (src[++i])
    3874:	eb 28                	jmp    389e <ft_replace+0x49>
	{
		if (src[i] == to_rep)
    3876:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3879:	48 63 d0             	movslq %eax,%rdx
    387c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3880:	48 01 d0             	add    %rdx,%rax
    3883:	0f b6 00             	movzbl (%rax),%eax
    3886:	38 45 e4             	cmp    %al,-0x1c(%rbp)
    3889:	75 13                	jne    389e <ft_replace+0x49>
			src[i] = set;
    388b:	8b 45 fc             	mov    -0x4(%rbp),%eax
    388e:	48 63 d0             	movslq %eax,%rdx
    3891:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3895:	48 01 c2             	add    %rax,%rdx
    3898:	0f b6 45 e0          	movzbl -0x20(%rbp),%eax
    389c:	88 02                	mov    %al,(%rdx)
	while (src[++i])
    389e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    38a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
    38a5:	48 63 d0             	movslq %eax,%rdx
    38a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    38ac:	48 01 d0             	add    %rdx,%rax
    38af:	0f b6 00             	movzbl (%rax),%eax
    38b2:	84 c0                	test   %al,%al
    38b4:	75 c0                	jne    3876 <ft_replace+0x21>
	}
}
    38b6:	90                   	nop
    38b7:	90                   	nop
    38b8:	5d                   	pop    %rbp
    38b9:	c3                   	ret    

00000000000038ba <count_strings>:
/* ************************************************************************** */

#include "utils.h"

static int	count_strings(const char *str, char *charset)
{
    38ba:	f3 0f 1e fa          	endbr64 
    38be:	55                   	push   %rbp
    38bf:	48 89 e5             	mov    %rsp,%rbp
    38c2:	48 83 ec 20          	sub    $0x20,%rsp
    38c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    38ca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int	i;
	int	count;

	count = 0;
    38ce:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	i = 0;
    38d5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	while (str[i] != '\0')
    38dc:	e9 94 00 00 00       	jmp    3975 <count_strings+0xbb>
	{
		while (str[i] != '\0' && check_separator(str[i], charset))
			i++;
    38e1:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
		while (str[i] != '\0' && check_separator(str[i], charset))
    38e5:	8b 45 f8             	mov    -0x8(%rbp),%eax
    38e8:	48 63 d0             	movslq %eax,%rdx
    38eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    38ef:	48 01 d0             	add    %rdx,%rax
    38f2:	0f b6 00             	movzbl (%rax),%eax
    38f5:	84 c0                	test   %al,%al
    38f7:	74 25                	je     391e <count_strings+0x64>
    38f9:	8b 45 f8             	mov    -0x8(%rbp),%eax
    38fc:	48 63 d0             	movslq %eax,%rdx
    38ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3903:	48 01 d0             	add    %rdx,%rax
    3906:	0f b6 00             	movzbl (%rax),%eax
    3909:	0f be c0             	movsbl %al,%eax
    390c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    3910:	48 89 d6             	mov    %rdx,%rsi
    3913:	89 c7                	mov    %eax,%edi
    3915:	e8 34 03 00 00       	call   3c4e <check_separator>
    391a:	85 c0                	test   %eax,%eax
    391c:	75 c3                	jne    38e1 <count_strings+0x27>
		if (str[i] != '\0')
    391e:	8b 45 f8             	mov    -0x8(%rbp),%eax
    3921:	48 63 d0             	movslq %eax,%rdx
    3924:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3928:	48 01 d0             	add    %rdx,%rax
    392b:	0f b6 00             	movzbl (%rax),%eax
    392e:	84 c0                	test   %al,%al
    3930:	74 0a                	je     393c <count_strings+0x82>
			count++;
    3932:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		while (str[i] != '\0' && !check_separator(str[i], charset))
    3936:	eb 04                	jmp    393c <count_strings+0x82>
			i++;
    3938:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
		while (str[i] != '\0' && !check_separator(str[i], charset))
    393c:	8b 45 f8             	mov    -0x8(%rbp),%eax
    393f:	48 63 d0             	movslq %eax,%rdx
    3942:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3946:	48 01 d0             	add    %rdx,%rax
    3949:	0f b6 00             	movzbl (%rax),%eax
    394c:	84 c0                	test   %al,%al
    394e:	74 25                	je     3975 <count_strings+0xbb>
    3950:	8b 45 f8             	mov    -0x8(%rbp),%eax
    3953:	48 63 d0             	movslq %eax,%rdx
    3956:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    395a:	48 01 d0             	add    %rdx,%rax
    395d:	0f b6 00             	movzbl (%rax),%eax
    3960:	0f be c0             	movsbl %al,%eax
    3963:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    3967:	48 89 d6             	mov    %rdx,%rsi
    396a:	89 c7                	mov    %eax,%edi
    396c:	e8 dd 02 00 00       	call   3c4e <check_separator>
    3971:	85 c0                	test   %eax,%eax
    3973:	74 c3                	je     3938 <count_strings+0x7e>
	while (str[i] != '\0')
    3975:	8b 45 f8             	mov    -0x8(%rbp),%eax
    3978:	48 63 d0             	movslq %eax,%rdx
    397b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    397f:	48 01 d0             	add    %rdx,%rax
    3982:	0f b6 00             	movzbl (%rax),%eax
    3985:	84 c0                	test   %al,%al
    3987:	0f 85 58 ff ff ff    	jne    38e5 <count_strings+0x2b>
	}
	return (count);
    398d:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    3990:	c9                   	leave  
    3991:	c3                   	ret    

0000000000003992 <ft_strlen_sep>:

static int	ft_strlen_sep(const char *str, char *charset)
{
    3992:	f3 0f 1e fa          	endbr64 
    3996:	55                   	push   %rbp
    3997:	48 89 e5             	mov    %rsp,%rbp
    399a:	48 83 ec 20          	sub    $0x20,%rsp
    399e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    39a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int	i;

	i = 0;
    39a6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	while (str[i] && !check_separator(str[i], charset))
    39ad:	eb 04                	jmp    39b3 <ft_strlen_sep+0x21>
		i++;
    39af:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	while (str[i] && !check_separator(str[i], charset))
    39b3:	8b 45 fc             	mov    -0x4(%rbp),%eax
    39b6:	48 63 d0             	movslq %eax,%rdx
    39b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    39bd:	48 01 d0             	add    %rdx,%rax
    39c0:	0f b6 00             	movzbl (%rax),%eax
    39c3:	84 c0                	test   %al,%al
    39c5:	74 25                	je     39ec <ft_strlen_sep+0x5a>
    39c7:	8b 45 fc             	mov    -0x4(%rbp),%eax
    39ca:	48 63 d0             	movslq %eax,%rdx
    39cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    39d1:	48 01 d0             	add    %rdx,%rax
    39d4:	0f b6 00             	movzbl (%rax),%eax
    39d7:	0f be c0             	movsbl %al,%eax
    39da:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    39de:	48 89 d6             	mov    %rdx,%rsi
    39e1:	89 c7                	mov    %eax,%edi
    39e3:	e8 66 02 00 00       	call   3c4e <check_separator>
    39e8:	85 c0                	test   %eax,%eax
    39ea:	74 c3                	je     39af <ft_strlen_sep+0x1d>
	return (i);
    39ec:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    39ef:	c9                   	leave  
    39f0:	c3                   	ret    

00000000000039f1 <ft_word>:

static char	*ft_word(const char *str, char *charset)
{
    39f1:	f3 0f 1e fa          	endbr64 
    39f5:	55                   	push   %rbp
    39f6:	48 89 e5             	mov    %rsp,%rbp
    39f9:	48 83 ec 20          	sub    $0x20,%rsp
    39fd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    3a01:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int		len_word;
	int		i;
	char	*word;

	i = 0;
    3a05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	len_word = ft_strlen_sep(str, charset);
    3a0c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    3a10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3a14:	48 89 d6             	mov    %rdx,%rsi
    3a17:	48 89 c7             	mov    %rax,%rdi
    3a1a:	e8 73 ff ff ff       	call   3992 <ft_strlen_sep>
    3a1f:	89 45 f4             	mov    %eax,-0xc(%rbp)
	word = (char *)malloc(sizeof(char) * (len_word + 1));
    3a22:	8b 45 f4             	mov    -0xc(%rbp),%eax
    3a25:	83 c0 01             	add    $0x1,%eax
    3a28:	48 98                	cltq   
    3a2a:	48 89 c7             	mov    %rax,%rdi
    3a2d:	e8 ee e6 ff ff       	call   2120 <malloc@plt>
    3a32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!word)
    3a36:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    3a3b:	75 2a                	jne    3a67 <ft_word+0x76>
		return (0);
    3a3d:	b8 00 00 00 00       	mov    $0x0,%eax
    3a42:	eb 3f                	jmp    3a83 <ft_word+0x92>
	while (i < len_word)
	{
		word[i] = str[i];
    3a44:	8b 45 f0             	mov    -0x10(%rbp),%eax
    3a47:	48 63 d0             	movslq %eax,%rdx
    3a4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3a4e:	48 01 d0             	add    %rdx,%rax
    3a51:	8b 55 f0             	mov    -0x10(%rbp),%edx
    3a54:	48 63 ca             	movslq %edx,%rcx
    3a57:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    3a5b:	48 01 ca             	add    %rcx,%rdx
    3a5e:	0f b6 00             	movzbl (%rax),%eax
    3a61:	88 02                	mov    %al,(%rdx)
		i++;
    3a63:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
	while (i < len_word)
    3a67:	8b 45 f0             	mov    -0x10(%rbp),%eax
    3a6a:	3b 45 f4             	cmp    -0xc(%rbp),%eax
    3a6d:	7c d5                	jl     3a44 <ft_word+0x53>
	}
	word[i] = '\0';
    3a6f:	8b 45 f0             	mov    -0x10(%rbp),%eax
    3a72:	48 63 d0             	movslq %eax,%rdx
    3a75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3a79:	48 01 d0             	add    %rdx,%rax
    3a7c:	c6 00 00             	movb   $0x0,(%rax)
	return (word);
    3a7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    3a83:	c9                   	leave  
    3a84:	c3                   	ret    

0000000000003a85 <ft_split>:

char	**ft_split(const char *str, char *charset)
{
    3a85:	f3 0f 1e fa          	endbr64 
    3a89:	55                   	push   %rbp
    3a8a:	48 89 e5             	mov    %rsp,%rbp
    3a8d:	53                   	push   %rbx
    3a8e:	48 83 ec 28          	sub    $0x28,%rsp
    3a92:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    3a96:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char	**strings;
	int		i;

	if (str == NULL)
    3a9a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
    3a9f:	75 0a                	jne    3aab <ft_split+0x26>
		return (NULL);
    3aa1:	b8 00 00 00 00       	mov    $0x0,%eax
    3aa6:	e9 30 01 00 00       	jmp    3bdb <ft_split+0x156>
	i = 0;
    3aab:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	strings = (char **)malloc(sizeof(char *)
			* (count_strings(str, charset) + 1));
    3ab2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    3ab6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3aba:	48 89 d6             	mov    %rdx,%rsi
    3abd:	48 89 c7             	mov    %rax,%rdi
    3ac0:	e8 f5 fd ff ff       	call   38ba <count_strings>
    3ac5:	83 c0 01             	add    $0x1,%eax
    3ac8:	48 98                	cltq   
	strings = (char **)malloc(sizeof(char *)
    3aca:	48 c1 e0 03          	shl    $0x3,%rax
    3ace:	48 89 c7             	mov    %rax,%rdi
    3ad1:	e8 4a e6 ff ff       	call   2120 <malloc@plt>
    3ad6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (!strings)
    3ada:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    3adf:	0f 85 c8 00 00 00    	jne    3bad <ft_split+0x128>
		return (0);
    3ae5:	b8 00 00 00 00       	mov    $0x0,%eax
    3aea:	e9 ec 00 00 00       	jmp    3bdb <ft_split+0x156>
	while (*str != '\0')
	{
		while (*str != '\0' && check_separator(*str, charset))
			str++;
    3aef:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
		while (*str != '\0' && check_separator(*str, charset))
    3af4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3af8:	0f b6 00             	movzbl (%rax),%eax
    3afb:	84 c0                	test   %al,%al
    3afd:	74 1c                	je     3b1b <ft_split+0x96>
    3aff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3b03:	0f b6 00             	movzbl (%rax),%eax
    3b06:	0f be c0             	movsbl %al,%eax
    3b09:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    3b0d:	48 89 d6             	mov    %rdx,%rsi
    3b10:	89 c7                	mov    %eax,%edi
    3b12:	e8 37 01 00 00       	call   3c4e <check_separator>
    3b17:	85 c0                	test   %eax,%eax
    3b19:	75 d4                	jne    3aef <ft_split+0x6a>
		if (*str != '\0')
    3b1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3b1f:	0f b6 00             	movzbl (%rax),%eax
    3b22:	84 c0                	test   %al,%al
    3b24:	74 60                	je     3b86 <ft_split+0x101>
		{
			strings[i] = ft_word(str, charset);
    3b26:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    3b29:	48 98                	cltq   
    3b2b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    3b32:	00 
    3b33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3b37:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
    3b3b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    3b3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3b43:	48 89 d6             	mov    %rdx,%rsi
    3b46:	48 89 c7             	mov    %rax,%rdi
    3b49:	e8 a3 fe ff ff       	call   39f1 <ft_word>
    3b4e:	48 89 03             	mov    %rax,(%rbx)
			if (strings[i++] == 0)
    3b51:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    3b54:	8d 50 01             	lea    0x1(%rax),%edx
    3b57:	89 55 e4             	mov    %edx,-0x1c(%rbp)
    3b5a:	48 98                	cltq   
    3b5c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    3b63:	00 
    3b64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3b68:	48 01 d0             	add    %rdx,%rax
    3b6b:	48 8b 00             	mov    (%rax),%rax
    3b6e:	48 85 c0             	test   %rax,%rax
    3b71:	75 13                	jne    3b86 <ft_split+0x101>
				return (free_tab(strings));
    3b73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3b77:	48 89 c7             	mov    %rax,%rdi
    3b7a:	e8 62 00 00 00       	call   3be1 <free_tab>
    3b7f:	eb 5a                	jmp    3bdb <ft_split+0x156>
		}
		while (*str && !check_separator(*str, charset))
			str++;
    3b81:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
		while (*str && !check_separator(*str, charset))
    3b86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3b8a:	0f b6 00             	movzbl (%rax),%eax
    3b8d:	84 c0                	test   %al,%al
    3b8f:	74 1c                	je     3bad <ft_split+0x128>
    3b91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3b95:	0f b6 00             	movzbl (%rax),%eax
    3b98:	0f be c0             	movsbl %al,%eax
    3b9b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    3b9f:	48 89 d6             	mov    %rdx,%rsi
    3ba2:	89 c7                	mov    %eax,%edi
    3ba4:	e8 a5 00 00 00       	call   3c4e <check_separator>
    3ba9:	85 c0                	test   %eax,%eax
    3bab:	74 d4                	je     3b81 <ft_split+0xfc>
	while (*str != '\0')
    3bad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3bb1:	0f b6 00             	movzbl (%rax),%eax
    3bb4:	84 c0                	test   %al,%al
    3bb6:	0f 85 38 ff ff ff    	jne    3af4 <ft_split+0x6f>
	}
	strings[i] = 0;
    3bbc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    3bbf:	48 98                	cltq   
    3bc1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    3bc8:	00 
    3bc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3bcd:	48 01 d0             	add    %rdx,%rax
    3bd0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return (strings);
    3bd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
    3bdb:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    3bdf:	c9                   	leave  
    3be0:	c3                   	ret    

0000000000003be1 <free_tab>:
/* ************************************************************************** */

#include "utils.h"

char	**free_tab(char **tab)
{
    3be1:	f3 0f 1e fa          	endbr64 
    3be5:	55                   	push   %rbp
    3be6:	48 89 e5             	mov    %rsp,%rbp
    3be9:	48 83 ec 20          	sub    $0x20,%rsp
    3bed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int	i;

	i = 0;
    3bf1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	while (tab[i])
    3bf8:	eb 25                	jmp    3c1f <free_tab+0x3e>
	{
		free(tab[i++]);
    3bfa:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3bfd:	8d 50 01             	lea    0x1(%rax),%edx
    3c00:	89 55 fc             	mov    %edx,-0x4(%rbp)
    3c03:	48 98                	cltq   
    3c05:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    3c0c:	00 
    3c0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3c11:	48 01 d0             	add    %rdx,%rax
    3c14:	48 8b 00             	mov    (%rax),%rax
    3c17:	48 89 c7             	mov    %rax,%rdi
    3c1a:	e8 11 e4 ff ff       	call   2030 <free@plt>
	while (tab[i])
    3c1f:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3c22:	48 98                	cltq   
    3c24:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    3c2b:	00 
    3c2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3c30:	48 01 d0             	add    %rdx,%rax
    3c33:	48 8b 00             	mov    (%rax),%rax
    3c36:	48 85 c0             	test   %rax,%rax
    3c39:	75 bf                	jne    3bfa <free_tab+0x19>
	}
	free(tab);
    3c3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3c3f:	48 89 c7             	mov    %rax,%rdi
    3c42:	e8 e9 e3 ff ff       	call   2030 <free@plt>
	return (0);
    3c47:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3c4c:	c9                   	leave  
    3c4d:	c3                   	ret    

0000000000003c4e <check_separator>:

int	check_separator(char c, char *charset)
{
    3c4e:	f3 0f 1e fa          	endbr64 
    3c52:	55                   	push   %rbp
    3c53:	48 89 e5             	mov    %rsp,%rbp
    3c56:	89 f8                	mov    %edi,%eax
    3c58:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    3c5c:	88 45 ec             	mov    %al,-0x14(%rbp)
	int	i;

	i = 0;
    3c5f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	while (charset[i] != '\0')
    3c66:	eb 20                	jmp    3c88 <check_separator+0x3a>
	{
		if (c == charset[i])
    3c68:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3c6b:	48 63 d0             	movslq %eax,%rdx
    3c6e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3c72:	48 01 d0             	add    %rdx,%rax
    3c75:	0f b6 00             	movzbl (%rax),%eax
    3c78:	38 45 ec             	cmp    %al,-0x14(%rbp)
    3c7b:	75 07                	jne    3c84 <check_separator+0x36>
			return (1);
    3c7d:	b8 01 00 00 00       	mov    $0x1,%eax
    3c82:	eb 1d                	jmp    3ca1 <check_separator+0x53>
		i++;
    3c84:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	while (charset[i] != '\0')
    3c88:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3c8b:	48 63 d0             	movslq %eax,%rdx
    3c8e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3c92:	48 01 d0             	add    %rdx,%rax
    3c95:	0f b6 00             	movzbl (%rax),%eax
    3c98:	84 c0                	test   %al,%al
    3c9a:	75 cc                	jne    3c68 <check_separator+0x1a>
	}
	return (0);
    3c9c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3ca1:	5d                   	pop    %rbp
    3ca2:	c3                   	ret    

0000000000003ca3 <ft_strcmp>:
/* ************************************************************************** */

#include "utils.h"

int	ft_strcmp(const char *s1, const char *s2)
{
    3ca3:	f3 0f 1e fa          	endbr64 
    3ca7:	55                   	push   %rbp
    3ca8:	48 89 e5             	mov    %rsp,%rbp
    3cab:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    3caf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t	i;

	i = 0;
    3cb3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	while ((char)s1[i] == (char)s2[i] \
    3cba:	eb 04                	jmp    3cc0 <ft_strcmp+0x1d>
		&& (char)s1[i] != '\0' && (char)s2[i] != '\0')
	{
		i++;
    3cbc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	while ((char)s1[i] == (char)s2[i] \
    3cc0:	8b 55 fc             	mov    -0x4(%rbp),%edx
    3cc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3cc7:	48 01 d0             	add    %rdx,%rax
    3cca:	0f b6 10             	movzbl (%rax),%edx
    3ccd:	8b 4d fc             	mov    -0x4(%rbp),%ecx
    3cd0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3cd4:	48 01 c8             	add    %rcx,%rax
    3cd7:	0f b6 00             	movzbl (%rax),%eax
    3cda:	38 c2                	cmp    %al,%dl
    3cdc:	75 22                	jne    3d00 <ft_strcmp+0x5d>
		&& (char)s1[i] != '\0' && (char)s2[i] != '\0')
    3cde:	8b 55 fc             	mov    -0x4(%rbp),%edx
    3ce1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3ce5:	48 01 d0             	add    %rdx,%rax
    3ce8:	0f b6 00             	movzbl (%rax),%eax
    3ceb:	84 c0                	test   %al,%al
    3ced:	74 11                	je     3d00 <ft_strcmp+0x5d>
    3cef:	8b 55 fc             	mov    -0x4(%rbp),%edx
    3cf2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3cf6:	48 01 d0             	add    %rdx,%rax
    3cf9:	0f b6 00             	movzbl (%rax),%eax
    3cfc:	84 c0                	test   %al,%al
    3cfe:	75 bc                	jne    3cbc <ft_strcmp+0x19>
	}
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
    3d00:	8b 55 fc             	mov    -0x4(%rbp),%edx
    3d03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3d07:	48 01 d0             	add    %rdx,%rax
    3d0a:	0f b6 00             	movzbl (%rax),%eax
    3d0d:	0f b6 c0             	movzbl %al,%eax
    3d10:	8b 4d fc             	mov    -0x4(%rbp),%ecx
    3d13:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    3d17:	48 01 ca             	add    %rcx,%rdx
    3d1a:	0f b6 12             	movzbl (%rdx),%edx
    3d1d:	0f b6 d2             	movzbl %dl,%edx
    3d20:	29 d0                	sub    %edx,%eax
}
    3d22:	5d                   	pop    %rbp
    3d23:	c3                   	ret    

0000000000003d24 <ft_strncmp>:

int	ft_strncmp(const char *s1, const char *s2, uint32_t n)
{
    3d24:	f3 0f 1e fa          	endbr64 
    3d28:	55                   	push   %rbp
    3d29:	48 89 e5             	mov    %rsp,%rbp
    3d2c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    3d30:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    3d34:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint32_t	i;

	i = 0;
    3d37:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if (n == 0)
    3d3e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
    3d42:	75 0b                	jne    3d4f <ft_strncmp+0x2b>
		return (0);
    3d44:	b8 00 00 00 00       	mov    $0x0,%eax
    3d49:	eb 71                	jmp    3dbc <ft_strncmp+0x98>
	while ((char)s1[i] == (char)s2[i] && i < n - 1 \
		&& (char)s1[i] != '\0' && (char)s2[i] != '\0')
	{
		i++;
    3d4b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	while ((char)s1[i] == (char)s2[i] && i < n - 1 \
    3d4f:	8b 55 fc             	mov    -0x4(%rbp),%edx
    3d52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3d56:	48 01 d0             	add    %rdx,%rax
    3d59:	0f b6 10             	movzbl (%rax),%edx
    3d5c:	8b 4d fc             	mov    -0x4(%rbp),%ecx
    3d5f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3d63:	48 01 c8             	add    %rcx,%rax
    3d66:	0f b6 00             	movzbl (%rax),%eax
    3d69:	38 c2                	cmp    %al,%dl
    3d6b:	75 2d                	jne    3d9a <ft_strncmp+0x76>
    3d6d:	8b 45 dc             	mov    -0x24(%rbp),%eax
    3d70:	83 e8 01             	sub    $0x1,%eax
    3d73:	39 45 fc             	cmp    %eax,-0x4(%rbp)
    3d76:	73 22                	jae    3d9a <ft_strncmp+0x76>
		&& (char)s1[i] != '\0' && (char)s2[i] != '\0')
    3d78:	8b 55 fc             	mov    -0x4(%rbp),%edx
    3d7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3d7f:	48 01 d0             	add    %rdx,%rax
    3d82:	0f b6 00             	movzbl (%rax),%eax
    3d85:	84 c0                	test   %al,%al
    3d87:	74 11                	je     3d9a <ft_strncmp+0x76>
    3d89:	8b 55 fc             	mov    -0x4(%rbp),%edx
    3d8c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3d90:	48 01 d0             	add    %rdx,%rax
    3d93:	0f b6 00             	movzbl (%rax),%eax
    3d96:	84 c0                	test   %al,%al
    3d98:	75 b1                	jne    3d4b <ft_strncmp+0x27>
	}
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
    3d9a:	8b 55 fc             	mov    -0x4(%rbp),%edx
    3d9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3da1:	48 01 d0             	add    %rdx,%rax
    3da4:	0f b6 00             	movzbl (%rax),%eax
    3da7:	0f b6 c0             	movzbl %al,%eax
    3daa:	8b 4d fc             	mov    -0x4(%rbp),%ecx
    3dad:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    3db1:	48 01 ca             	add    %rcx,%rdx
    3db4:	0f b6 12             	movzbl (%rdx),%edx
    3db7:	0f b6 d2             	movzbl %dl,%edx
    3dba:	29 d0                	sub    %edx,%eax
}
    3dbc:	5d                   	pop    %rbp
    3dbd:	c3                   	ret    

0000000000003dbe <ft_strnrcmp>:

int	ft_strnrcmp(const char *s1, const char *s2, uint32_t n)
{
    3dbe:	f3 0f 1e fa          	endbr64 
    3dc2:	55                   	push   %rbp
    3dc3:	48 89 e5             	mov    %rsp,%rbp
    3dc6:	53                   	push   %rbx
    3dc7:	48 83 ec 38          	sub    $0x38,%rsp
    3dcb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    3dcf:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    3dd3:	89 55 cc             	mov    %edx,-0x34(%rbp)
	uint32_t	i;

	i = ft_max(ft_strlen(s1), ft_strlen(s2)) - 1;
    3dd6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    3dda:	48 89 c7             	mov    %rax,%rdi
    3ddd:	e8 fb f6 ff ff       	call   34dd <ft_strlen>
    3de2:	89 c3                	mov    %eax,%ebx
    3de4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3de8:	48 89 c7             	mov    %rax,%rdi
    3deb:	e8 ed f6 ff ff       	call   34dd <ft_strlen>
    3df0:	89 de                	mov    %ebx,%esi
    3df2:	89 c7                	mov    %eax,%edi
    3df4:	e8 95 f8 ff ff       	call   368e <ft_max>
    3df9:	83 e8 01             	sub    $0x1,%eax
    3dfc:	89 45 ec             	mov    %eax,-0x14(%rbp)
	while (n > 0 && i > 0 && (char)s1[i] == (char)s2[n - 1])
    3dff:	eb 15                	jmp    3e16 <ft_strnrcmp+0x58>
	{
		i--;
    3e01:	83 6d ec 01          	subl   $0x1,-0x14(%rbp)
		n--;
    3e05:	83 6d cc 01          	subl   $0x1,-0x34(%rbp)
		if (n == 0)
    3e09:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
    3e0d:	75 07                	jne    3e16 <ft_strnrcmp+0x58>
			return (0);
    3e0f:	b8 00 00 00 00       	mov    $0x0,%eax
    3e14:	eb 51                	jmp    3e67 <ft_strnrcmp+0xa9>
	while (n > 0 && i > 0 && (char)s1[i] == (char)s2[n - 1])
    3e16:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
    3e1a:	74 29                	je     3e45 <ft_strnrcmp+0x87>
    3e1c:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
    3e20:	74 23                	je     3e45 <ft_strnrcmp+0x87>
    3e22:	8b 55 ec             	mov    -0x14(%rbp),%edx
    3e25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3e29:	48 01 d0             	add    %rdx,%rax
    3e2c:	0f b6 10             	movzbl (%rax),%edx
    3e2f:	8b 45 cc             	mov    -0x34(%rbp),%eax
    3e32:	83 e8 01             	sub    $0x1,%eax
    3e35:	89 c1                	mov    %eax,%ecx
    3e37:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    3e3b:	48 01 c8             	add    %rcx,%rax
    3e3e:	0f b6 00             	movzbl (%rax),%eax
    3e41:	38 c2                	cmp    %al,%dl
    3e43:	74 bc                	je     3e01 <ft_strnrcmp+0x43>
	}
	return ((unsigned char)s1[i] - (unsigned char)s2[n]);
    3e45:	8b 55 ec             	mov    -0x14(%rbp),%edx
    3e48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3e4c:	48 01 d0             	add    %rdx,%rax
    3e4f:	0f b6 00             	movzbl (%rax),%eax
    3e52:	0f b6 c0             	movzbl %al,%eax
    3e55:	8b 4d cc             	mov    -0x34(%rbp),%ecx
    3e58:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    3e5c:	48 01 ca             	add    %rcx,%rdx
    3e5f:	0f b6 12             	movzbl (%rdx),%edx
    3e62:	0f b6 d2             	movzbl %dl,%edx
    3e65:	29 d0                	sub    %edx,%eax
}
    3e67:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    3e6b:	c9                   	leave  
    3e6c:	c3                   	ret    

0000000000003e6d <ft_extension>:

int	ft_extension(char *str, char *end)
{
    3e6d:	f3 0f 1e fa          	endbr64 
    3e71:	55                   	push   %rbp
    3e72:	48 89 e5             	mov    %rsp,%rbp
    3e75:	48 83 ec 20          	sub    $0x20,%rsp
    3e79:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    3e7d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int	len;
	int	count;

	len = ft_strlen(str) - 1;
    3e81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3e85:	48 89 c7             	mov    %rax,%rdi
    3e88:	e8 50 f6 ff ff       	call   34dd <ft_strlen>
    3e8d:	83 e8 01             	sub    $0x1,%eax
    3e90:	89 45 f8             	mov    %eax,-0x8(%rbp)
	count = ft_strlen(end) - 1;
    3e93:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3e97:	48 89 c7             	mov    %rax,%rdi
    3e9a:	e8 3e f6 ff ff       	call   34dd <ft_strlen>
    3e9f:	83 e8 01             	sub    $0x1,%eax
    3ea2:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (len == count)
    3ea5:	8b 45 f8             	mov    -0x8(%rbp),%eax
    3ea8:	3b 45 fc             	cmp    -0x4(%rbp),%eax
    3eab:	75 0b                	jne    3eb8 <ft_extension+0x4b>
		return (0);
    3ead:	b8 00 00 00 00       	mov    $0x0,%eax
    3eb2:	eb 4c                	jmp    3f00 <ft_extension+0x93>
	while ((str[len--] == end[count]) && ((count > 0) && (len > 0)))
		count--;
    3eb4:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
	while ((str[len--] == end[count]) && ((count > 0) && (len > 0)))
    3eb8:	8b 45 f8             	mov    -0x8(%rbp),%eax
    3ebb:	8d 50 ff             	lea    -0x1(%rax),%edx
    3ebe:	89 55 f8             	mov    %edx,-0x8(%rbp)
    3ec1:	48 63 d0             	movslq %eax,%rdx
    3ec4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3ec8:	48 01 d0             	add    %rdx,%rax
    3ecb:	0f b6 10             	movzbl (%rax),%edx
    3ece:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3ed1:	48 63 c8             	movslq %eax,%rcx
    3ed4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3ed8:	48 01 c8             	add    %rcx,%rax
    3edb:	0f b6 00             	movzbl (%rax),%eax
    3ede:	38 c2                	cmp    %al,%dl
    3ee0:	75 0c                	jne    3eee <ft_extension+0x81>
    3ee2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
    3ee6:	7e 06                	jle    3eee <ft_extension+0x81>
    3ee8:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
    3eec:	7f c6                	jg     3eb4 <ft_extension+0x47>
	if (count == 0)
    3eee:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
    3ef2:	75 07                	jne    3efb <ft_extension+0x8e>
		return (1);
    3ef4:	b8 01 00 00 00       	mov    $0x1,%eax
    3ef9:	eb 05                	jmp    3f00 <ft_extension+0x93>
	return (0);
    3efb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3f00:	c9                   	leave  
    3f01:	c3                   	ret    

0000000000003f02 <ft_strdup>:
/* ************************************************************************** */

#include "utils.h"

char	*ft_strdup(const char *src)
{
    3f02:	f3 0f 1e fa          	endbr64 
    3f06:	55                   	push   %rbp
    3f07:	48 89 e5             	mov    %rsp,%rbp
    3f0a:	48 83 ec 20          	sub    $0x20,%rsp
    3f0e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char	*str;
	int		i;

	if (!src)
    3f12:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    3f17:	75 07                	jne    3f20 <ft_strdup+0x1e>
		return (NULL);
    3f19:	b8 00 00 00 00       	mov    $0x0,%eax
    3f1e:	eb 6d                	jmp    3f8d <ft_strdup+0x8b>
	i = ft_strlen(src);
    3f20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3f24:	48 89 c7             	mov    %rax,%rdi
    3f27:	e8 b1 f5 ff ff       	call   34dd <ft_strlen>
    3f2c:	89 45 f4             	mov    %eax,-0xc(%rbp)
	str = malloc((i + 1) * sizeof(char));
    3f2f:	8b 45 f4             	mov    -0xc(%rbp),%eax
    3f32:	83 c0 01             	add    $0x1,%eax
    3f35:	48 98                	cltq   
    3f37:	48 89 c7             	mov    %rax,%rdi
    3f3a:	e8 e1 e1 ff ff       	call   2120 <malloc@plt>
    3f3f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!str)
    3f43:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    3f48:	75 07                	jne    3f51 <ft_strdup+0x4f>
		return (NULL);
    3f4a:	b8 00 00 00 00       	mov    $0x0,%eax
    3f4f:	eb 3c                	jmp    3f8d <ft_strdup+0x8b>
	ft_memcpy(str, src, i);
    3f51:	8b 45 f4             	mov    -0xc(%rbp),%eax
    3f54:	48 63 d0             	movslq %eax,%rdx
    3f57:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
    3f5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3f5f:	48 89 ce             	mov    %rcx,%rsi
    3f62:	48 89 c7             	mov    %rax,%rdi
    3f65:	e8 b7 f6 ff ff       	call   3621 <ft_memcpy>
	ft_memset(str + i, '\0', sizeof(char));
    3f6a:	8b 45 f4             	mov    -0xc(%rbp),%eax
    3f6d:	48 63 d0             	movslq %eax,%rdx
    3f70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3f74:	48 01 d0             	add    %rdx,%rax
    3f77:	ba 01 00 00 00       	mov    $0x1,%edx
    3f7c:	be 00 00 00 00       	mov    $0x0,%esi
    3f81:	48 89 c7             	mov    %rax,%rdi
    3f84:	e8 17 f0 ff ff       	call   2fa0 <ft_memset>
	return (str);
    3f89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    3f8d:	c9                   	leave  
    3f8e:	c3                   	ret    

0000000000003f8f <ft_strcpy>:
/* ************************************************************************** */

#include "utils.h"

static char	*ft_strcpy(char *dest, char *src)
{
    3f8f:	f3 0f 1e fa          	endbr64 
    3f93:	55                   	push   %rbp
    3f94:	48 89 e5             	mov    %rsp,%rbp
    3f97:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    3f9b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int	index;

	index = 0;
    3f9f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	while (src[index] != '\0')
    3fa6:	eb 23                	jmp    3fcb <ft_strcpy+0x3c>
	{
		dest[index] = src[index];
    3fa8:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3fab:	48 63 d0             	movslq %eax,%rdx
    3fae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3fb2:	48 01 d0             	add    %rdx,%rax
    3fb5:	8b 55 fc             	mov    -0x4(%rbp),%edx
    3fb8:	48 63 ca             	movslq %edx,%rcx
    3fbb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    3fbf:	48 01 ca             	add    %rcx,%rdx
    3fc2:	0f b6 00             	movzbl (%rax),%eax
    3fc5:	88 02                	mov    %al,(%rdx)
		index++;
    3fc7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	while (src[index] != '\0')
    3fcb:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3fce:	48 63 d0             	movslq %eax,%rdx
    3fd1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3fd5:	48 01 d0             	add    %rdx,%rax
    3fd8:	0f b6 00             	movzbl (%rax),%eax
    3fdb:	84 c0                	test   %al,%al
    3fdd:	75 c9                	jne    3fa8 <ft_strcpy+0x19>
	}
	dest[index] = '\0';
    3fdf:	8b 45 fc             	mov    -0x4(%rbp),%eax
    3fe2:	48 63 d0             	movslq %eax,%rdx
    3fe5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3fe9:	48 01 d0             	add    %rdx,%rax
    3fec:	c6 00 00             	movb   $0x0,(%rax)
	return (dest);
    3fef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
    3ff3:	5d                   	pop    %rbp
    3ff4:	c3                   	ret    

0000000000003ff5 <ft_compute_final_length>:

static int	ft_compute_final_length(char **strings, int size, int sep_length)
{
    3ff5:	f3 0f 1e fa          	endbr64 
    3ff9:	55                   	push   %rbp
    3ffa:	48 89 e5             	mov    %rsp,%rbp
    3ffd:	48 83 ec 20          	sub    $0x20,%rsp
    4001:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    4005:	89 75 e4             	mov    %esi,-0x1c(%rbp)
    4008:	89 55 e0             	mov    %edx,-0x20(%rbp)
	int	final_length;
	int	i;

	final_length = 0;
    400b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	i = -1;
    4012:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
	while (++i < size)
    4019:	eb 3a                	jmp    4055 <ft_compute_final_length+0x60>
	{
		final_length += ft_strlen(strings[i]);
    401b:	8b 45 fc             	mov    -0x4(%rbp),%eax
    401e:	48 98                	cltq   
    4020:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    4027:	00 
    4028:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    402c:	48 01 d0             	add    %rdx,%rax
    402f:	48 8b 00             	mov    (%rax),%rax
    4032:	48 89 c7             	mov    %rax,%rdi
    4035:	e8 a3 f4 ff ff       	call   34dd <ft_strlen>
    403a:	89 c2                	mov    %eax,%edx
    403c:	8b 45 f8             	mov    -0x8(%rbp),%eax
    403f:	01 d0                	add    %edx,%eax
    4041:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (i < size - 1)
    4044:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    4047:	83 e8 01             	sub    $0x1,%eax
    404a:	39 45 fc             	cmp    %eax,-0x4(%rbp)
    404d:	7d 06                	jge    4055 <ft_compute_final_length+0x60>
			final_length += sep_length;
    404f:	8b 45 e0             	mov    -0x20(%rbp),%eax
    4052:	01 45 f8             	add    %eax,-0x8(%rbp)
	while (++i < size)
    4055:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    4059:	8b 45 fc             	mov    -0x4(%rbp),%eax
    405c:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
    405f:	7c ba                	jl     401b <ft_compute_final_length+0x26>
	}
	return (final_length);
    4061:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
    4064:	c9                   	leave  
    4065:	c3                   	ret    

0000000000004066 <ft_strjoin_arr>:

char	*ft_strjoin_arr(int size, char **strs, char *sep)
{
    4066:	f3 0f 1e fa          	endbr64 
    406a:	55                   	push   %rbp
    406b:	48 89 e5             	mov    %rsp,%rbp
    406e:	48 83 ec 40          	sub    $0x40,%rsp
    4072:	89 7d dc             	mov    %edi,-0x24(%rbp)
    4075:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    4079:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int		full_length;
	int		i;
	char	*string;
	char	*tmp;

	if (!size)
    407d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
    4081:	75 14                	jne    4097 <ft_strjoin_arr+0x31>
		return ((char *)ft_calloc(1, sizeof(char)));
    4083:	be 01 00 00 00       	mov    $0x1,%esi
    4088:	bf 01 00 00 00       	mov    $0x1,%edi
    408d:	e8 7c ef ff ff       	call   300e <ft_calloc>
    4092:	e9 ea 00 00 00       	jmp    4181 <ft_strjoin_arr+0x11b>
	full_length = ft_compute_final_length(strs, size, ft_strlen(sep));
    4097:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    409b:	48 89 c7             	mov    %rax,%rdi
    409e:	e8 3a f4 ff ff       	call   34dd <ft_strlen>
    40a3:	89 c2                	mov    %eax,%edx
    40a5:	8b 4d dc             	mov    -0x24(%rbp),%ecx
    40a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    40ac:	89 ce                	mov    %ecx,%esi
    40ae:	48 89 c7             	mov    %rax,%rdi
    40b1:	e8 3f ff ff ff       	call   3ff5 <ft_compute_final_length>
    40b6:	89 45 ec             	mov    %eax,-0x14(%rbp)
	string = (char *)malloc((full_length + 1) * sizeof(char));
    40b9:	8b 45 ec             	mov    -0x14(%rbp),%eax
    40bc:	83 c0 01             	add    $0x1,%eax
    40bf:	48 98                	cltq   
    40c1:	48 89 c7             	mov    %rax,%rdi
    40c4:	e8 57 e0 ff ff       	call   2120 <malloc@plt>
    40c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!string)
    40cd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    40d2:	75 0a                	jne    40de <ft_strjoin_arr+0x78>
		return (NULL);
    40d4:	b8 00 00 00 00       	mov    $0x0,%eax
    40d9:	e9 a3 00 00 00       	jmp    4181 <ft_strjoin_arr+0x11b>
	tmp = string;
    40de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    40e2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	i = -1;
    40e6:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%rbp)
	while (++i < size)
    40ed:	eb 77                	jmp    4166 <ft_strjoin_arr+0x100>
	{
		ft_strcpy(tmp, strs[i]);
    40ef:	8b 45 e8             	mov    -0x18(%rbp),%eax
    40f2:	48 98                	cltq   
    40f4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    40fb:	00 
    40fc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4100:	48 01 d0             	add    %rdx,%rax
    4103:	48 8b 10             	mov    (%rax),%rdx
    4106:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    410a:	48 89 d6             	mov    %rdx,%rsi
    410d:	48 89 c7             	mov    %rax,%rdi
    4110:	e8 7a fe ff ff       	call   3f8f <ft_strcpy>
		tmp += ft_strlen(strs[i]);
    4115:	8b 45 e8             	mov    -0x18(%rbp),%eax
    4118:	48 98                	cltq   
    411a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    4121:	00 
    4122:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4126:	48 01 d0             	add    %rdx,%rax
    4129:	48 8b 00             	mov    (%rax),%rax
    412c:	48 89 c7             	mov    %rax,%rdi
    412f:	e8 a9 f3 ff ff       	call   34dd <ft_strlen>
    4134:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if (i < size - 1)
    4138:	8b 45 dc             	mov    -0x24(%rbp),%eax
    413b:	83 e8 01             	sub    $0x1,%eax
    413e:	39 45 e8             	cmp    %eax,-0x18(%rbp)
    4141:	7d 23                	jge    4166 <ft_strjoin_arr+0x100>
		{
			ft_strcpy(tmp, sep);
    4143:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    4147:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    414b:	48 89 d6             	mov    %rdx,%rsi
    414e:	48 89 c7             	mov    %rax,%rdi
    4151:	e8 39 fe ff ff       	call   3f8f <ft_strcpy>
			tmp += ft_strlen(sep);
    4156:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    415a:	48 89 c7             	mov    %rax,%rdi
    415d:	e8 7b f3 ff ff       	call   34dd <ft_strlen>
    4162:	48 01 45 f0          	add    %rax,-0x10(%rbp)
	while (++i < size)
    4166:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
    416a:	8b 45 e8             	mov    -0x18(%rbp),%eax
    416d:	3b 45 dc             	cmp    -0x24(%rbp),%eax
    4170:	0f 8c 79 ff ff ff    	jl     40ef <ft_strjoin_arr+0x89>
		}
	}
	*tmp = '\0';
    4176:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    417a:	c6 00 00             	movb   $0x0,(%rax)
	return (string);
    417d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    4181:	c9                   	leave  
    4182:	c3                   	ret    

0000000000004183 <ft_strjoin>:

char	*ft_strjoin(char *s1, char *s2)
{
    4183:	f3 0f 1e fa          	endbr64 
    4187:	55                   	push   %rbp
    4188:	48 89 e5             	mov    %rsp,%rbp
    418b:	48 83 ec 20          	sub    $0x20,%rsp
    418f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    4193:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char	*str;
	int		i;
	int		j;

	if (!s1)
    4197:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    419c:	75 13                	jne    41b1 <ft_strjoin+0x2e>
		s1 = (char *)ft_calloc(1, sizeof(char));
    419e:	be 01 00 00 00       	mov    $0x1,%esi
    41a3:	bf 01 00 00 00       	mov    $0x1,%edi
    41a8:	e8 61 ee ff ff       	call   300e <ft_calloc>
    41ad:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (!s1)
    41b1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    41b6:	75 0a                	jne    41c2 <ft_strjoin+0x3f>
		return (NULL);
    41b8:	b8 00 00 00 00       	mov    $0x0,%eax
    41bd:	e9 e0 00 00 00       	jmp    42a2 <ft_strjoin+0x11f>
	if (!s2)
    41c2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
    41c7:	75 16                	jne    41df <ft_strjoin+0x5c>
		return (free(s1), NULL);
    41c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    41cd:	48 89 c7             	mov    %rax,%rdi
    41d0:	e8 5b de ff ff       	call   2030 <free@plt>
    41d5:	b8 00 00 00 00       	mov    $0x0,%eax
    41da:	e9 c3 00 00 00       	jmp    42a2 <ft_strjoin+0x11f>
	i = ft_strlen(s1);
    41df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    41e3:	48 89 c7             	mov    %rax,%rdi
    41e6:	e8 f2 f2 ff ff       	call   34dd <ft_strlen>
    41eb:	89 45 f0             	mov    %eax,-0x10(%rbp)
	j = ft_strlen(s2);
    41ee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    41f2:	48 89 c7             	mov    %rax,%rdi
    41f5:	e8 e3 f2 ff ff       	call   34dd <ft_strlen>
    41fa:	89 45 f4             	mov    %eax,-0xc(%rbp)
	str = malloc(
			sizeof(char) * (i + j + 1));
    41fd:	8b 55 f0             	mov    -0x10(%rbp),%edx
    4200:	8b 45 f4             	mov    -0xc(%rbp),%eax
    4203:	01 d0                	add    %edx,%eax
    4205:	83 c0 01             	add    $0x1,%eax
	str = malloc(
    4208:	48 98                	cltq   
    420a:	48 89 c7             	mov    %rax,%rdi
    420d:	e8 0e df ff ff       	call   2120 <malloc@plt>
    4212:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!str)
    4216:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    421b:	75 13                	jne    4230 <ft_strjoin+0xad>
		return (free(s1), NULL);
    421d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4221:	48 89 c7             	mov    %rax,%rdi
    4224:	e8 07 de ff ff       	call   2030 <free@plt>
    4229:	b8 00 00 00 00       	mov    $0x0,%eax
    422e:	eb 72                	jmp    42a2 <ft_strjoin+0x11f>
	ft_memcpy(str, s1, i);
    4230:	8b 45 f0             	mov    -0x10(%rbp),%eax
    4233:	48 63 d0             	movslq %eax,%rdx
    4236:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
    423a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    423e:	48 89 ce             	mov    %rcx,%rsi
    4241:	48 89 c7             	mov    %rax,%rdi
    4244:	e8 d8 f3 ff ff       	call   3621 <ft_memcpy>
	ft_memcpy(str + i, s2, j);
    4249:	8b 45 f4             	mov    -0xc(%rbp),%eax
    424c:	48 63 d0             	movslq %eax,%rdx
    424f:	8b 45 f0             	mov    -0x10(%rbp),%eax
    4252:	48 63 c8             	movslq %eax,%rcx
    4255:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4259:	48 01 c1             	add    %rax,%rcx
    425c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    4260:	48 89 c6             	mov    %rax,%rsi
    4263:	48 89 cf             	mov    %rcx,%rdi
    4266:	e8 b6 f3 ff ff       	call   3621 <ft_memcpy>
	ft_memset(str + i + j, '\0', sizeof(char));
    426b:	8b 45 f0             	mov    -0x10(%rbp),%eax
    426e:	48 63 d0             	movslq %eax,%rdx
    4271:	8b 45 f4             	mov    -0xc(%rbp),%eax
    4274:	48 98                	cltq   
    4276:	48 01 c2             	add    %rax,%rdx
    4279:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    427d:	48 01 d0             	add    %rdx,%rax
    4280:	ba 01 00 00 00       	mov    $0x1,%edx
    4285:	be 00 00 00 00       	mov    $0x0,%esi
    428a:	48 89 c7             	mov    %rax,%rdi
    428d:	e8 0e ed ff ff       	call   2fa0 <ft_memset>
	free(s1);
    4292:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4296:	48 89 c7             	mov    %rax,%rdi
    4299:	e8 92 dd ff ff       	call   2030 <free@plt>
	return (str);
    429e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    42a2:	c9                   	leave  
    42a3:	c3                   	ret    

00000000000042a4 <ft_strlcpy>:
/* ************************************************************************** */

#include "utils.h"

int	ft_strlcpy(char *dest, char *src, uint32_t size)
{
    42a4:	f3 0f 1e fa          	endbr64 
    42a8:	55                   	push   %rbp
    42a9:	48 89 e5             	mov    %rsp,%rbp
    42ac:	48 83 ec 30          	sub    $0x30,%rsp
    42b0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    42b4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    42b8:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint32_t	i;
	uint32_t	x;

	x = ft_strlen(src);
    42bb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    42bf:	48 89 c7             	mov    %rax,%rdi
    42c2:	e8 16 f2 ff ff       	call   34dd <ft_strlen>
    42c7:	89 45 fc             	mov    %eax,-0x4(%rbp)
	i = 0;
    42ca:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	if (size != 0)
    42d1:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
    42d5:	74 38                	je     430f <ft_strlcpy+0x6b>
	{
		while (i < size && src[i] != '\0')
    42d7:	eb 1d                	jmp    42f6 <ft_strlcpy+0x52>
		{
			dest[i] = src[i];
    42d9:	8b 55 f8             	mov    -0x8(%rbp),%edx
    42dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    42e0:	48 01 d0             	add    %rdx,%rax
    42e3:	8b 4d f8             	mov    -0x8(%rbp),%ecx
    42e6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    42ea:	48 01 ca             	add    %rcx,%rdx
    42ed:	0f b6 00             	movzbl (%rax),%eax
    42f0:	88 02                	mov    %al,(%rdx)
			i++;
    42f2:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
		while (i < size && src[i] != '\0')
    42f6:	8b 45 f8             	mov    -0x8(%rbp),%eax
    42f9:	3b 45 dc             	cmp    -0x24(%rbp),%eax
    42fc:	73 11                	jae    430f <ft_strlcpy+0x6b>
    42fe:	8b 55 f8             	mov    -0x8(%rbp),%edx
    4301:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    4305:	48 01 d0             	add    %rdx,%rax
    4308:	0f b6 00             	movzbl (%rax),%eax
    430b:	84 c0                	test   %al,%al
    430d:	75 ca                	jne    42d9 <ft_strlcpy+0x35>
		}
	}
	return (x);
    430f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
    4312:	c9                   	leave  
    4313:	c3                   	ret    

0000000000004314 <ft_char_in_set>:
/* ************************************************************************** */

#include "utils.h"

static int	ft_char_in_set(char c, char const *set)
{
    4314:	f3 0f 1e fa          	endbr64 
    4318:	55                   	push   %rbp
    4319:	48 89 e5             	mov    %rsp,%rbp
    431c:	89 f8                	mov    %edi,%eax
    431e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    4322:	88 45 ec             	mov    %al,-0x14(%rbp)
	size_t	i;

	i = 0;
    4325:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    432c:	00 
	while (set[i])
    432d:	eb 1f                	jmp    434e <ft_char_in_set+0x3a>
	{
		if (set[i] == c)
    432f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    4333:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4337:	48 01 d0             	add    %rdx,%rax
    433a:	0f b6 00             	movzbl (%rax),%eax
    433d:	38 45 ec             	cmp    %al,-0x14(%rbp)
    4340:	75 07                	jne    4349 <ft_char_in_set+0x35>
			return (1);
    4342:	b8 01 00 00 00       	mov    $0x1,%eax
    4347:	eb 1c                	jmp    4365 <ft_char_in_set+0x51>
		i++;
    4349:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	while (set[i])
    434e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    4352:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4356:	48 01 d0             	add    %rdx,%rax
    4359:	0f b6 00             	movzbl (%rax),%eax
    435c:	84 c0                	test   %al,%al
    435e:	75 cf                	jne    432f <ft_char_in_set+0x1b>
	}
	return (0);
    4360:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4365:	5d                   	pop    %rbp
    4366:	c3                   	ret    

0000000000004367 <ft_strtrim>:

char	*ft_strtrim(char const *s1, char const *set)
{
    4367:	f3 0f 1e fa          	endbr64 
    436b:	55                   	push   %rbp
    436c:	48 89 e5             	mov    %rsp,%rbp
    436f:	48 83 ec 30          	sub    $0x30,%rsp
    4373:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    4377:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char	*str;
	size_t	i;
	size_t	start;
	size_t	end;

	start = 0;
    437b:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    4382:	00 
	while (s1[start] && ft_char_in_set(s1[start], set))
    4383:	eb 05                	jmp    438a <ft_strtrim+0x23>
		start++;
    4385:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	while (s1[start] && ft_char_in_set(s1[start], set))
    438a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    438e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4392:	48 01 d0             	add    %rdx,%rax
    4395:	0f b6 00             	movzbl (%rax),%eax
    4398:	84 c0                	test   %al,%al
    439a:	74 23                	je     43bf <ft_strtrim+0x58>
    439c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    43a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    43a4:	48 01 d0             	add    %rdx,%rax
    43a7:	0f b6 00             	movzbl (%rax),%eax
    43aa:	0f be c0             	movsbl %al,%eax
    43ad:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    43b1:	48 89 d6             	mov    %rdx,%rsi
    43b4:	89 c7                	mov    %eax,%edi
    43b6:	e8 59 ff ff ff       	call   4314 <ft_char_in_set>
    43bb:	85 c0                	test   %eax,%eax
    43bd:	75 c6                	jne    4385 <ft_strtrim+0x1e>
	end = ft_strlen(s1);
    43bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    43c3:	48 89 c7             	mov    %rax,%rdi
    43c6:	e8 12 f1 ff ff       	call   34dd <ft_strlen>
    43cb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (end > start && ft_char_in_set(s1[end - 1], set))
    43cf:	eb 05                	jmp    43d6 <ft_strtrim+0x6f>
		end--;
    43d1:	48 83 6d f0 01       	subq   $0x1,-0x10(%rbp)
	while (end > start && ft_char_in_set(s1[end - 1], set))
    43d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    43da:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
    43de:	76 27                	jbe    4407 <ft_strtrim+0xa0>
    43e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    43e4:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    43e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    43ec:	48 01 d0             	add    %rdx,%rax
    43ef:	0f b6 00             	movzbl (%rax),%eax
    43f2:	0f be c0             	movsbl %al,%eax
    43f5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    43f9:	48 89 d6             	mov    %rdx,%rsi
    43fc:	89 c7                	mov    %eax,%edi
    43fe:	e8 11 ff ff ff       	call   4314 <ft_char_in_set>
    4403:	85 c0                	test   %eax,%eax
    4405:	75 ca                	jne    43d1 <ft_strtrim+0x6a>
	str = (char *)malloc(sizeof(*s1) * (end - start + 1));
    4407:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    440b:	48 2b 45 e8          	sub    -0x18(%rbp),%rax
    440f:	48 83 c0 01          	add    $0x1,%rax
    4413:	48 89 c7             	mov    %rax,%rdi
    4416:	e8 05 dd ff ff       	call   2120 <malloc@plt>
    441b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!str)
    441f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    4424:	75 07                	jne    442d <ft_strtrim+0xc6>
		return (NULL);
    4426:	b8 00 00 00 00       	mov    $0x0,%eax
    442b:	eb 52                	jmp    447f <ft_strtrim+0x118>
	i = 0;
    442d:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    4434:	00 
	while (start < end)
    4435:	eb 2c                	jmp    4463 <ft_strtrim+0xfc>
		str[i++] = s1[start++];
    4437:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    443b:	48 8d 50 01          	lea    0x1(%rax),%rdx
    443f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    4443:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    4447:	48 8d 0c 10          	lea    (%rax,%rdx,1),%rcx
    444b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    444f:	48 8d 50 01          	lea    0x1(%rax),%rdx
    4453:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
    4457:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    445b:	48 01 c2             	add    %rax,%rdx
    445e:	0f b6 01             	movzbl (%rcx),%eax
    4461:	88 02                	mov    %al,(%rdx)
	while (start < end)
    4463:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4467:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
    446b:	72 ca                	jb     4437 <ft_strtrim+0xd0>
	str[i] = 0;
    446d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    4471:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    4475:	48 01 d0             	add    %rdx,%rax
    4478:	c6 00 00             	movb   $0x0,(%rax)
	return (str);
    447b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    447f:	c9                   	leave  
    4480:	c3                   	ret    

0000000000004481 <ft_realloc>:
/* ************************************************************************** */

#include "utils.h"

void	*ft_realloc(void *ptr, size_t size)
{
    4481:	f3 0f 1e fa          	endbr64 
    4485:	55                   	push   %rbp
    4486:	48 89 e5             	mov    %rsp,%rbp
    4489:	48 83 ec 20          	sub    $0x20,%rsp
    448d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    4491:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	void	*new_ptr;

	new_ptr = malloc(size);
    4495:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    4499:	48 89 c7             	mov    %rax,%rdi
    449c:	e8 7f dc ff ff       	call   2120 <malloc@plt>
    44a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!new_ptr)
    44a5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    44aa:	75 07                	jne    44b3 <ft_realloc+0x32>
		return (NULL);
    44ac:	b8 00 00 00 00       	mov    $0x0,%eax
    44b1:	eb 2e                	jmp    44e1 <ft_realloc+0x60>
	if (ptr)
    44b3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    44b8:	74 23                	je     44dd <ft_realloc+0x5c>
	{
		ft_memcpy(new_ptr, ptr, size);
    44ba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    44be:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
    44c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    44c6:	48 89 ce             	mov    %rcx,%rsi
    44c9:	48 89 c7             	mov    %rax,%rdi
    44cc:	e8 50 f1 ff ff       	call   3621 <ft_memcpy>
		free(ptr);
    44d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    44d5:	48 89 c7             	mov    %rax,%rdi
    44d8:	e8 53 db ff ff       	call   2030 <free@plt>
	}
	return (new_ptr);
    44dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    44e1:	c9                   	leave  
    44e2:	c3                   	ret    

00000000000044e3 <get_type_name>:
/* ************************************************************************** */

#include "woody.h"

static void	get_type_name(t_binary_reader *reader, t_elf_file *elf_file)
{
    44e3:	f3 0f 1e fa          	endbr64 
    44e7:	55                   	push   %rbp
    44e8:	48 89 e5             	mov    %rsp,%rbp
    44eb:	48 83 ec 10          	sub    $0x10,%rsp
    44ef:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    44f3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	reader->seek(reader, 0x10);
    44f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    44fb:	48 8b 50 18          	mov    0x18(%rax),%rdx
    44ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4503:	be 10 00 00 00       	mov    $0x10,%esi
    4508:	48 89 c7             	mov    %rax,%rdi
    450b:	ff d2                	call   *%rdx
	elf_file->e_type = reader->get_uint16(reader);
    450d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4511:	48 8b 50 30          	mov    0x30(%rax),%rdx
    4515:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4519:	48 89 c7             	mov    %rax,%rdi
    451c:	ff d2                	call   *%rdx
    451e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
    4522:	66 89 42 10          	mov    %ax,0x10(%rdx)
	 switch(elf_file->e_type) {
    4526:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    452a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    452e:	0f b7 c0             	movzwl %ax,%eax
    4531:	3d ff ff 00 00       	cmp    $0xffff,%eax
    4536:	0f 84 0a 01 00 00    	je     4646 <get_type_name+0x163>
    453c:	3d ff ff 00 00       	cmp    $0xffff,%eax
    4541:	0f 8f 10 01 00 00    	jg     4657 <get_type_name+0x174>
    4547:	3d 00 ff 00 00       	cmp    $0xff00,%eax
    454c:	0f 84 e3 00 00 00    	je     4635 <get_type_name+0x152>
    4552:	3d 00 ff 00 00       	cmp    $0xff00,%eax
    4557:	0f 8f fa 00 00 00    	jg     4657 <get_type_name+0x174>
    455d:	3d ff fe 00 00       	cmp    $0xfeff,%eax
    4562:	0f 84 bc 00 00 00    	je     4624 <get_type_name+0x141>
    4568:	3d ff fe 00 00       	cmp    $0xfeff,%eax
    456d:	0f 8f e4 00 00 00    	jg     4657 <get_type_name+0x174>
    4573:	83 f8 04             	cmp    $0x4,%eax
    4576:	7f 34                	jg     45ac <get_type_name+0xc9>
    4578:	85 c0                	test   %eax,%eax
    457a:	0f 88 d7 00 00 00    	js     4657 <get_type_name+0x174>
    4580:	83 f8 04             	cmp    $0x4,%eax
    4583:	0f 87 ce 00 00 00    	ja     4657 <get_type_name+0x174>
    4589:	89 c0                	mov    %eax,%eax
    458b:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
    4592:	00 
    4593:	48 8d 05 96 3c 00 00 	lea    0x3c96(%rip),%rax        # 8230 <rcon+0x1f0>
    459a:	8b 04 02             	mov    (%rdx,%rax,1),%eax
    459d:	48 98                	cltq   
    459f:	48 8d 15 8a 3c 00 00 	lea    0x3c8a(%rip),%rdx        # 8230 <rcon+0x1f0>
    45a6:	48 01 d0             	add    %rdx,%rax
    45a9:	3e ff e0             	notrack jmp *%rax
    45ac:	3d 00 fe 00 00       	cmp    $0xfe00,%eax
    45b1:	74 60                	je     4613 <get_type_name+0x130>
    45b3:	e9 9f 00 00 00       	jmp    4657 <get_type_name+0x174>
		case 0x00 :
			elf_file->e_type_name = "NONE";
    45b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    45bc:	48 8d 15 52 3c 00 00 	lea    0x3c52(%rip),%rdx        # 8215 <rcon+0x1d5>
    45c3:	48 89 50 18          	mov    %rdx,0x18(%rax)
			break;
    45c7:	e9 9b 00 00 00       	jmp    4667 <get_type_name+0x184>
		case 0x01 :
			elf_file->e_type_name = "REL";
    45cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    45d0:	48 8d 15 cf 3a 00 00 	lea    0x3acf(%rip),%rdx        # 80a6 <rcon+0x66>
    45d7:	48 89 50 18          	mov    %rdx,0x18(%rax)
			break;
    45db:	e9 87 00 00 00       	jmp    4667 <get_type_name+0x184>
		case 0x02 :
			elf_file->e_type_name = "EXEC";
    45e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    45e4:	48 8d 15 2f 3c 00 00 	lea    0x3c2f(%rip),%rdx        # 821a <rcon+0x1da>
    45eb:	48 89 50 18          	mov    %rdx,0x18(%rax)
			break;
    45ef:	eb 76                	jmp    4667 <get_type_name+0x184>
		case 0x03 :
			elf_file->e_type_name = "DYN";
    45f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    45f5:	48 8d 15 23 3c 00 00 	lea    0x3c23(%rip),%rdx        # 821f <rcon+0x1df>
    45fc:	48 89 50 18          	mov    %rdx,0x18(%rax)
			break;
    4600:	eb 65                	jmp    4667 <get_type_name+0x184>
		case 0x04 :
			elf_file->e_type_name = "CORE";
    4602:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    4606:	48 8d 15 16 3c 00 00 	lea    0x3c16(%rip),%rdx        # 8223 <rcon+0x1e3>
    460d:	48 89 50 18          	mov    %rdx,0x18(%rax)
			break;
    4611:	eb 54                	jmp    4667 <get_type_name+0x184>
		case 0xFE00 :
			elf_file->e_type_name = "LOOS";
    4613:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    4617:	48 8d 15 a5 3b 00 00 	lea    0x3ba5(%rip),%rdx        # 81c3 <rcon+0x183>
    461e:	48 89 50 18          	mov    %rdx,0x18(%rax)
			break;
    4622:	eb 43                	jmp    4667 <get_type_name+0x184>
		case 0xFEFF :
			elf_file->e_type_name = "HIOS";
    4624:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    4628:	48 8d 15 d3 3b 00 00 	lea    0x3bd3(%rip),%rdx        # 8202 <rcon+0x1c2>
    462f:	48 89 50 18          	mov    %rdx,0x18(%rax)
			break;
    4633:	eb 32                	jmp    4667 <get_type_name+0x184>
		case 0xFF00 :
			elf_file->e_type_name = "LOPROC";
    4635:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    4639:	48 8d 15 c7 3b 00 00 	lea    0x3bc7(%rip),%rdx        # 8207 <rcon+0x1c7>
    4640:	48 89 50 18          	mov    %rdx,0x18(%rax)
			break;
    4644:	eb 21                	jmp    4667 <get_type_name+0x184>
		case 0xFFFF :
			elf_file->e_type_name = "HIPROC";
    4646:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    464a:	48 8d 15 bd 3b 00 00 	lea    0x3bbd(%rip),%rdx        # 820e <rcon+0x1ce>
    4651:	48 89 50 18          	mov    %rdx,0x18(%rax)
            break;
    4655:	eb 10                	jmp    4667 <get_type_name+0x184>
        default:
			elf_file->e_type_name = "Error";
    4657:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    465b:	48 8d 15 c6 3b 00 00 	lea    0x3bc6(%rip),%rdx        # 8228 <rcon+0x1e8>
    4662:	48 89 50 18          	mov    %rdx,0x18(%rax)
    }
}
    4666:	90                   	nop
    4667:	90                   	nop
    4668:	c9                   	leave  
    4669:	c3                   	ret    

000000000000466a <get_elf_tables_offset>:

static int	get_elf_tables_offset(t_elf_file *elf_file, t_binary_reader *reader)
{
    466a:	f3 0f 1e fa          	endbr64 
    466e:	55                   	push   %rbp
    466f:	48 89 e5             	mov    %rsp,%rbp
    4672:	53                   	push   %rbx
    4673:	48 83 ec 28          	sub    $0x28,%rsp
    4677:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    467b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	reader->seek(reader, elf_file->e_shoff);
    467f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4683:	48 8b 50 18          	mov    0x18(%rax),%rdx
    4687:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    468b:	48 8b 40 38          	mov    0x38(%rax),%rax
    468f:	89 c1                	mov    %eax,%ecx
    4691:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4695:	89 ce                	mov    %ecx,%esi
    4697:	48 89 c7             	mov    %rax,%rdi
    469a:	ff d2                	call   *%rdx
	elf_file->section_tables = ft_calloc(elf_file->e_shnum, sizeof(t_elf_section_table));
    469c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    46a0:	0f b7 40 56          	movzwl 0x56(%rax),%eax
    46a4:	0f b7 c0             	movzwl %ax,%eax
    46a7:	be 30 00 00 00       	mov    $0x30,%esi
    46ac:	48 89 c7             	mov    %rax,%rdi
    46af:	e8 5a e9 ff ff       	call   300e <ft_calloc>
    46b4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    46b8:	48 89 42 60          	mov    %rax,0x60(%rdx)
	if (elf_file->section_tables == NULL)
    46bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    46c0:	48 8b 40 60          	mov    0x60(%rax),%rax
    46c4:	48 85 c0             	test   %rax,%rax
    46c7:	75 16                	jne    46df <get_elf_tables_offset+0x75>
		return (ft_error(WD_PREFIX"Could not allocate memory.\n"), 1);
    46c9:	48 8d 3d 78 3b 00 00 	lea    0x3b78(%rip),%rdi        # 8248 <rcon+0x208>
    46d0:	e8 cb e9 ff ff       	call   30a0 <ft_error>
    46d5:	b8 01 00 00 00       	mov    $0x1,%eax
    46da:	e9 b7 03 00 00       	jmp    4a96 <get_elf_tables_offset+0x42c>
	for (int i = 0; i < elf_file->e_shnum; i++)
    46df:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    46e6:	e9 9e 02 00 00       	jmp    4989 <get_elf_tables_offset+0x31f>
	{
		elf_file->section_tables[i].sh_name_offset = reader->get_uint32(reader);
    46eb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    46ef:	48 8b 50 38          	mov    0x38(%rax),%rdx
    46f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    46f7:	48 8b 70 60          	mov    0x60(%rax),%rsi
    46fb:	8b 45 e8             	mov    -0x18(%rbp),%eax
    46fe:	48 63 c8             	movslq %eax,%rcx
    4701:	48 89 c8             	mov    %rcx,%rax
    4704:	48 01 c0             	add    %rax,%rax
    4707:	48 01 c8             	add    %rcx,%rax
    470a:	48 c1 e0 04          	shl    $0x4,%rax
    470e:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4712:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4716:	48 89 c7             	mov    %rax,%rdi
    4719:	ff d2                	call   *%rdx
    471b:	89 03                	mov    %eax,(%rbx)
		elf_file->section_tables[i].sh_type = reader->get_uint32(reader);
    471d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4721:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4725:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4729:	48 8b 70 60          	mov    0x60(%rax),%rsi
    472d:	8b 45 e8             	mov    -0x18(%rbp),%eax
    4730:	48 63 c8             	movslq %eax,%rcx
    4733:	48 89 c8             	mov    %rcx,%rax
    4736:	48 01 c0             	add    %rax,%rax
    4739:	48 01 c8             	add    %rcx,%rax
    473c:	48 c1 e0 04          	shl    $0x4,%rax
    4740:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4744:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4748:	48 89 c7             	mov    %rax,%rdi
    474b:	ff d2                	call   *%rdx
    474d:	89 43 04             	mov    %eax,0x4(%rbx)
		if (elf_file->e_ident.ei_class == WD_32BITS)
    4750:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4754:	0f b6 40 04          	movzbl 0x4(%rax),%eax
    4758:	3c 01                	cmp    $0x1,%al
    475a:	0f 85 e1 00 00 00    	jne    4841 <get_elf_tables_offset+0x1d7>
		{
			elf_file->section_tables[i].sh_flags = reader->get_uint32(reader);
    4760:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4764:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4768:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    476c:	48 89 c7             	mov    %rax,%rdi
    476f:	ff d2                	call   *%rdx
    4771:	89 c1                	mov    %eax,%ecx
    4773:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4777:	48 8b 70 60          	mov    0x60(%rax),%rsi
    477b:	8b 45 e8             	mov    -0x18(%rbp),%eax
    477e:	48 63 d0             	movslq %eax,%rdx
    4781:	48 89 d0             	mov    %rdx,%rax
    4784:	48 01 c0             	add    %rax,%rax
    4787:	48 01 d0             	add    %rdx,%rax
    478a:	48 c1 e0 04          	shl    $0x4,%rax
    478e:	48 01 f0             	add    %rsi,%rax
    4791:	89 ca                	mov    %ecx,%edx
    4793:	48 89 50 08          	mov    %rdx,0x8(%rax)
			elf_file->section_tables[i].sh_address = reader->get_uint32(reader);
    4797:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    479b:	48 8b 50 38          	mov    0x38(%rax),%rdx
    479f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    47a3:	48 89 c7             	mov    %rax,%rdi
    47a6:	ff d2                	call   *%rdx
    47a8:	89 c1                	mov    %eax,%ecx
    47aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    47ae:	48 8b 70 60          	mov    0x60(%rax),%rsi
    47b2:	8b 45 e8             	mov    -0x18(%rbp),%eax
    47b5:	48 63 d0             	movslq %eax,%rdx
    47b8:	48 89 d0             	mov    %rdx,%rax
    47bb:	48 01 c0             	add    %rax,%rax
    47be:	48 01 d0             	add    %rdx,%rax
    47c1:	48 c1 e0 04          	shl    $0x4,%rax
    47c5:	48 01 f0             	add    %rsi,%rax
    47c8:	89 ca                	mov    %ecx,%edx
    47ca:	48 89 50 10          	mov    %rdx,0x10(%rax)
			elf_file->section_tables[i].sh_offset = reader->get_uint32(reader);
    47ce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    47d2:	48 8b 50 38          	mov    0x38(%rax),%rdx
    47d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    47da:	48 89 c7             	mov    %rax,%rdi
    47dd:	ff d2                	call   *%rdx
    47df:	89 c1                	mov    %eax,%ecx
    47e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    47e5:	48 8b 70 60          	mov    0x60(%rax),%rsi
    47e9:	8b 45 e8             	mov    -0x18(%rbp),%eax
    47ec:	48 63 d0             	movslq %eax,%rdx
    47ef:	48 89 d0             	mov    %rdx,%rax
    47f2:	48 01 c0             	add    %rax,%rax
    47f5:	48 01 d0             	add    %rdx,%rax
    47f8:	48 c1 e0 04          	shl    $0x4,%rax
    47fc:	48 01 f0             	add    %rsi,%rax
    47ff:	89 ca                	mov    %ecx,%edx
    4801:	48 89 50 18          	mov    %rdx,0x18(%rax)
			elf_file->section_tables[i].sh_size = reader->get_uint32(reader);
    4805:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4809:	48 8b 50 38          	mov    0x38(%rax),%rdx
    480d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4811:	48 89 c7             	mov    %rax,%rdi
    4814:	ff d2                	call   *%rdx
    4816:	89 c1                	mov    %eax,%ecx
    4818:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    481c:	48 8b 70 60          	mov    0x60(%rax),%rsi
    4820:	8b 45 e8             	mov    -0x18(%rbp),%eax
    4823:	48 63 d0             	movslq %eax,%rdx
    4826:	48 89 d0             	mov    %rdx,%rax
    4829:	48 01 c0             	add    %rax,%rax
    482c:	48 01 d0             	add    %rdx,%rax
    482f:	48 c1 e0 04          	shl    $0x4,%rax
    4833:	48 01 f0             	add    %rsi,%rax
    4836:	89 ca                	mov    %ecx,%edx
    4838:	48 89 50 20          	mov    %rdx,0x20(%rax)
    483c:	e9 d0 00 00 00       	jmp    4911 <get_elf_tables_offset+0x2a7>
		}
		else
		{
			elf_file->section_tables[i].sh_flags = reader->get_uint64(reader);
    4841:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4845:	48 8b 50 40          	mov    0x40(%rax),%rdx
    4849:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    484d:	48 8b 70 60          	mov    0x60(%rax),%rsi
    4851:	8b 45 e8             	mov    -0x18(%rbp),%eax
    4854:	48 63 c8             	movslq %eax,%rcx
    4857:	48 89 c8             	mov    %rcx,%rax
    485a:	48 01 c0             	add    %rax,%rax
    485d:	48 01 c8             	add    %rcx,%rax
    4860:	48 c1 e0 04          	shl    $0x4,%rax
    4864:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4868:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    486c:	48 89 c7             	mov    %rax,%rdi
    486f:	ff d2                	call   *%rdx
    4871:	48 89 43 08          	mov    %rax,0x8(%rbx)
			elf_file->section_tables[i].sh_address = reader->get_uint64(reader);
    4875:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4879:	48 8b 50 40          	mov    0x40(%rax),%rdx
    487d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4881:	48 8b 70 60          	mov    0x60(%rax),%rsi
    4885:	8b 45 e8             	mov    -0x18(%rbp),%eax
    4888:	48 63 c8             	movslq %eax,%rcx
    488b:	48 89 c8             	mov    %rcx,%rax
    488e:	48 01 c0             	add    %rax,%rax
    4891:	48 01 c8             	add    %rcx,%rax
    4894:	48 c1 e0 04          	shl    $0x4,%rax
    4898:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    489c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    48a0:	48 89 c7             	mov    %rax,%rdi
    48a3:	ff d2                	call   *%rdx
    48a5:	48 89 43 10          	mov    %rax,0x10(%rbx)
			elf_file->section_tables[i].sh_offset = reader->get_uint64(reader);
    48a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    48ad:	48 8b 50 40          	mov    0x40(%rax),%rdx
    48b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    48b5:	48 8b 70 60          	mov    0x60(%rax),%rsi
    48b9:	8b 45 e8             	mov    -0x18(%rbp),%eax
    48bc:	48 63 c8             	movslq %eax,%rcx
    48bf:	48 89 c8             	mov    %rcx,%rax
    48c2:	48 01 c0             	add    %rax,%rax
    48c5:	48 01 c8             	add    %rcx,%rax
    48c8:	48 c1 e0 04          	shl    $0x4,%rax
    48cc:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    48d0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    48d4:	48 89 c7             	mov    %rax,%rdi
    48d7:	ff d2                	call   *%rdx
    48d9:	48 89 43 18          	mov    %rax,0x18(%rbx)
			elf_file->section_tables[i].sh_size = reader->get_uint64(reader);
    48dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    48e1:	48 8b 50 40          	mov    0x40(%rax),%rdx
    48e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    48e9:	48 8b 70 60          	mov    0x60(%rax),%rsi
    48ed:	8b 45 e8             	mov    -0x18(%rbp),%eax
    48f0:	48 63 c8             	movslq %eax,%rcx
    48f3:	48 89 c8             	mov    %rcx,%rax
    48f6:	48 01 c0             	add    %rax,%rax
    48f9:	48 01 c8             	add    %rcx,%rax
    48fc:	48 c1 e0 04          	shl    $0x4,%rax
    4900:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4904:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4908:	48 89 c7             	mov    %rax,%rdi
    490b:	ff d2                	call   *%rdx
    490d:	48 89 43 20          	mov    %rax,0x20(%rbx)
		}
		(void)reader->get_uint32(reader); // sh_link
    4911:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4915:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4919:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    491d:	48 89 c7             	mov    %rax,%rdi
    4920:	ff d2                	call   *%rdx
		(void)reader->get_uint32(reader); // sh_info
    4922:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4926:	48 8b 50 38          	mov    0x38(%rax),%rdx
    492a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    492e:	48 89 c7             	mov    %rax,%rdi
    4931:	ff d2                	call   *%rdx
		if (elf_file->e_ident.ei_class == WD_32BITS)
    4933:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4937:	0f b6 40 04          	movzbl 0x4(%rax),%eax
    493b:	3c 01                	cmp    $0x1,%al
    493d:	75 24                	jne    4963 <get_elf_tables_offset+0x2f9>
		{
			(void)reader->get_uint32(reader); // sh_addralign
    493f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4943:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4947:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    494b:	48 89 c7             	mov    %rax,%rdi
    494e:	ff d2                	call   *%rdx
			(void)reader->get_uint32(reader); // sh_entize
    4950:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4954:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4958:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    495c:	48 89 c7             	mov    %rax,%rdi
    495f:	ff d2                	call   *%rdx
    4961:	eb 22                	jmp    4985 <get_elf_tables_offset+0x31b>
		}
		else
		{
			(void)reader->get_uint64(reader); // sh_addralign
    4963:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4967:	48 8b 50 40          	mov    0x40(%rax),%rdx
    496b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    496f:	48 89 c7             	mov    %rax,%rdi
    4972:	ff d2                	call   *%rdx
			(void)reader->get_uint64(reader); // sh_entize
    4974:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4978:	48 8b 50 40          	mov    0x40(%rax),%rdx
    497c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4980:	48 89 c7             	mov    %rax,%rdi
    4983:	ff d2                	call   *%rdx
	for (int i = 0; i < elf_file->e_shnum; i++)
    4985:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
    4989:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    498d:	0f b7 40 56          	movzwl 0x56(%rax),%eax
    4991:	0f b7 c0             	movzwl %ax,%eax
    4994:	39 45 e8             	cmp    %eax,-0x18(%rbp)
    4997:	0f 8c 4e fd ff ff    	jl     46eb <get_elf_tables_offset+0x81>
		}
	}
	for (int i = 0; i < elf_file->e_shnum; i++)
    499d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    49a4:	e9 d4 00 00 00       	jmp    4a7d <get_elf_tables_offset+0x413>
	{
		reader->seek(reader, elf_file->section_tables[elf_file->e_shstrndx].sh_offset + elf_file->section_tables[i].sh_name_offset);
    49a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    49ad:	48 8b 50 18          	mov    0x18(%rax),%rdx
    49b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    49b5:	48 8b 70 60          	mov    0x60(%rax),%rsi
    49b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    49bd:	0f b7 40 58          	movzwl 0x58(%rax),%eax
    49c1:	0f b7 c8             	movzwl %ax,%ecx
    49c4:	48 89 c8             	mov    %rcx,%rax
    49c7:	48 01 c0             	add    %rax,%rax
    49ca:	48 01 c8             	add    %rcx,%rax
    49cd:	48 c1 e0 04          	shl    $0x4,%rax
    49d1:	48 01 f0             	add    %rsi,%rax
    49d4:	48 8b 40 18          	mov    0x18(%rax),%rax
    49d8:	89 c7                	mov    %eax,%edi
    49da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    49de:	48 8b 70 60          	mov    0x60(%rax),%rsi
    49e2:	8b 45 ec             	mov    -0x14(%rbp),%eax
    49e5:	48 63 c8             	movslq %eax,%rcx
    49e8:	48 89 c8             	mov    %rcx,%rax
    49eb:	48 01 c0             	add    %rax,%rax
    49ee:	48 01 c8             	add    %rcx,%rax
    49f1:	48 c1 e0 04          	shl    $0x4,%rax
    49f5:	48 01 f0             	add    %rsi,%rax
    49f8:	8b 00                	mov    (%rax),%eax
    49fa:	8d 0c 07             	lea    (%rdi,%rax,1),%ecx
    49fd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4a01:	89 ce                	mov    %ecx,%esi
    4a03:	48 89 c7             	mov    %rax,%rdi
    4a06:	ff d2                	call   *%rdx
		elf_file->section_tables[i].sh_name = reader->get_rstring(reader);
    4a08:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4a0c:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
    4a13:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4a17:	48 8b 70 60          	mov    0x60(%rax),%rsi
    4a1b:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4a1e:	48 63 c8             	movslq %eax,%rcx
    4a21:	48 89 c8             	mov    %rcx,%rax
    4a24:	48 01 c0             	add    %rax,%rax
    4a27:	48 01 c8             	add    %rcx,%rax
    4a2a:	48 c1 e0 04          	shl    $0x4,%rax
    4a2e:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4a32:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4a36:	48 89 c7             	mov    %rax,%rdi
    4a39:	ff d2                	call   *%rdx
    4a3b:	48 89 43 28          	mov    %rax,0x28(%rbx)
		if (elf_file->section_tables[i].sh_name == NULL)
    4a3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4a43:	48 8b 48 60          	mov    0x60(%rax),%rcx
    4a47:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4a4a:	48 63 d0             	movslq %eax,%rdx
    4a4d:	48 89 d0             	mov    %rdx,%rax
    4a50:	48 01 c0             	add    %rax,%rax
    4a53:	48 01 d0             	add    %rdx,%rax
    4a56:	48 c1 e0 04          	shl    $0x4,%rax
    4a5a:	48 01 c8             	add    %rcx,%rax
    4a5d:	48 8b 40 28          	mov    0x28(%rax),%rax
    4a61:	48 85 c0             	test   %rax,%rax
    4a64:	75 13                	jne    4a79 <get_elf_tables_offset+0x40f>
			return (ft_error(WD_PREFIX"Could not allocate memory.\n"), 1);
    4a66:	48 8d 3d db 37 00 00 	lea    0x37db(%rip),%rdi        # 8248 <rcon+0x208>
    4a6d:	e8 2e e6 ff ff       	call   30a0 <ft_error>
    4a72:	b8 01 00 00 00       	mov    $0x1,%eax
    4a77:	eb 1d                	jmp    4a96 <get_elf_tables_offset+0x42c>
	for (int i = 0; i < elf_file->e_shnum; i++)
    4a79:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
    4a7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4a81:	0f b7 40 56          	movzwl 0x56(%rax),%eax
    4a85:	0f b7 c0             	movzwl %ax,%eax
    4a88:	39 45 ec             	cmp    %eax,-0x14(%rbp)
    4a8b:	0f 8c 18 ff ff ff    	jl     49a9 <get_elf_tables_offset+0x33f>
	}
	return (0);
    4a91:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4a96:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    4a9a:	c9                   	leave  
    4a9b:	c3                   	ret    

0000000000004a9c <get_elf_program_headers>:

static int	get_elf_program_headers(t_elf_file *elf_file, t_binary_reader *reader)
{
    4a9c:	f3 0f 1e fa          	endbr64 
    4aa0:	55                   	push   %rbp
    4aa1:	48 89 e5             	mov    %rsp,%rbp
    4aa4:	53                   	push   %rbx
    4aa5:	48 83 ec 28          	sub    $0x28,%rsp
    4aa9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    4aad:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	reader->seek(reader, elf_file->e_phoff);
    4ab1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4ab5:	48 8b 50 18          	mov    0x18(%rax),%rdx
    4ab9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4abd:	48 8b 40 30          	mov    0x30(%rax),%rax
    4ac1:	89 c1                	mov    %eax,%ecx
    4ac3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4ac7:	89 ce                	mov    %ecx,%esi
    4ac9:	48 89 c7             	mov    %rax,%rdi
    4acc:	ff d2                	call   *%rdx
	elf_file->program_headers = ft_calloc(elf_file->e_phnum, sizeof(t_elf_program_header));
    4ace:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4ad2:	0f b7 40 52          	movzwl 0x52(%rax),%eax
    4ad6:	0f b7 c0             	movzwl %ax,%eax
    4ad9:	be 38 00 00 00       	mov    $0x38,%esi
    4ade:	48 89 c7             	mov    %rax,%rdi
    4ae1:	e8 28 e5 ff ff       	call   300e <ft_calloc>
    4ae6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    4aea:	48 89 42 68          	mov    %rax,0x68(%rdx)
	if (elf_file->program_headers == NULL)
    4aee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4af2:	48 8b 40 68          	mov    0x68(%rax),%rax
    4af6:	48 85 c0             	test   %rax,%rax
    4af9:	75 16                	jne    4b11 <get_elf_program_headers+0x75>
		return (ft_error(WD_PREFIX"Could not allocate memory.\n"), 1);
    4afb:	48 8d 3d 46 37 00 00 	lea    0x3746(%rip),%rdi        # 8248 <rcon+0x208>
    4b02:	e8 99 e5 ff ff       	call   30a0 <ft_error>
    4b07:	b8 01 00 00 00       	mov    $0x1,%eax
    4b0c:	e9 67 03 00 00       	jmp    4e78 <get_elf_program_headers+0x3dc>
	for (int i = 0; i < elf_file->e_phnum; i++)
    4b11:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    4b18:	e9 42 03 00 00       	jmp    4e5f <get_elf_program_headers+0x3c3>
	{
		elf_file->program_headers[i].p_type = reader->get_uint32(reader);
    4b1d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4b21:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4b25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4b29:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4b2d:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4b30:	48 63 c8             	movslq %eax,%rcx
    4b33:	48 89 c8             	mov    %rcx,%rax
    4b36:	48 c1 e0 03          	shl    $0x3,%rax
    4b3a:	48 29 c8             	sub    %rcx,%rax
    4b3d:	48 c1 e0 03          	shl    $0x3,%rax
    4b41:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4b45:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4b49:	48 89 c7             	mov    %rax,%rdi
    4b4c:	ff d2                	call   *%rdx
    4b4e:	89 03                	mov    %eax,(%rbx)
		if (elf_file->e_ident.ei_class == WD_32BITS)
    4b50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4b54:	0f b6 40 04          	movzbl 0x4(%rax),%eax
    4b58:	3c 01                	cmp    $0x1,%al
    4b5a:	0f 85 89 01 00 00    	jne    4ce9 <get_elf_program_headers+0x24d>
		{
			elf_file->program_headers[i].p_offset = reader->get_uint32(reader);
    4b60:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4b64:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4b68:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4b6c:	48 89 c7             	mov    %rax,%rdi
    4b6f:	ff d2                	call   *%rdx
    4b71:	89 c1                	mov    %eax,%ecx
    4b73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4b77:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4b7b:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4b7e:	48 63 d0             	movslq %eax,%rdx
    4b81:	48 89 d0             	mov    %rdx,%rax
    4b84:	48 c1 e0 03          	shl    $0x3,%rax
    4b88:	48 29 d0             	sub    %rdx,%rax
    4b8b:	48 c1 e0 03          	shl    $0x3,%rax
    4b8f:	48 01 f0             	add    %rsi,%rax
    4b92:	89 ca                	mov    %ecx,%edx
    4b94:	48 89 50 08          	mov    %rdx,0x8(%rax)
			elf_file->program_headers[i].p_vaddr = reader->get_uint32(reader);
    4b98:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4b9c:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4ba0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4ba4:	48 89 c7             	mov    %rax,%rdi
    4ba7:	ff d2                	call   *%rdx
    4ba9:	89 c1                	mov    %eax,%ecx
    4bab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4baf:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4bb3:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4bb6:	48 63 d0             	movslq %eax,%rdx
    4bb9:	48 89 d0             	mov    %rdx,%rax
    4bbc:	48 c1 e0 03          	shl    $0x3,%rax
    4bc0:	48 29 d0             	sub    %rdx,%rax
    4bc3:	48 c1 e0 03          	shl    $0x3,%rax
    4bc7:	48 01 f0             	add    %rsi,%rax
    4bca:	89 ca                	mov    %ecx,%edx
    4bcc:	48 89 50 10          	mov    %rdx,0x10(%rax)
			elf_file->program_headers[i].p_paddr = reader->get_uint32(reader);
    4bd0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4bd4:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4bd8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4bdc:	48 89 c7             	mov    %rax,%rdi
    4bdf:	ff d2                	call   *%rdx
    4be1:	89 c1                	mov    %eax,%ecx
    4be3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4be7:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4beb:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4bee:	48 63 d0             	movslq %eax,%rdx
    4bf1:	48 89 d0             	mov    %rdx,%rax
    4bf4:	48 c1 e0 03          	shl    $0x3,%rax
    4bf8:	48 29 d0             	sub    %rdx,%rax
    4bfb:	48 c1 e0 03          	shl    $0x3,%rax
    4bff:	48 01 f0             	add    %rsi,%rax
    4c02:	89 ca                	mov    %ecx,%edx
    4c04:	48 89 50 18          	mov    %rdx,0x18(%rax)
			elf_file->program_headers[i].p_filesz = reader->get_uint32(reader);
    4c08:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4c0c:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4c10:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4c14:	48 89 c7             	mov    %rax,%rdi
    4c17:	ff d2                	call   *%rdx
    4c19:	89 c1                	mov    %eax,%ecx
    4c1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4c1f:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4c23:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4c26:	48 63 d0             	movslq %eax,%rdx
    4c29:	48 89 d0             	mov    %rdx,%rax
    4c2c:	48 c1 e0 03          	shl    $0x3,%rax
    4c30:	48 29 d0             	sub    %rdx,%rax
    4c33:	48 c1 e0 03          	shl    $0x3,%rax
    4c37:	48 01 f0             	add    %rsi,%rax
    4c3a:	89 ca                	mov    %ecx,%edx
    4c3c:	48 89 50 20          	mov    %rdx,0x20(%rax)
			elf_file->program_headers[i].p_memsz = reader->get_uint32(reader);
    4c40:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4c44:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4c48:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4c4c:	48 89 c7             	mov    %rax,%rdi
    4c4f:	ff d2                	call   *%rdx
    4c51:	89 c1                	mov    %eax,%ecx
    4c53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4c57:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4c5b:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4c5e:	48 63 d0             	movslq %eax,%rdx
    4c61:	48 89 d0             	mov    %rdx,%rax
    4c64:	48 c1 e0 03          	shl    $0x3,%rax
    4c68:	48 29 d0             	sub    %rdx,%rax
    4c6b:	48 c1 e0 03          	shl    $0x3,%rax
    4c6f:	48 01 f0             	add    %rsi,%rax
    4c72:	89 ca                	mov    %ecx,%edx
    4c74:	48 89 50 28          	mov    %rdx,0x28(%rax)
			elf_file->program_headers[i].p_flags = reader->get_uint32(reader);
    4c78:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4c7c:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4c80:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4c84:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4c88:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4c8b:	48 63 c8             	movslq %eax,%rcx
    4c8e:	48 89 c8             	mov    %rcx,%rax
    4c91:	48 c1 e0 03          	shl    $0x3,%rax
    4c95:	48 29 c8             	sub    %rcx,%rax
    4c98:	48 c1 e0 03          	shl    $0x3,%rax
    4c9c:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4ca0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4ca4:	48 89 c7             	mov    %rax,%rdi
    4ca7:	ff d2                	call   *%rdx
    4ca9:	89 43 04             	mov    %eax,0x4(%rbx)
			elf_file->program_headers[i].p_align = reader->get_uint32(reader);
    4cac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4cb0:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4cb4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4cb8:	48 89 c7             	mov    %rax,%rdi
    4cbb:	ff d2                	call   *%rdx
    4cbd:	89 c1                	mov    %eax,%ecx
    4cbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4cc3:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4cc7:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4cca:	48 63 d0             	movslq %eax,%rdx
    4ccd:	48 89 d0             	mov    %rdx,%rax
    4cd0:	48 c1 e0 03          	shl    $0x3,%rax
    4cd4:	48 29 d0             	sub    %rdx,%rax
    4cd7:	48 c1 e0 03          	shl    $0x3,%rax
    4cdb:	48 01 f0             	add    %rsi,%rax
    4cde:	89 ca                	mov    %ecx,%edx
    4ce0:	48 89 50 30          	mov    %rdx,0x30(%rax)
    4ce4:	e9 72 01 00 00       	jmp    4e5b <get_elf_program_headers+0x3bf>
		}
		else
		{
			elf_file->program_headers[i].p_flags = reader->get_uint32(reader);
    4ce9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4ced:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4cf1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4cf5:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4cf9:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4cfc:	48 63 c8             	movslq %eax,%rcx
    4cff:	48 89 c8             	mov    %rcx,%rax
    4d02:	48 c1 e0 03          	shl    $0x3,%rax
    4d06:	48 29 c8             	sub    %rcx,%rax
    4d09:	48 c1 e0 03          	shl    $0x3,%rax
    4d0d:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4d11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4d15:	48 89 c7             	mov    %rax,%rdi
    4d18:	ff d2                	call   *%rdx
    4d1a:	89 43 04             	mov    %eax,0x4(%rbx)
			elf_file->program_headers[i].p_offset = reader->get_uint64(reader);
    4d1d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4d21:	48 8b 50 40          	mov    0x40(%rax),%rdx
    4d25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4d29:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4d2d:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4d30:	48 63 c8             	movslq %eax,%rcx
    4d33:	48 89 c8             	mov    %rcx,%rax
    4d36:	48 c1 e0 03          	shl    $0x3,%rax
    4d3a:	48 29 c8             	sub    %rcx,%rax
    4d3d:	48 c1 e0 03          	shl    $0x3,%rax
    4d41:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4d45:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4d49:	48 89 c7             	mov    %rax,%rdi
    4d4c:	ff d2                	call   *%rdx
    4d4e:	48 89 43 08          	mov    %rax,0x8(%rbx)
			elf_file->program_headers[i].p_vaddr = reader->get_uint64(reader);
    4d52:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4d56:	48 8b 50 40          	mov    0x40(%rax),%rdx
    4d5a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4d5e:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4d62:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4d65:	48 63 c8             	movslq %eax,%rcx
    4d68:	48 89 c8             	mov    %rcx,%rax
    4d6b:	48 c1 e0 03          	shl    $0x3,%rax
    4d6f:	48 29 c8             	sub    %rcx,%rax
    4d72:	48 c1 e0 03          	shl    $0x3,%rax
    4d76:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4d7a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4d7e:	48 89 c7             	mov    %rax,%rdi
    4d81:	ff d2                	call   *%rdx
    4d83:	48 89 43 10          	mov    %rax,0x10(%rbx)
			elf_file->program_headers[i].p_paddr = reader->get_uint64(reader);
    4d87:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4d8b:	48 8b 50 40          	mov    0x40(%rax),%rdx
    4d8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4d93:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4d97:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4d9a:	48 63 c8             	movslq %eax,%rcx
    4d9d:	48 89 c8             	mov    %rcx,%rax
    4da0:	48 c1 e0 03          	shl    $0x3,%rax
    4da4:	48 29 c8             	sub    %rcx,%rax
    4da7:	48 c1 e0 03          	shl    $0x3,%rax
    4dab:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4daf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4db3:	48 89 c7             	mov    %rax,%rdi
    4db6:	ff d2                	call   *%rdx
    4db8:	48 89 43 18          	mov    %rax,0x18(%rbx)
			elf_file->program_headers[i].p_filesz = reader->get_uint64(reader);
    4dbc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4dc0:	48 8b 50 40          	mov    0x40(%rax),%rdx
    4dc4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4dc8:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4dcc:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4dcf:	48 63 c8             	movslq %eax,%rcx
    4dd2:	48 89 c8             	mov    %rcx,%rax
    4dd5:	48 c1 e0 03          	shl    $0x3,%rax
    4dd9:	48 29 c8             	sub    %rcx,%rax
    4ddc:	48 c1 e0 03          	shl    $0x3,%rax
    4de0:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4de4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4de8:	48 89 c7             	mov    %rax,%rdi
    4deb:	ff d2                	call   *%rdx
    4ded:	48 89 43 20          	mov    %rax,0x20(%rbx)
			elf_file->program_headers[i].p_memsz = reader->get_uint64(reader);
    4df1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4df5:	48 8b 50 40          	mov    0x40(%rax),%rdx
    4df9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4dfd:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4e01:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4e04:	48 63 c8             	movslq %eax,%rcx
    4e07:	48 89 c8             	mov    %rcx,%rax
    4e0a:	48 c1 e0 03          	shl    $0x3,%rax
    4e0e:	48 29 c8             	sub    %rcx,%rax
    4e11:	48 c1 e0 03          	shl    $0x3,%rax
    4e15:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4e19:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4e1d:	48 89 c7             	mov    %rax,%rdi
    4e20:	ff d2                	call   *%rdx
    4e22:	48 89 43 28          	mov    %rax,0x28(%rbx)
			elf_file->program_headers[i].p_align = reader->get_uint64(reader);
    4e26:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4e2a:	48 8b 50 40          	mov    0x40(%rax),%rdx
    4e2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4e32:	48 8b 70 68          	mov    0x68(%rax),%rsi
    4e36:	8b 45 ec             	mov    -0x14(%rbp),%eax
    4e39:	48 63 c8             	movslq %eax,%rcx
    4e3c:	48 89 c8             	mov    %rcx,%rax
    4e3f:	48 c1 e0 03          	shl    $0x3,%rax
    4e43:	48 29 c8             	sub    %rcx,%rax
    4e46:	48 c1 e0 03          	shl    $0x3,%rax
    4e4a:	48 8d 1c 06          	lea    (%rsi,%rax,1),%rbx
    4e4e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4e52:	48 89 c7             	mov    %rax,%rdi
    4e55:	ff d2                	call   *%rdx
    4e57:	48 89 43 30          	mov    %rax,0x30(%rbx)
	for (int i = 0; i < elf_file->e_phnum; i++)
    4e5b:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
    4e5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4e63:	0f b7 40 52          	movzwl 0x52(%rax),%eax
    4e67:	0f b7 c0             	movzwl %ax,%eax
    4e6a:	39 45 ec             	cmp    %eax,-0x14(%rbp)
    4e6d:	0f 8c aa fc ff ff    	jl     4b1d <get_elf_program_headers+0x81>
		}
	}
	return (0);
    4e73:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4e78:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    4e7c:	c9                   	leave  
    4e7d:	c3                   	ret    

0000000000004e7e <new_elf_file>:

t_elf_file	*new_elf_file(t_binary_reader *reader)
{
    4e7e:	f3 0f 1e fa          	endbr64 
    4e82:	55                   	push   %rbp
    4e83:	48 89 e5             	mov    %rsp,%rbp
    4e86:	48 83 ec 20          	sub    $0x20,%rsp
    4e8a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	t_elf_file *elf_file = ft_calloc(1, sizeof(t_elf_file));
    4e8e:	be 70 00 00 00       	mov    $0x70,%esi
    4e93:	bf 01 00 00 00       	mov    $0x1,%edi
    4e98:	e8 71 e1 ff ff       	call   300e <ft_calloc>
    4e9d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (elf_file == NULL)
    4ea1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    4ea6:	75 16                	jne    4ebe <new_elf_file+0x40>
		return (ft_error(WD_PREFIX"Could not allocate memory.\n"), NULL);
    4ea8:	48 8d 3d 99 33 00 00 	lea    0x3399(%rip),%rdi        # 8248 <rcon+0x208>
    4eaf:	e8 ec e1 ff ff       	call   30a0 <ft_error>
    4eb4:	b8 00 00 00 00       	mov    $0x0,%eax
    4eb9:	e9 08 03 00 00       	jmp    51c6 <new_elf_file+0x348>

	/**
	 * By default we set en endianness to little endian because it's the endianness of the header
	 */
	reader->set_endian(reader, READER_LITTLE_ENDIAN);
    4ebe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4ec2:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
    4ec9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4ecd:	be 01 00 00 00       	mov    $0x1,%esi
    4ed2:	48 89 c7             	mov    %rax,%rdi
    4ed5:	ff d2                	call   *%rdx
	reader->get_bytes(reader, elf_file->e_ident.raw, 16);
    4ed7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4edb:	4c 8b 80 90 00 00 00 	mov    0x90(%rax),%r8
    4ee2:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    4ee6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4eea:	ba 10 00 00 00       	mov    $0x10,%edx
    4eef:	48 89 ce             	mov    %rcx,%rsi
    4ef2:	48 89 c7             	mov    %rax,%rdi
    4ef5:	41 ff d0             	call   *%r8

	if (elf_file->e_ident.ei_magic != 0x464C457F) // 0x7F 'E' 'L' 'F' but reversed because of endianness
    4ef8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4efc:	8b 00                	mov    (%rax),%eax
    4efe:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
    4f03:	74 22                	je     4f27 <new_elf_file+0xa9>
	{
		delete_elf_file(elf_file);
    4f05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4f09:	48 89 c7             	mov    %rax,%rdi
    4f0c:	e8 b7 02 00 00       	call   51c8 <delete_elf_file>
		return (ft_error(WD_PREFIX"Invalid file format.\n"), NULL);
    4f11:	48 8d 3d 53 33 00 00 	lea    0x3353(%rip),%rdi        # 826b <rcon+0x22b>
    4f18:	e8 83 e1 ff ff       	call   30a0 <ft_error>
    4f1d:	b8 00 00 00 00       	mov    $0x0,%eax
    4f22:	e9 9f 02 00 00       	jmp    51c6 <new_elf_file+0x348>
	}

	if (elf_file->e_ident.ei_data == 2)
    4f27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4f2b:	0f b6 40 05          	movzbl 0x5(%rax),%eax
    4f2f:	3c 02                	cmp    $0x2,%al
    4f31:	75 19                	jne    4f4c <new_elf_file+0xce>
	{
		reader->set_endian(reader, READER_BIG_ENDIAN);
    4f33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4f37:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
    4f3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4f42:	be 00 00 00 00       	mov    $0x0,%esi
    4f47:	48 89 c7             	mov    %rax,%rdi
    4f4a:	ff d2                	call   *%rdx
	}

	/**
	 * We check that the e_ident version is 1, if not the file is not valid
	 */
	if (elf_file->e_ident.ei_version != 1)
    4f4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4f50:	0f b6 40 06          	movzbl 0x6(%rax),%eax
    4f54:	3c 01                	cmp    $0x1,%al
    4f56:	74 22                	je     4f7a <new_elf_file+0xfc>
	{
		delete_elf_file(elf_file);
    4f58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4f5c:	48 89 c7             	mov    %rax,%rdi
    4f5f:	e8 64 02 00 00       	call   51c8 <delete_elf_file>
		return (ft_error(WD_PREFIX"Wrong version.\n"), NULL);
    4f64:	48 8d 3d 1d 33 00 00 	lea    0x331d(%rip),%rdi        # 8288 <rcon+0x248>
    4f6b:	e8 30 e1 ff ff       	call   30a0 <ft_error>
    4f70:	b8 00 00 00 00       	mov    $0x0,%eax
    4f75:	e9 4c 02 00 00       	jmp    51c6 <new_elf_file+0x348>
	}

	/**
	 * We ensure that the format of the binary matches the current system
	 */
	if (elf_file->e_ident.ei_osabi != 0x00 && elf_file->e_ident.ei_osabi != 0x03)
    4f7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4f7e:	0f b6 40 07          	movzbl 0x7(%rax),%eax
    4f82:	84 c0                	test   %al,%al
    4f84:	74 2e                	je     4fb4 <new_elf_file+0x136>
    4f86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4f8a:	0f b6 40 07          	movzbl 0x7(%rax),%eax
    4f8e:	3c 03                	cmp    $0x3,%al
    4f90:	74 22                	je     4fb4 <new_elf_file+0x136>
	{
		delete_elf_file(elf_file);
    4f92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4f96:	48 89 c7             	mov    %rax,%rdi
    4f99:	e8 2a 02 00 00       	call   51c8 <delete_elf_file>
		return (ft_error(WD_PREFIX"Incompatible ABI.\n"), NULL);
    4f9e:	48 8d 3d fa 32 00 00 	lea    0x32fa(%rip),%rdi        # 829f <rcon+0x25f>
    4fa5:	e8 f6 e0 ff ff       	call   30a0 <ft_error>
    4faa:	b8 00 00 00 00       	mov    $0x0,%eax
    4faf:	e9 12 02 00 00       	jmp    51c6 <new_elf_file+0x348>
	}

	get_type_name(reader, elf_file);
    4fb4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    4fb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4fbc:	48 89 d6             	mov    %rdx,%rsi
    4fbf:	48 89 c7             	mov    %rax,%rdi
    4fc2:	e8 1c f5 ff ff       	call   44e3 <get_type_name>
	elf_file->e_machine = reader->get_uint16(reader);
    4fc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4fcb:	48 8b 50 30          	mov    0x30(%rax),%rdx
    4fcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4fd3:	48 89 c7             	mov    %rax,%rdi
    4fd6:	ff d2                	call   *%rdx
    4fd8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    4fdc:	66 89 42 20          	mov    %ax,0x20(%rdx)
	elf_file->e_version = reader->get_uint32(reader);
    4fe0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4fe4:	48 8b 50 38          	mov    0x38(%rax),%rdx
    4fe8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4fec:	48 89 c7             	mov    %rax,%rdi
    4fef:	ff d2                	call   *%rdx
    4ff1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    4ff5:	89 42 24             	mov    %eax,0x24(%rdx)

	if (elf_file->e_ident.ei_class == WD_32BITS)
    4ff8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4ffc:	0f b6 40 04          	movzbl 0x4(%rax),%eax
    5000:	3c 01                	cmp    $0x1,%al
    5002:	75 60                	jne    5064 <new_elf_file+0x1e6>
	{
		elf_file->e_entry += reader->get_uint32(reader);
    5004:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5008:	48 8b 50 38          	mov    0x38(%rax),%rdx
    500c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5010:	48 89 c7             	mov    %rax,%rdi
    5013:	ff d2                	call   *%rdx
    5015:	89 c2                	mov    %eax,%edx
    5017:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    501b:	48 8b 40 28          	mov    0x28(%rax),%rax
    501f:	89 d2                	mov    %edx,%edx
    5021:	48 01 c2             	add    %rax,%rdx
    5024:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    5028:	48 89 50 28          	mov    %rdx,0x28(%rax)
		elf_file->e_phoff = reader->get_uint32(reader);
    502c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5030:	48 8b 50 38          	mov    0x38(%rax),%rdx
    5034:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5038:	48 89 c7             	mov    %rax,%rdi
    503b:	ff d2                	call   *%rdx
    503d:	89 c2                	mov    %eax,%edx
    503f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    5043:	48 89 50 30          	mov    %rdx,0x30(%rax)
		elf_file->e_shoff = reader->get_uint32(reader);
    5047:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    504b:	48 8b 50 38          	mov    0x38(%rax),%rdx
    504f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5053:	48 89 c7             	mov    %rax,%rdi
    5056:	ff d2                	call   *%rdx
    5058:	89 c2                	mov    %eax,%edx
    505a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    505e:	48 89 50 38          	mov    %rdx,0x38(%rax)
    5062:	eb 59                	jmp    50bd <new_elf_file+0x23f>
	}
	else
	{
		elf_file->e_entry += reader->get_uint64(reader);
    5064:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5068:	48 8b 50 40          	mov    0x40(%rax),%rdx
    506c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5070:	48 89 c7             	mov    %rax,%rdi
    5073:	ff d2                	call   *%rdx
    5075:	48 89 c2             	mov    %rax,%rdx
    5078:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    507c:	48 8b 40 28          	mov    0x28(%rax),%rax
    5080:	48 01 c2             	add    %rax,%rdx
    5083:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    5087:	48 89 50 28          	mov    %rdx,0x28(%rax)
		elf_file->e_phoff = reader->get_uint64(reader);
    508b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    508f:	48 8b 50 40          	mov    0x40(%rax),%rdx
    5093:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5097:	48 89 c7             	mov    %rax,%rdi
    509a:	ff d2                	call   *%rdx
    509c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    50a0:	48 89 42 30          	mov    %rax,0x30(%rdx)
		elf_file->e_shoff = reader->get_uint64(reader);
    50a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    50a8:	48 8b 50 40          	mov    0x40(%rax),%rdx
    50ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    50b0:	48 89 c7             	mov    %rax,%rdi
    50b3:	ff d2                	call   *%rdx
    50b5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    50b9:	48 89 42 38          	mov    %rax,0x38(%rdx)
	}
	elf_file->e_flags = reader->get_uint32(reader);
    50bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    50c1:	48 8b 50 38          	mov    0x38(%rax),%rdx
    50c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    50c9:	48 89 c7             	mov    %rax,%rdi
    50cc:	ff d2                	call   *%rdx
    50ce:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    50d2:	89 42 40             	mov    %eax,0x40(%rdx)
	elf_file->e_ehsize = reader->get_uint16(reader);
    50d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    50d9:	48 8b 50 30          	mov    0x30(%rax),%rdx
    50dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    50e1:	48 89 c7             	mov    %rax,%rdi
    50e4:	ff d2                	call   *%rdx
    50e6:	0f b7 d0             	movzwl %ax,%edx
    50e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    50ed:	48 89 50 48          	mov    %rdx,0x48(%rax)
	elf_file->e_phentsize = reader->get_uint16(reader);
    50f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    50f5:	48 8b 50 30          	mov    0x30(%rax),%rdx
    50f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    50fd:	48 89 c7             	mov    %rax,%rdi
    5100:	ff d2                	call   *%rdx
    5102:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    5106:	66 89 42 50          	mov    %ax,0x50(%rdx)
	elf_file->e_phnum = reader->get_uint16(reader);
    510a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    510e:	48 8b 50 30          	mov    0x30(%rax),%rdx
    5112:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5116:	48 89 c7             	mov    %rax,%rdi
    5119:	ff d2                	call   *%rdx
    511b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    511f:	66 89 42 52          	mov    %ax,0x52(%rdx)
	elf_file->e_shentsize = reader->get_uint16(reader);
    5123:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5127:	48 8b 50 30          	mov    0x30(%rax),%rdx
    512b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    512f:	48 89 c7             	mov    %rax,%rdi
    5132:	ff d2                	call   *%rdx
    5134:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    5138:	66 89 42 54          	mov    %ax,0x54(%rdx)
	elf_file->e_shnum = reader->get_uint16(reader);
    513c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5140:	48 8b 50 30          	mov    0x30(%rax),%rdx
    5144:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5148:	48 89 c7             	mov    %rax,%rdi
    514b:	ff d2                	call   *%rdx
    514d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    5151:	66 89 42 56          	mov    %ax,0x56(%rdx)
	elf_file->e_shstrndx = reader->get_uint16(reader);
    5155:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5159:	48 8b 50 30          	mov    0x30(%rax),%rdx
    515d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5161:	48 89 c7             	mov    %rax,%rdi
    5164:	ff d2                	call   *%rdx
    5166:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    516a:	66 89 42 58          	mov    %ax,0x58(%rdx)

	if (get_elf_tables_offset(elf_file, reader))
    516e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    5172:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    5176:	48 89 d6             	mov    %rdx,%rsi
    5179:	48 89 c7             	mov    %rax,%rdi
    517c:	e8 e9 f4 ff ff       	call   466a <get_elf_tables_offset>
    5181:	85 c0                	test   %eax,%eax
    5183:	74 13                	je     5198 <new_elf_file+0x31a>
	{
		delete_elf_file(elf_file);
    5185:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    5189:	48 89 c7             	mov    %rax,%rdi
    518c:	e8 37 00 00 00       	call   51c8 <delete_elf_file>
		return (NULL);
    5191:	b8 00 00 00 00       	mov    $0x0,%eax
    5196:	eb 2e                	jmp    51c6 <new_elf_file+0x348>
	}

	if (get_elf_program_headers(elf_file, reader))
    5198:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    519c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    51a0:	48 89 d6             	mov    %rdx,%rsi
    51a3:	48 89 c7             	mov    %rax,%rdi
    51a6:	e8 f1 f8 ff ff       	call   4a9c <get_elf_program_headers>
    51ab:	85 c0                	test   %eax,%eax
    51ad:	74 13                	je     51c2 <new_elf_file+0x344>
	{
		delete_elf_file(elf_file);
    51af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    51b3:	48 89 c7             	mov    %rax,%rdi
    51b6:	e8 0d 00 00 00       	call   51c8 <delete_elf_file>
		return (NULL);
    51bb:	b8 00 00 00 00       	mov    $0x0,%eax
    51c0:	eb 04                	jmp    51c6 <new_elf_file+0x348>
	}

	return (elf_file);
    51c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    51c6:	c9                   	leave  
    51c7:	c3                   	ret    

00000000000051c8 <delete_elf_file>:

void	delete_elf_file(t_elf_file *elf_file)
{
    51c8:	f3 0f 1e fa          	endbr64 
    51cc:	55                   	push   %rbp
    51cd:	48 89 e5             	mov    %rsp,%rbp
    51d0:	48 83 ec 20          	sub    $0x20,%rsp
    51d4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	if (elf_file == NULL)
    51d8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
    51dd:	0f 84 8f 00 00 00    	je     5272 <delete_elf_file+0xaa>
		return ;

	if (elf_file->program_headers)
    51e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    51e7:	48 8b 40 68          	mov    0x68(%rax),%rax
    51eb:	48 85 c0             	test   %rax,%rax
    51ee:	74 10                	je     5200 <delete_elf_file+0x38>
		free(elf_file->program_headers);
    51f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    51f4:	48 8b 40 68          	mov    0x68(%rax),%rax
    51f8:	48 89 c7             	mov    %rax,%rdi
    51fb:	e8 30 ce ff ff       	call   2030 <free@plt>

	if (elf_file->section_tables)
    5200:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5204:	48 8b 40 60          	mov    0x60(%rax),%rax
    5208:	48 85 c0             	test   %rax,%rax
    520b:	74 57                	je     5264 <delete_elf_file+0x9c>
	{
		for (int i = 0; i < elf_file->e_shnum; i++)
    520d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    5214:	eb 2e                	jmp    5244 <delete_elf_file+0x7c>
		{
			free(elf_file->section_tables[i].sh_name);
    5216:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    521a:	48 8b 48 60          	mov    0x60(%rax),%rcx
    521e:	8b 45 fc             	mov    -0x4(%rbp),%eax
    5221:	48 63 d0             	movslq %eax,%rdx
    5224:	48 89 d0             	mov    %rdx,%rax
    5227:	48 01 c0             	add    %rax,%rax
    522a:	48 01 d0             	add    %rdx,%rax
    522d:	48 c1 e0 04          	shl    $0x4,%rax
    5231:	48 01 c8             	add    %rcx,%rax
    5234:	48 8b 40 28          	mov    0x28(%rax),%rax
    5238:	48 89 c7             	mov    %rax,%rdi
    523b:	e8 f0 cd ff ff       	call   2030 <free@plt>
		for (int i = 0; i < elf_file->e_shnum; i++)
    5240:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    5244:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5248:	0f b7 40 56          	movzwl 0x56(%rax),%eax
    524c:	0f b7 c0             	movzwl %ax,%eax
    524f:	39 45 fc             	cmp    %eax,-0x4(%rbp)
    5252:	7c c2                	jl     5216 <delete_elf_file+0x4e>
		}
		free(elf_file->section_tables);
    5254:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5258:	48 8b 40 60          	mov    0x60(%rax),%rax
    525c:	48 89 c7             	mov    %rax,%rdi
    525f:	e8 cc cd ff ff       	call   2030 <free@plt>
	}
	free(elf_file);
    5264:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    5268:	48 89 c7             	mov    %rax,%rdi
    526b:	e8 c0 cd ff ff       	call   2030 <free@plt>
    5270:	eb 01                	jmp    5273 <delete_elf_file+0xab>
		return ;
    5272:	90                   	nop
}
    5273:	c9                   	leave  
    5274:	c3                   	ret    

0000000000005275 <print_elf_program_flag>:

static void	print_elf_program_flag(uint32_t flag)
{
    5275:	f3 0f 1e fa          	endbr64 
    5279:	55                   	push   %rbp
    527a:	48 89 e5             	mov    %rsp,%rbp
    527d:	48 83 ec 20          	sub    $0x20,%rsp
    5281:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int res = 0;
    5284:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if (flag & 0x01)
    528b:	8b 45 ec             	mov    -0x14(%rbp),%eax
    528e:	83 e0 01             	and    $0x1,%eax
    5291:	85 c0                	test   %eax,%eax
    5293:	74 14                	je     52a9 <print_elf_program_flag+0x34>
		res += printf("X");
    5295:	48 8d 3d 1d 30 00 00 	lea    0x301d(%rip),%rdi        # 82b9 <rcon+0x279>
    529c:	b8 00 00 00 00       	mov    $0x0,%eax
    52a1:	e8 fa cd ff ff       	call   20a0 <printf@plt>
    52a6:	01 45 fc             	add    %eax,-0x4(%rbp)
	if (flag & 0x02)
    52a9:	8b 45 ec             	mov    -0x14(%rbp),%eax
    52ac:	83 e0 02             	and    $0x2,%eax
    52af:	85 c0                	test   %eax,%eax
    52b1:	74 14                	je     52c7 <print_elf_program_flag+0x52>
		res += printf("W");
    52b3:	48 8d 3d 01 30 00 00 	lea    0x3001(%rip),%rdi        # 82bb <rcon+0x27b>
    52ba:	b8 00 00 00 00       	mov    $0x0,%eax
    52bf:	e8 dc cd ff ff       	call   20a0 <printf@plt>
    52c4:	01 45 fc             	add    %eax,-0x4(%rbp)
	if (flag & 0x04)
    52c7:	8b 45 ec             	mov    -0x14(%rbp),%eax
    52ca:	83 e0 04             	and    $0x4,%eax
    52cd:	85 c0                	test   %eax,%eax
    52cf:	74 14                	je     52e5 <print_elf_program_flag+0x70>
		res += printf("R");
    52d1:	48 8d 3d e5 2f 00 00 	lea    0x2fe5(%rip),%rdi        # 82bd <rcon+0x27d>
    52d8:	b8 00 00 00 00       	mov    $0x0,%eax
    52dd:	e8 be cd ff ff       	call   20a0 <printf@plt>
    52e2:	01 45 fc             	add    %eax,-0x4(%rbp)
	printf("%*s%s", 3 - res, "", "    ");
    52e5:	b8 03 00 00 00       	mov    $0x3,%eax
    52ea:	2b 45 fc             	sub    -0x4(%rbp),%eax
    52ed:	48 8d 0d cb 2f 00 00 	lea    0x2fcb(%rip),%rcx        # 82bf <rcon+0x27f>
    52f4:	48 8d 15 c9 2f 00 00 	lea    0x2fc9(%rip),%rdx        # 82c4 <rcon+0x284>
    52fb:	89 c6                	mov    %eax,%esi
    52fd:	48 8d 3d c1 2f 00 00 	lea    0x2fc1(%rip),%rdi        # 82c5 <rcon+0x285>
    5304:	b8 00 00 00 00       	mov    $0x0,%eax
    5309:	e8 92 cd ff ff       	call   20a0 <printf@plt>
}
    530e:	90                   	nop
    530f:	c9                   	leave  
    5310:	c3                   	ret    

0000000000005311 <print_elf_file>:

void	print_elf_file(t_elf_file *elf_file)
{
    5311:	f3 0f 1e fa          	endbr64 
    5315:	55                   	push   %rbp
    5316:	48 89 e5             	mov    %rsp,%rbp
    5319:	48 83 ec 30          	sub    $0x30,%rsp
    531d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	printf("ELF Header:\n");
    5321:	48 8d 3d a3 2f 00 00 	lea    0x2fa3(%rip),%rdi        # 82cb <rcon+0x28b>
    5328:	e8 23 cd ff ff       	call   2050 <puts@plt>
	printf("  Magic:   ");
    532d:	48 8d 3d a3 2f 00 00 	lea    0x2fa3(%rip),%rdi        # 82d7 <rcon+0x297>
    5334:	b8 00 00 00 00       	mov    $0x0,%eax
    5339:	e8 62 cd ff ff       	call   20a0 <printf@plt>
	for (int i = 0; i < 16; i++)
    533e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    5345:	eb 27                	jmp    536e <print_elf_file+0x5d>
		printf("%02X ", elf_file->e_ident.raw[i]);
    5347:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    534b:	8b 45 ec             	mov    -0x14(%rbp),%eax
    534e:	48 98                	cltq   
    5350:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
    5354:	0f be c0             	movsbl %al,%eax
    5357:	89 c6                	mov    %eax,%esi
    5359:	48 8d 3d 83 2f 00 00 	lea    0x2f83(%rip),%rdi        # 82e3 <rcon+0x2a3>
    5360:	b8 00 00 00 00       	mov    $0x0,%eax
    5365:	e8 36 cd ff ff       	call   20a0 <printf@plt>
	for (int i = 0; i < 16; i++)
    536a:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
    536e:	83 7d ec 0f          	cmpl   $0xf,-0x14(%rbp)
    5372:	7e d3                	jle    5347 <print_elf_file+0x36>
	printf("\n");
    5374:	bf 0a 00 00 00       	mov    $0xa,%edi
    5379:	e8 c2 cc ff ff       	call   2040 <putchar@plt>
	printf("  Class:                             ELF%d\n", elf_file->e_ident.ei_class * 32);
    537e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5382:	0f b6 40 04          	movzbl 0x4(%rax),%eax
    5386:	0f b6 c0             	movzbl %al,%eax
    5389:	c1 e0 05             	shl    $0x5,%eax
    538c:	89 c6                	mov    %eax,%esi
    538e:	48 8d 3d 5b 2f 00 00 	lea    0x2f5b(%rip),%rdi        # 82f0 <rcon+0x2b0>
    5395:	b8 00 00 00 00       	mov    $0x0,%eax
    539a:	e8 01 cd ff ff       	call   20a0 <printf@plt>
	printf("  Data:                              2's complement, %s\n", elf_file->e_ident.ei_data - 1 ? "big endian" : "little endian");
    539f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    53a3:	0f b6 40 05          	movzbl 0x5(%rax),%eax
    53a7:	3c 01                	cmp    $0x1,%al
    53a9:	74 09                	je     53b4 <print_elf_file+0xa3>
    53ab:	48 8d 05 6a 2f 00 00 	lea    0x2f6a(%rip),%rax        # 831c <rcon+0x2dc>
    53b2:	eb 07                	jmp    53bb <print_elf_file+0xaa>
    53b4:	48 8d 05 6c 2f 00 00 	lea    0x2f6c(%rip),%rax        # 8327 <rcon+0x2e7>
    53bb:	48 89 c6             	mov    %rax,%rsi
    53be:	48 8d 3d 73 2f 00 00 	lea    0x2f73(%rip),%rdi        # 8338 <rcon+0x2f8>
    53c5:	b8 00 00 00 00       	mov    $0x0,%eax
    53ca:	e8 d1 cc ff ff       	call   20a0 <printf@plt>
	printf("  Version:                           %u (current)\n", elf_file->e_ident.ei_version);
    53cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    53d3:	0f b6 40 06          	movzbl 0x6(%rax),%eax
    53d7:	0f b6 c0             	movzbl %al,%eax
    53da:	89 c6                	mov    %eax,%esi
    53dc:	48 8d 3d 95 2f 00 00 	lea    0x2f95(%rip),%rdi        # 8378 <rcon+0x338>
    53e3:	b8 00 00 00 00       	mov    $0x0,%eax
    53e8:	e8 b3 cc ff ff       	call   20a0 <printf@plt>
	printf("  OS/ABI:                            %s\n", g_elf_osabi_name[elf_file->e_ident.ei_osabi]);
    53ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    53f1:	0f b6 40 07          	movzbl 0x7(%rax),%eax
    53f5:	0f b6 c0             	movzbl %al,%eax
    53f8:	48 98                	cltq   
    53fa:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    5401:	00 
    5402:	48 8d 05 b7 6e 00 00 	lea    0x6eb7(%rip),%rax        # c2c0 <g_elf_osabi_name>
    5409:	48 8b 04 02          	mov    (%rdx,%rax,1),%rax
    540d:	48 89 c6             	mov    %rax,%rsi
    5410:	48 8d 3d 99 2f 00 00 	lea    0x2f99(%rip),%rdi        # 83b0 <rcon+0x370>
    5417:	b8 00 00 00 00       	mov    $0x0,%eax
    541c:	e8 7f cc ff ff       	call   20a0 <printf@plt>
	printf("  ABI Version:                       %u\n", elf_file->e_ident.ei_abi_version);
    5421:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5425:	0f b6 40 08          	movzbl 0x8(%rax),%eax
    5429:	0f b6 c0             	movzbl %al,%eax
    542c:	89 c6                	mov    %eax,%esi
    542e:	48 8d 3d ab 2f 00 00 	lea    0x2fab(%rip),%rdi        # 83e0 <rcon+0x3a0>
    5435:	b8 00 00 00 00       	mov    $0x0,%eax
    543a:	e8 61 cc ff ff       	call   20a0 <printf@plt>
	printf("  Type:                              %s\n", elf_file->e_type_name);
    543f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5443:	48 8b 40 18          	mov    0x18(%rax),%rax
    5447:	48 89 c6             	mov    %rax,%rsi
    544a:	48 8d 3d bf 2f 00 00 	lea    0x2fbf(%rip),%rdi        # 8410 <rcon+0x3d0>
    5451:	b8 00 00 00 00       	mov    $0x0,%eax
    5456:	e8 45 cc ff ff       	call   20a0 <printf@plt>
	printf("  Version:                           %#x\n", elf_file->e_version);
    545b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    545f:	8b 40 24             	mov    0x24(%rax),%eax
    5462:	89 c6                	mov    %eax,%esi
    5464:	48 8d 3d d5 2f 00 00 	lea    0x2fd5(%rip),%rdi        # 8440 <rcon+0x400>
    546b:	b8 00 00 00 00       	mov    $0x0,%eax
    5470:	e8 2b cc ff ff       	call   20a0 <printf@plt>
	printf("  Entry point:                       %#lx\n", elf_file->e_entry);
    5475:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5479:	48 8b 40 28          	mov    0x28(%rax),%rax
    547d:	48 89 c6             	mov    %rax,%rsi
    5480:	48 8d 3d e9 2f 00 00 	lea    0x2fe9(%rip),%rdi        # 8470 <rcon+0x430>
    5487:	b8 00 00 00 00       	mov    $0x0,%eax
    548c:	e8 0f cc ff ff       	call   20a0 <printf@plt>
	printf("  Start of program headers:          %ld (bytes into file)\n", elf_file->e_phoff);
    5491:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5495:	48 8b 40 30          	mov    0x30(%rax),%rax
    5499:	48 89 c6             	mov    %rax,%rsi
    549c:	48 8d 3d fd 2f 00 00 	lea    0x2ffd(%rip),%rdi        # 84a0 <rcon+0x460>
    54a3:	b8 00 00 00 00       	mov    $0x0,%eax
    54a8:	e8 f3 cb ff ff       	call   20a0 <printf@plt>
	printf("  Start of section headers:          %ld (bytes into file)\n", elf_file->e_shoff);
    54ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    54b1:	48 8b 40 38          	mov    0x38(%rax),%rax
    54b5:	48 89 c6             	mov    %rax,%rsi
    54b8:	48 8d 3d 21 30 00 00 	lea    0x3021(%rip),%rdi        # 84e0 <rcon+0x4a0>
    54bf:	b8 00 00 00 00       	mov    $0x0,%eax
    54c4:	e8 d7 cb ff ff       	call   20a0 <printf@plt>
	printf("  Size of this header:               %ld (bytes)\n", elf_file->e_ehsize);
    54c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    54cd:	48 8b 40 48          	mov    0x48(%rax),%rax
    54d1:	48 89 c6             	mov    %rax,%rsi
    54d4:	48 8d 3d 45 30 00 00 	lea    0x3045(%rip),%rdi        # 8520 <rcon+0x4e0>
    54db:	b8 00 00 00 00       	mov    $0x0,%eax
    54e0:	e8 bb cb ff ff       	call   20a0 <printf@plt>
	printf("  Size of program headers:           %d (bytes)\n", elf_file->e_phentsize);
    54e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    54e9:	0f b7 40 50          	movzwl 0x50(%rax),%eax
    54ed:	0f b7 c0             	movzwl %ax,%eax
    54f0:	89 c6                	mov    %eax,%esi
    54f2:	48 8d 3d 5f 30 00 00 	lea    0x305f(%rip),%rdi        # 8558 <rcon+0x518>
    54f9:	b8 00 00 00 00       	mov    $0x0,%eax
    54fe:	e8 9d cb ff ff       	call   20a0 <printf@plt>
	printf("  Number of program headers:         %d\n", elf_file->e_phnum);
    5503:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5507:	0f b7 40 52          	movzwl 0x52(%rax),%eax
    550b:	0f b7 c0             	movzwl %ax,%eax
    550e:	89 c6                	mov    %eax,%esi
    5510:	48 8d 3d 79 30 00 00 	lea    0x3079(%rip),%rdi        # 8590 <rcon+0x550>
    5517:	b8 00 00 00 00       	mov    $0x0,%eax
    551c:	e8 7f cb ff ff       	call   20a0 <printf@plt>
	printf("  Size of section headers:           %d (bytes)\n", elf_file->e_shentsize);
    5521:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5525:	0f b7 40 54          	movzwl 0x54(%rax),%eax
    5529:	0f b7 c0             	movzwl %ax,%eax
    552c:	89 c6                	mov    %eax,%esi
    552e:	48 8d 3d 8b 30 00 00 	lea    0x308b(%rip),%rdi        # 85c0 <rcon+0x580>
    5535:	b8 00 00 00 00       	mov    $0x0,%eax
    553a:	e8 61 cb ff ff       	call   20a0 <printf@plt>
	printf("  Number of section headers:         %d\n", elf_file->e_shnum);
    553f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5543:	0f b7 40 56          	movzwl 0x56(%rax),%eax
    5547:	0f b7 c0             	movzwl %ax,%eax
    554a:	89 c6                	mov    %eax,%esi
    554c:	48 8d 3d a5 30 00 00 	lea    0x30a5(%rip),%rdi        # 85f8 <rcon+0x5b8>
    5553:	b8 00 00 00 00       	mov    $0x0,%eax
    5558:	e8 43 cb ff ff       	call   20a0 <printf@plt>
	printf("  Section header string table index: %d\n", elf_file->e_shstrndx);
    555d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5561:	0f b7 40 58          	movzwl 0x58(%rax),%eax
    5565:	0f b7 c0             	movzwl %ax,%eax
    5568:	89 c6                	mov    %eax,%esi
    556a:	48 8d 3d b7 30 00 00 	lea    0x30b7(%rip),%rdi        # 8628 <rcon+0x5e8>
    5571:	b8 00 00 00 00       	mov    $0x0,%eax
    5576:	e8 25 cb ff ff       	call   20a0 <printf@plt>

	printf("\nSection Headers:\n");
    557b:	48 8d 3d cf 30 00 00 	lea    0x30cf(%rip),%rdi        # 8651 <rcon+0x611>
    5582:	e8 c9 ca ff ff       	call   2050 <puts@plt>
	printf("  [Nr] Name               Type               Address            Offset             Size\n");
    5587:	48 8d 3d da 30 00 00 	lea    0x30da(%rip),%rdi        # 8668 <rcon+0x628>
    558e:	e8 bd ca ff ff       	call   2050 <puts@plt>
	for (int i = 0; i < elf_file->e_shnum; i++)
    5593:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
    559a:	e9 98 01 00 00       	jmp    5737 <print_elf_file+0x426>
	{
		printf("  [%2d] ", i);
    559f:	8b 45 f0             	mov    -0x10(%rbp),%eax
    55a2:	89 c6                	mov    %eax,%esi
    55a4:	48 8d 3d 15 31 00 00 	lea    0x3115(%rip),%rdi        # 86c0 <rcon+0x680>
    55ab:	b8 00 00 00 00       	mov    $0x0,%eax
    55b0:	e8 eb ca ff ff       	call   20a0 <printf@plt>
		printf("%-18s ", elf_file->section_tables[i].sh_name);
    55b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    55b9:	48 8b 48 60          	mov    0x60(%rax),%rcx
    55bd:	8b 45 f0             	mov    -0x10(%rbp),%eax
    55c0:	48 63 d0             	movslq %eax,%rdx
    55c3:	48 89 d0             	mov    %rdx,%rax
    55c6:	48 01 c0             	add    %rax,%rax
    55c9:	48 01 d0             	add    %rdx,%rax
    55cc:	48 c1 e0 04          	shl    $0x4,%rax
    55d0:	48 01 c8             	add    %rcx,%rax
    55d3:	48 8b 40 28          	mov    0x28(%rax),%rax
    55d7:	48 89 c6             	mov    %rax,%rsi
    55da:	48 8d 3d e8 30 00 00 	lea    0x30e8(%rip),%rdi        # 86c9 <rcon+0x689>
    55e1:	b8 00 00 00 00       	mov    $0x0,%eax
    55e6:	e8 b5 ca ff ff       	call   20a0 <printf@plt>
		if (elf_file->section_tables[i].sh_type < 0x13)
    55eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    55ef:	48 8b 48 60          	mov    0x60(%rax),%rcx
    55f3:	8b 45 f0             	mov    -0x10(%rbp),%eax
    55f6:	48 63 d0             	movslq %eax,%rdx
    55f9:	48 89 d0             	mov    %rdx,%rax
    55fc:	48 01 c0             	add    %rax,%rax
    55ff:	48 01 d0             	add    %rdx,%rax
    5602:	48 c1 e0 04          	shl    $0x4,%rax
    5606:	48 01 c8             	add    %rcx,%rax
    5609:	8b 40 04             	mov    0x4(%rax),%eax
    560c:	83 f8 12             	cmp    $0x12,%eax
    560f:	77 4c                	ja     565d <print_elf_file+0x34c>
			printf("%-18s ", g_elf_section_table_type[elf_file->section_tables[i].sh_type]);
    5611:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5615:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5619:	8b 45 f0             	mov    -0x10(%rbp),%eax
    561c:	48 63 d0             	movslq %eax,%rdx
    561f:	48 89 d0             	mov    %rdx,%rax
    5622:	48 01 c0             	add    %rax,%rax
    5625:	48 01 d0             	add    %rdx,%rax
    5628:	48 c1 e0 04          	shl    $0x4,%rax
    562c:	48 01 c8             	add    %rcx,%rax
    562f:	8b 40 04             	mov    0x4(%rax),%eax
    5632:	89 c0                	mov    %eax,%eax
    5634:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    563b:	00 
    563c:	48 8d 05 dd 6b 00 00 	lea    0x6bdd(%rip),%rax        # c220 <g_elf_section_table_type>
    5643:	48 8b 04 02          	mov    (%rdx,%rax,1),%rax
    5647:	48 89 c6             	mov    %rax,%rsi
    564a:	48 8d 3d 78 30 00 00 	lea    0x3078(%rip),%rdi        # 86c9 <rcon+0x689>
    5651:	b8 00 00 00 00       	mov    $0x0,%eax
    5656:	e8 45 ca ff ff       	call   20a0 <printf@plt>
    565b:	eb 34                	jmp    5691 <print_elf_file+0x380>
		else
			printf("%#-18x ", elf_file->section_tables[i].sh_type);
    565d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5661:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5665:	8b 45 f0             	mov    -0x10(%rbp),%eax
    5668:	48 63 d0             	movslq %eax,%rdx
    566b:	48 89 d0             	mov    %rdx,%rax
    566e:	48 01 c0             	add    %rax,%rax
    5671:	48 01 d0             	add    %rdx,%rax
    5674:	48 c1 e0 04          	shl    $0x4,%rax
    5678:	48 01 c8             	add    %rcx,%rax
    567b:	8b 40 04             	mov    0x4(%rax),%eax
    567e:	89 c6                	mov    %eax,%esi
    5680:	48 8d 3d 49 30 00 00 	lea    0x3049(%rip),%rdi        # 86d0 <rcon+0x690>
    5687:	b8 00 00 00 00       	mov    $0x0,%eax
    568c:	e8 0f ca ff ff       	call   20a0 <printf@plt>
		printf("%#018lx ", elf_file->section_tables[i].sh_address);
    5691:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5695:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5699:	8b 45 f0             	mov    -0x10(%rbp),%eax
    569c:	48 63 d0             	movslq %eax,%rdx
    569f:	48 89 d0             	mov    %rdx,%rax
    56a2:	48 01 c0             	add    %rax,%rax
    56a5:	48 01 d0             	add    %rdx,%rax
    56a8:	48 c1 e0 04          	shl    $0x4,%rax
    56ac:	48 01 c8             	add    %rcx,%rax
    56af:	48 8b 40 10          	mov    0x10(%rax),%rax
    56b3:	48 89 c6             	mov    %rax,%rsi
    56b6:	48 8d 3d 1b 30 00 00 	lea    0x301b(%rip),%rdi        # 86d8 <rcon+0x698>
    56bd:	b8 00 00 00 00       	mov    $0x0,%eax
    56c2:	e8 d9 c9 ff ff       	call   20a0 <printf@plt>
		printf("%#018lx ", elf_file->section_tables[i].sh_offset);
    56c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    56cb:	48 8b 48 60          	mov    0x60(%rax),%rcx
    56cf:	8b 45 f0             	mov    -0x10(%rbp),%eax
    56d2:	48 63 d0             	movslq %eax,%rdx
    56d5:	48 89 d0             	mov    %rdx,%rax
    56d8:	48 01 c0             	add    %rax,%rax
    56db:	48 01 d0             	add    %rdx,%rax
    56de:	48 c1 e0 04          	shl    $0x4,%rax
    56e2:	48 01 c8             	add    %rcx,%rax
    56e5:	48 8b 40 18          	mov    0x18(%rax),%rax
    56e9:	48 89 c6             	mov    %rax,%rsi
    56ec:	48 8d 3d e5 2f 00 00 	lea    0x2fe5(%rip),%rdi        # 86d8 <rcon+0x698>
    56f3:	b8 00 00 00 00       	mov    $0x0,%eax
    56f8:	e8 a3 c9 ff ff       	call   20a0 <printf@plt>
		printf("%#018lx\n", elf_file->section_tables[i].sh_size);
    56fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5701:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5705:	8b 45 f0             	mov    -0x10(%rbp),%eax
    5708:	48 63 d0             	movslq %eax,%rdx
    570b:	48 89 d0             	mov    %rdx,%rax
    570e:	48 01 c0             	add    %rax,%rax
    5711:	48 01 d0             	add    %rdx,%rax
    5714:	48 c1 e0 04          	shl    $0x4,%rax
    5718:	48 01 c8             	add    %rcx,%rax
    571b:	48 8b 40 20          	mov    0x20(%rax),%rax
    571f:	48 89 c6             	mov    %rax,%rsi
    5722:	48 8d 3d b8 2f 00 00 	lea    0x2fb8(%rip),%rdi        # 86e1 <rcon+0x6a1>
    5729:	b8 00 00 00 00       	mov    $0x0,%eax
    572e:	e8 6d c9 ff ff       	call   20a0 <printf@plt>
	for (int i = 0; i < elf_file->e_shnum; i++)
    5733:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
    5737:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    573b:	0f b7 40 56          	movzwl 0x56(%rax),%eax
    573f:	0f b7 c0             	movzwl %ax,%eax
    5742:	39 45 f0             	cmp    %eax,-0x10(%rbp)
    5745:	0f 8c 54 fe ff ff    	jl     559f <print_elf_file+0x28e>
	}

	printf("\nProgram Headers:\n");
    574b:	48 8d 3d 98 2f 00 00 	lea    0x2f98(%rip),%rdi        # 86ea <rcon+0x6aa>
    5752:	e8 f9 c8 ff ff       	call   2050 <puts@plt>
	printf("  Type           Offset             VirtAddr           PhysAddr           FileSiz            MemSiz             Flags  Align\n");
    5757:	48 8d 3d a2 2f 00 00 	lea    0x2fa2(%rip),%rdi        # 8700 <rcon+0x6c0>
    575e:	e8 ed c8 ff ff       	call   2050 <puts@plt>
	for (int i = 0; i < elf_file->e_phnum; i++)
    5763:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    576a:	e9 2e 02 00 00       	jmp    599d <print_elf_file+0x68c>
	{
		printf("  ");
    576f:	48 8d 3d 07 30 00 00 	lea    0x3007(%rip),%rdi        # 877d <rcon+0x73d>
    5776:	b8 00 00 00 00       	mov    $0x0,%eax
    577b:	e8 20 c9 ff ff       	call   20a0 <printf@plt>
		if (elf_file->program_headers[i].p_type < 0x08)
    5780:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5784:	48 8b 48 68          	mov    0x68(%rax),%rcx
    5788:	8b 45 f4             	mov    -0xc(%rbp),%eax
    578b:	48 63 d0             	movslq %eax,%rdx
    578e:	48 89 d0             	mov    %rdx,%rax
    5791:	48 c1 e0 03          	shl    $0x3,%rax
    5795:	48 29 d0             	sub    %rdx,%rax
    5798:	48 c1 e0 03          	shl    $0x3,%rax
    579c:	48 01 c8             	add    %rcx,%rax
    579f:	8b 00                	mov    (%rax),%eax
    57a1:	83 f8 07             	cmp    $0x7,%eax
    57a4:	77 4c                	ja     57f2 <print_elf_file+0x4e1>
			printf("%-14s ", g_elf_program_header_type[elf_file->program_headers[i].p_type]);
    57a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    57aa:	48 8b 48 68          	mov    0x68(%rax),%rcx
    57ae:	8b 45 f4             	mov    -0xc(%rbp),%eax
    57b1:	48 63 d0             	movslq %eax,%rdx
    57b4:	48 89 d0             	mov    %rdx,%rax
    57b7:	48 c1 e0 03          	shl    $0x3,%rax
    57bb:	48 29 d0             	sub    %rdx,%rax
    57be:	48 c1 e0 03          	shl    $0x3,%rax
    57c2:	48 01 c8             	add    %rcx,%rax
    57c5:	8b 00                	mov    (%rax),%eax
    57c7:	89 c0                	mov    %eax,%eax
    57c9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    57d0:	00 
    57d1:	48 8d 05 88 6b 00 00 	lea    0x6b88(%rip),%rax        # c360 <g_elf_program_header_type>
    57d8:	48 8b 04 02          	mov    (%rdx,%rax,1),%rax
    57dc:	48 89 c6             	mov    %rax,%rsi
    57df:	48 8d 3d 9a 2f 00 00 	lea    0x2f9a(%rip),%rdi        # 8780 <rcon+0x740>
    57e6:	b8 00 00 00 00       	mov    $0x0,%eax
    57eb:	e8 b0 c8 ff ff       	call   20a0 <printf@plt>
    57f0:	eb 34                	jmp    5826 <print_elf_file+0x515>
		else
			printf("%#-14x ", elf_file->program_headers[i].p_type);
    57f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    57f6:	48 8b 48 68          	mov    0x68(%rax),%rcx
    57fa:	8b 45 f4             	mov    -0xc(%rbp),%eax
    57fd:	48 63 d0             	movslq %eax,%rdx
    5800:	48 89 d0             	mov    %rdx,%rax
    5803:	48 c1 e0 03          	shl    $0x3,%rax
    5807:	48 29 d0             	sub    %rdx,%rax
    580a:	48 c1 e0 03          	shl    $0x3,%rax
    580e:	48 01 c8             	add    %rcx,%rax
    5811:	8b 00                	mov    (%rax),%eax
    5813:	89 c6                	mov    %eax,%esi
    5815:	48 8d 3d 6b 2f 00 00 	lea    0x2f6b(%rip),%rdi        # 8787 <rcon+0x747>
    581c:	b8 00 00 00 00       	mov    $0x0,%eax
    5821:	e8 7a c8 ff ff       	call   20a0 <printf@plt>
		printf("%#018lx ", elf_file->program_headers[i].p_offset);
    5826:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    582a:	48 8b 48 68          	mov    0x68(%rax),%rcx
    582e:	8b 45 f4             	mov    -0xc(%rbp),%eax
    5831:	48 63 d0             	movslq %eax,%rdx
    5834:	48 89 d0             	mov    %rdx,%rax
    5837:	48 c1 e0 03          	shl    $0x3,%rax
    583b:	48 29 d0             	sub    %rdx,%rax
    583e:	48 c1 e0 03          	shl    $0x3,%rax
    5842:	48 01 c8             	add    %rcx,%rax
    5845:	48 8b 40 08          	mov    0x8(%rax),%rax
    5849:	48 89 c6             	mov    %rax,%rsi
    584c:	48 8d 3d 85 2e 00 00 	lea    0x2e85(%rip),%rdi        # 86d8 <rcon+0x698>
    5853:	b8 00 00 00 00       	mov    $0x0,%eax
    5858:	e8 43 c8 ff ff       	call   20a0 <printf@plt>
		printf("%#018lx ", elf_file->program_headers[i].p_vaddr);
    585d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5861:	48 8b 48 68          	mov    0x68(%rax),%rcx
    5865:	8b 45 f4             	mov    -0xc(%rbp),%eax
    5868:	48 63 d0             	movslq %eax,%rdx
    586b:	48 89 d0             	mov    %rdx,%rax
    586e:	48 c1 e0 03          	shl    $0x3,%rax
    5872:	48 29 d0             	sub    %rdx,%rax
    5875:	48 c1 e0 03          	shl    $0x3,%rax
    5879:	48 01 c8             	add    %rcx,%rax
    587c:	48 8b 40 10          	mov    0x10(%rax),%rax
    5880:	48 89 c6             	mov    %rax,%rsi
    5883:	48 8d 3d 4e 2e 00 00 	lea    0x2e4e(%rip),%rdi        # 86d8 <rcon+0x698>
    588a:	b8 00 00 00 00       	mov    $0x0,%eax
    588f:	e8 0c c8 ff ff       	call   20a0 <printf@plt>
		printf("%#018lx ", elf_file->program_headers[i].p_paddr);
    5894:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5898:	48 8b 48 68          	mov    0x68(%rax),%rcx
    589c:	8b 45 f4             	mov    -0xc(%rbp),%eax
    589f:	48 63 d0             	movslq %eax,%rdx
    58a2:	48 89 d0             	mov    %rdx,%rax
    58a5:	48 c1 e0 03          	shl    $0x3,%rax
    58a9:	48 29 d0             	sub    %rdx,%rax
    58ac:	48 c1 e0 03          	shl    $0x3,%rax
    58b0:	48 01 c8             	add    %rcx,%rax
    58b3:	48 8b 40 18          	mov    0x18(%rax),%rax
    58b7:	48 89 c6             	mov    %rax,%rsi
    58ba:	48 8d 3d 17 2e 00 00 	lea    0x2e17(%rip),%rdi        # 86d8 <rcon+0x698>
    58c1:	b8 00 00 00 00       	mov    $0x0,%eax
    58c6:	e8 d5 c7 ff ff       	call   20a0 <printf@plt>
		printf("%#018lx ", elf_file->program_headers[i].p_filesz);
    58cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    58cf:	48 8b 48 68          	mov    0x68(%rax),%rcx
    58d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
    58d6:	48 63 d0             	movslq %eax,%rdx
    58d9:	48 89 d0             	mov    %rdx,%rax
    58dc:	48 c1 e0 03          	shl    $0x3,%rax
    58e0:	48 29 d0             	sub    %rdx,%rax
    58e3:	48 c1 e0 03          	shl    $0x3,%rax
    58e7:	48 01 c8             	add    %rcx,%rax
    58ea:	48 8b 40 20          	mov    0x20(%rax),%rax
    58ee:	48 89 c6             	mov    %rax,%rsi
    58f1:	48 8d 3d e0 2d 00 00 	lea    0x2de0(%rip),%rdi        # 86d8 <rcon+0x698>
    58f8:	b8 00 00 00 00       	mov    $0x0,%eax
    58fd:	e8 9e c7 ff ff       	call   20a0 <printf@plt>
		printf("%#018lx ", elf_file->program_headers[i].p_memsz);
    5902:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5906:	48 8b 48 68          	mov    0x68(%rax),%rcx
    590a:	8b 45 f4             	mov    -0xc(%rbp),%eax
    590d:	48 63 d0             	movslq %eax,%rdx
    5910:	48 89 d0             	mov    %rdx,%rax
    5913:	48 c1 e0 03          	shl    $0x3,%rax
    5917:	48 29 d0             	sub    %rdx,%rax
    591a:	48 c1 e0 03          	shl    $0x3,%rax
    591e:	48 01 c8             	add    %rcx,%rax
    5921:	48 8b 40 28          	mov    0x28(%rax),%rax
    5925:	48 89 c6             	mov    %rax,%rsi
    5928:	48 8d 3d a9 2d 00 00 	lea    0x2da9(%rip),%rdi        # 86d8 <rcon+0x698>
    592f:	b8 00 00 00 00       	mov    $0x0,%eax
    5934:	e8 67 c7 ff ff       	call   20a0 <printf@plt>
		print_elf_program_flag(elf_file->program_headers[i].p_flags);
    5939:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    593d:	48 8b 48 68          	mov    0x68(%rax),%rcx
    5941:	8b 45 f4             	mov    -0xc(%rbp),%eax
    5944:	48 63 d0             	movslq %eax,%rdx
    5947:	48 89 d0             	mov    %rdx,%rax
    594a:	48 c1 e0 03          	shl    $0x3,%rax
    594e:	48 29 d0             	sub    %rdx,%rax
    5951:	48 c1 e0 03          	shl    $0x3,%rax
    5955:	48 01 c8             	add    %rcx,%rax
    5958:	8b 40 04             	mov    0x4(%rax),%eax
    595b:	89 c7                	mov    %eax,%edi
    595d:	e8 13 f9 ff ff       	call   5275 <print_elf_program_flag>
		printf("%#lx\n", elf_file->program_headers[i].p_align);
    5962:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5966:	48 8b 48 68          	mov    0x68(%rax),%rcx
    596a:	8b 45 f4             	mov    -0xc(%rbp),%eax
    596d:	48 63 d0             	movslq %eax,%rdx
    5970:	48 89 d0             	mov    %rdx,%rax
    5973:	48 c1 e0 03          	shl    $0x3,%rax
    5977:	48 29 d0             	sub    %rdx,%rax
    597a:	48 c1 e0 03          	shl    $0x3,%rax
    597e:	48 01 c8             	add    %rcx,%rax
    5981:	48 8b 40 30          	mov    0x30(%rax),%rax
    5985:	48 89 c6             	mov    %rax,%rsi
    5988:	48 8d 3d 00 2e 00 00 	lea    0x2e00(%rip),%rdi        # 878f <rcon+0x74f>
    598f:	b8 00 00 00 00       	mov    $0x0,%eax
    5994:	e8 07 c7 ff ff       	call   20a0 <printf@plt>
	for (int i = 0; i < elf_file->e_phnum; i++)
    5999:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
    599d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    59a1:	0f b7 40 52          	movzwl 0x52(%rax),%eax
    59a5:	0f b7 c0             	movzwl %ax,%eax
    59a8:	39 45 f4             	cmp    %eax,-0xc(%rbp)
    59ab:	0f 8c be fd ff ff    	jl     576f <print_elf_file+0x45e>
	}

	printf("\nSection to Segment mapping:\n");
    59b1:	48 8d 3d dd 2d 00 00 	lea    0x2ddd(%rip),%rdi        # 8795 <rcon+0x755>
    59b8:	e8 93 c6 ff ff       	call   2050 <puts@plt>
	printf("  Segment Sections...\n");
    59bd:	48 8d 3d ee 2d 00 00 	lea    0x2dee(%rip),%rdi        # 87b2 <rcon+0x772>
    59c4:	e8 87 c6 ff ff       	call   2050 <puts@plt>
	for (int i = 0; i < elf_file->e_phnum; i++)
    59c9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    59d0:	e9 61 01 00 00       	jmp    5b36 <print_elf_file+0x825>
	{
		printf("   %02d     ", i);
    59d5:	8b 45 f8             	mov    -0x8(%rbp),%eax
    59d8:	89 c6                	mov    %eax,%esi
    59da:	48 8d 3d e7 2d 00 00 	lea    0x2de7(%rip),%rdi        # 87c8 <rcon+0x788>
    59e1:	b8 00 00 00 00       	mov    $0x0,%eax
    59e6:	e8 b5 c6 ff ff       	call   20a0 <printf@plt>
		for (int j = 1; j < elf_file->e_shnum; j++)
    59eb:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
    59f2:	e9 1d 01 00 00       	jmp    5b14 <print_elf_file+0x803>
		{
			if (elf_file->section_tables[j].sh_offset >= elf_file->program_headers[i].p_offset &&
    59f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    59fb:	48 8b 48 60          	mov    0x60(%rax),%rcx
    59ff:	8b 45 fc             	mov    -0x4(%rbp),%eax
    5a02:	48 63 d0             	movslq %eax,%rdx
    5a05:	48 89 d0             	mov    %rdx,%rax
    5a08:	48 01 c0             	add    %rax,%rax
    5a0b:	48 01 d0             	add    %rdx,%rax
    5a0e:	48 c1 e0 04          	shl    $0x4,%rax
    5a12:	48 01 c8             	add    %rcx,%rax
    5a15:	48 8b 48 18          	mov    0x18(%rax),%rcx
    5a19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5a1d:	48 8b 70 68          	mov    0x68(%rax),%rsi
    5a21:	8b 45 f8             	mov    -0x8(%rbp),%eax
    5a24:	48 63 d0             	movslq %eax,%rdx
    5a27:	48 89 d0             	mov    %rdx,%rax
    5a2a:	48 c1 e0 03          	shl    $0x3,%rax
    5a2e:	48 29 d0             	sub    %rdx,%rax
    5a31:	48 c1 e0 03          	shl    $0x3,%rax
    5a35:	48 01 f0             	add    %rsi,%rax
    5a38:	48 8b 40 08          	mov    0x8(%rax),%rax
    5a3c:	48 39 c1             	cmp    %rax,%rcx
    5a3f:	0f 82 cb 00 00 00    	jb     5b10 <print_elf_file+0x7ff>
				elf_file->section_tables[j].sh_offset + elf_file->section_tables[j].sh_size <=
    5a45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5a49:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5a4d:	8b 45 fc             	mov    -0x4(%rbp),%eax
    5a50:	48 63 d0             	movslq %eax,%rdx
    5a53:	48 89 d0             	mov    %rdx,%rax
    5a56:	48 01 c0             	add    %rax,%rax
    5a59:	48 01 d0             	add    %rdx,%rax
    5a5c:	48 c1 e0 04          	shl    $0x4,%rax
    5a60:	48 01 c8             	add    %rcx,%rax
    5a63:	48 8b 48 18          	mov    0x18(%rax),%rcx
    5a67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5a6b:	48 8b 70 60          	mov    0x60(%rax),%rsi
    5a6f:	8b 45 fc             	mov    -0x4(%rbp),%eax
    5a72:	48 63 d0             	movslq %eax,%rdx
    5a75:	48 89 d0             	mov    %rdx,%rax
    5a78:	48 01 c0             	add    %rax,%rax
    5a7b:	48 01 d0             	add    %rdx,%rax
    5a7e:	48 c1 e0 04          	shl    $0x4,%rax
    5a82:	48 01 f0             	add    %rsi,%rax
    5a85:	48 8b 40 20          	mov    0x20(%rax),%rax
    5a89:	48 01 c1             	add    %rax,%rcx
				elf_file->program_headers[i].p_offset + elf_file->program_headers[i].p_filesz)
    5a8c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5a90:	48 8b 70 68          	mov    0x68(%rax),%rsi
    5a94:	8b 45 f8             	mov    -0x8(%rbp),%eax
    5a97:	48 63 d0             	movslq %eax,%rdx
    5a9a:	48 89 d0             	mov    %rdx,%rax
    5a9d:	48 c1 e0 03          	shl    $0x3,%rax
    5aa1:	48 29 d0             	sub    %rdx,%rax
    5aa4:	48 c1 e0 03          	shl    $0x3,%rax
    5aa8:	48 01 f0             	add    %rsi,%rax
    5aab:	48 8b 70 08          	mov    0x8(%rax),%rsi
    5aaf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5ab3:	48 8b 78 68          	mov    0x68(%rax),%rdi
    5ab7:	8b 45 f8             	mov    -0x8(%rbp),%eax
    5aba:	48 63 d0             	movslq %eax,%rdx
    5abd:	48 89 d0             	mov    %rdx,%rax
    5ac0:	48 c1 e0 03          	shl    $0x3,%rax
    5ac4:	48 29 d0             	sub    %rdx,%rax
    5ac7:	48 c1 e0 03          	shl    $0x3,%rax
    5acb:	48 01 f8             	add    %rdi,%rax
    5ace:	48 8b 40 20          	mov    0x20(%rax),%rax
    5ad2:	48 01 f0             	add    %rsi,%rax
			if (elf_file->section_tables[j].sh_offset >= elf_file->program_headers[i].p_offset &&
    5ad5:	48 39 c1             	cmp    %rax,%rcx
    5ad8:	77 36                	ja     5b10 <print_elf_file+0x7ff>
			{
				printf("%s ", elf_file->section_tables[j].sh_name);
    5ada:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5ade:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5ae2:	8b 45 fc             	mov    -0x4(%rbp),%eax
    5ae5:	48 63 d0             	movslq %eax,%rdx
    5ae8:	48 89 d0             	mov    %rdx,%rax
    5aeb:	48 01 c0             	add    %rax,%rax
    5aee:	48 01 d0             	add    %rdx,%rax
    5af1:	48 c1 e0 04          	shl    $0x4,%rax
    5af5:	48 01 c8             	add    %rcx,%rax
    5af8:	48 8b 40 28          	mov    0x28(%rax),%rax
    5afc:	48 89 c6             	mov    %rax,%rsi
    5aff:	48 8d 3d cf 2c 00 00 	lea    0x2ccf(%rip),%rdi        # 87d5 <rcon+0x795>
    5b06:	b8 00 00 00 00       	mov    $0x0,%eax
    5b0b:	e8 90 c5 ff ff       	call   20a0 <printf@plt>
		for (int j = 1; j < elf_file->e_shnum; j++)
    5b10:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    5b14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5b18:	0f b7 40 56          	movzwl 0x56(%rax),%eax
    5b1c:	0f b7 c0             	movzwl %ax,%eax
    5b1f:	39 45 fc             	cmp    %eax,-0x4(%rbp)
    5b22:	0f 8c cf fe ff ff    	jl     59f7 <print_elf_file+0x6e6>
			}
		}
		printf("\n");
    5b28:	bf 0a 00 00 00       	mov    $0xa,%edi
    5b2d:	e8 0e c5 ff ff       	call   2040 <putchar@plt>
	for (int i = 0; i < elf_file->e_phnum; i++)
    5b32:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
    5b36:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5b3a:	0f b7 40 52          	movzwl 0x52(%rax),%eax
    5b3e:	0f b7 c0             	movzwl %ax,%eax
    5b41:	39 45 f8             	cmp    %eax,-0x8(%rbp)
    5b44:	0f 8c 8b fe ff ff    	jl     59d5 <print_elf_file+0x6c4>
	}
}
    5b4a:	90                   	nop
    5b4b:	90                   	nop
    5b4c:	c9                   	leave  
    5b4d:	c3                   	ret    

0000000000005b4e <strip_sections>:
/* ************************************************************************** */

#include "woody.h"

static int	strip_sections(t_elf_file *old_elf_file, t_elf_file *new_elf_file, t_binary_reader *reader)
{
    5b4e:	f3 0f 1e fa          	endbr64 
    5b52:	55                   	push   %rbp
    5b53:	48 89 e5             	mov    %rsp,%rbp
    5b56:	53                   	push   %rbx
    5b57:	48 83 ec 38          	sub    $0x38,%rsp
    5b5b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    5b5f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    5b63:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	new_elf_file->section_tables = NULL;
    5b67:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5b6b:	48 c7 40 60 00 00 00 	movq   $0x0,0x60(%rax)
    5b72:	00 
	int j = 0;
    5b73:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
	for (int i = 0; i < old_elf_file->e_shnum; i++)
    5b7a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    5b81:	e9 f6 00 00 00       	jmp    5c7c <strip_sections+0x12e>
	{
		if (old_elf_file->section_tables[i].sh_type == 0x1) // PROGBITS
    5b86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5b8a:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5b8e:	8b 45 ec             	mov    -0x14(%rbp),%eax
    5b91:	48 63 d0             	movslq %eax,%rdx
    5b94:	48 89 d0             	mov    %rdx,%rax
    5b97:	48 01 c0             	add    %rax,%rax
    5b9a:	48 01 d0             	add    %rdx,%rax
    5b9d:	48 c1 e0 04          	shl    $0x4,%rax
    5ba1:	48 01 c8             	add    %rcx,%rax
    5ba4:	8b 40 04             	mov    0x4(%rax),%eax
    5ba7:	83 f8 01             	cmp    $0x1,%eax
    5baa:	0f 85 c8 00 00 00    	jne    5c78 <strip_sections+0x12a>
		{
			new_elf_file->section_tables = ft_realloc(new_elf_file->section_tables, sizeof(t_elf_section_table) * (i + 1));
    5bb0:	8b 45 ec             	mov    -0x14(%rbp),%eax
    5bb3:	83 c0 01             	add    $0x1,%eax
    5bb6:	48 63 d0             	movslq %eax,%rdx
    5bb9:	48 89 d0             	mov    %rdx,%rax
    5bbc:	48 01 c0             	add    %rax,%rax
    5bbf:	48 01 d0             	add    %rdx,%rax
    5bc2:	48 c1 e0 04          	shl    $0x4,%rax
    5bc6:	48 89 c2             	mov    %rax,%rdx
    5bc9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5bcd:	48 8b 40 60          	mov    0x60(%rax),%rax
    5bd1:	48 89 d6             	mov    %rdx,%rsi
    5bd4:	48 89 c7             	mov    %rax,%rdi
    5bd7:	e8 a5 e8 ff ff       	call   4481 <ft_realloc>
    5bdc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    5be0:	48 89 42 60          	mov    %rax,0x60(%rdx)
			if (!new_elf_file->section_tables)
    5be4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5be8:	48 8b 40 60          	mov    0x60(%rax),%rax
    5bec:	48 85 c0             	test   %rax,%rax
    5bef:	75 16                	jne    5c07 <strip_sections+0xb9>
				return (ft_error(WD_PREFIX"Could not allocate memory.\n"), 1);
    5bf1:	48 8d 3d c0 2d 00 00 	lea    0x2dc0(%rip),%rdi        # 89b8 <rcon+0x1d8>
    5bf8:	e8 a3 d4 ff ff       	call   30a0 <ft_error>
    5bfd:	b8 01 00 00 00       	mov    $0x1,%eax
    5c02:	e9 9b 00 00 00       	jmp    5ca2 <strip_sections+0x154>
			new_elf_file->section_tables[j++] = old_elf_file->section_tables[i];
    5c07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5c0b:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5c0f:	8b 45 ec             	mov    -0x14(%rbp),%eax
    5c12:	48 63 d0             	movslq %eax,%rdx
    5c15:	48 89 d0             	mov    %rdx,%rax
    5c18:	48 01 c0             	add    %rax,%rax
    5c1b:	48 01 d0             	add    %rdx,%rax
    5c1e:	48 c1 e0 04          	shl    $0x4,%rax
    5c22:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
    5c26:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5c2a:	48 8b 70 60          	mov    0x60(%rax),%rsi
    5c2e:	8b 45 e8             	mov    -0x18(%rbp),%eax
    5c31:	8d 48 01             	lea    0x1(%rax),%ecx
    5c34:	89 4d e8             	mov    %ecx,-0x18(%rbp)
    5c37:	48 63 c8             	movslq %eax,%rcx
    5c3a:	48 89 c8             	mov    %rcx,%rax
    5c3d:	48 01 c0             	add    %rax,%rax
    5c40:	48 01 c8             	add    %rcx,%rax
    5c43:	48 c1 e0 04          	shl    $0x4,%rax
    5c47:	48 01 f0             	add    %rsi,%rax
    5c4a:	48 8b 0a             	mov    (%rdx),%rcx
    5c4d:	48 8b 5a 08          	mov    0x8(%rdx),%rbx
    5c51:	48 89 08             	mov    %rcx,(%rax)
    5c54:	48 89 58 08          	mov    %rbx,0x8(%rax)
    5c58:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
    5c5c:	48 8b 5a 18          	mov    0x18(%rdx),%rbx
    5c60:	48 89 48 10          	mov    %rcx,0x10(%rax)
    5c64:	48 89 58 18          	mov    %rbx,0x18(%rax)
    5c68:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
    5c6c:	48 8b 5a 28          	mov    0x28(%rdx),%rbx
    5c70:	48 89 48 20          	mov    %rcx,0x20(%rax)
    5c74:	48 89 58 28          	mov    %rbx,0x28(%rax)
	for (int i = 0; i < old_elf_file->e_shnum; i++)
    5c78:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
    5c7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5c80:	0f b7 40 56          	movzwl 0x56(%rax),%eax
    5c84:	0f b7 c0             	movzwl %ax,%eax
    5c87:	39 45 ec             	cmp    %eax,-0x14(%rbp)
    5c8a:	0f 8c f6 fe ff ff    	jl     5b86 <strip_sections+0x38>
		}
	}
	new_elf_file->e_shnum = j;
    5c90:	8b 45 e8             	mov    -0x18(%rbp),%eax
    5c93:	89 c2                	mov    %eax,%edx
    5c95:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5c99:	66 89 50 56          	mov    %dx,0x56(%rax)
	return (0);
    5c9d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    5ca2:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    5ca6:	c9                   	leave  
    5ca7:	c3                   	ret    

0000000000005ca8 <strip_program_headers>:

static int strip_program_headers(t_elf_file *old_elf_file, t_elf_file *new_elf_file, t_binary_reader *reader)
{
    5ca8:	f3 0f 1e fa          	endbr64 
    5cac:	55                   	push   %rbp
    5cad:	48 89 e5             	mov    %rsp,%rbp
    5cb0:	53                   	push   %rbx
    5cb1:	48 83 ec 38          	sub    $0x38,%rsp
    5cb5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    5cb9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    5cbd:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	new_elf_file->program_headers = NULL;
    5cc1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5cc5:	48 c7 40 68 00 00 00 	movq   $0x0,0x68(%rax)
    5ccc:	00 
	int j = 0;
    5ccd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	
	for (int i = 0; i < old_elf_file->e_phnum; i++)
    5cd4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
    5cdb:	e9 f8 01 00 00       	jmp    5ed8 <strip_program_headers+0x230>
	{
		// Vrifie si le segment contient des sections
		int has_sections = 0;
    5ce0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for (int k = 0; k < old_elf_file->e_shnum; k++)
    5ce7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    5cee:	e9 f0 00 00 00       	jmp    5de3 <strip_program_headers+0x13b>
		{
			// if (new_elf_file->section_tables[k].sh_type == 0x0) continue;

			// if (new_elf_file->section_tables[k].sh_address >= old_elf_file->program_headers[i].p_vaddr &&
			if (new_elf_file->section_tables[k].sh_address > old_elf_file->program_headers[i].p_vaddr &&
    5cf3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5cf7:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5cfb:	8b 45 ec             	mov    -0x14(%rbp),%eax
    5cfe:	48 63 d0             	movslq %eax,%rdx
    5d01:	48 89 d0             	mov    %rdx,%rax
    5d04:	48 01 c0             	add    %rax,%rax
    5d07:	48 01 d0             	add    %rdx,%rax
    5d0a:	48 c1 e0 04          	shl    $0x4,%rax
    5d0e:	48 01 c8             	add    %rcx,%rax
    5d11:	48 8b 48 10          	mov    0x10(%rax),%rcx
    5d15:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5d19:	48 8b 70 68          	mov    0x68(%rax),%rsi
    5d1d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    5d20:	48 63 d0             	movslq %eax,%rdx
    5d23:	48 89 d0             	mov    %rdx,%rax
    5d26:	48 c1 e0 03          	shl    $0x3,%rax
    5d2a:	48 29 d0             	sub    %rdx,%rax
    5d2d:	48 c1 e0 03          	shl    $0x3,%rax
    5d31:	48 01 f0             	add    %rsi,%rax
    5d34:	48 8b 40 10          	mov    0x10(%rax),%rax
    5d38:	48 39 c1             	cmp    %rax,%rcx
    5d3b:	0f 86 9e 00 00 00    	jbe    5ddf <strip_program_headers+0x137>
				new_elf_file->section_tables[k].sh_address + new_elf_file->section_tables[k].sh_size <=
    5d41:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5d45:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5d49:	8b 45 ec             	mov    -0x14(%rbp),%eax
    5d4c:	48 63 d0             	movslq %eax,%rdx
    5d4f:	48 89 d0             	mov    %rdx,%rax
    5d52:	48 01 c0             	add    %rax,%rax
    5d55:	48 01 d0             	add    %rdx,%rax
    5d58:	48 c1 e0 04          	shl    $0x4,%rax
    5d5c:	48 01 c8             	add    %rcx,%rax
    5d5f:	48 8b 48 10          	mov    0x10(%rax),%rcx
    5d63:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5d67:	48 8b 70 60          	mov    0x60(%rax),%rsi
    5d6b:	8b 45 ec             	mov    -0x14(%rbp),%eax
    5d6e:	48 63 d0             	movslq %eax,%rdx
    5d71:	48 89 d0             	mov    %rdx,%rax
    5d74:	48 01 c0             	add    %rax,%rax
    5d77:	48 01 d0             	add    %rdx,%rax
    5d7a:	48 c1 e0 04          	shl    $0x4,%rax
    5d7e:	48 01 f0             	add    %rsi,%rax
    5d81:	48 8b 40 20          	mov    0x20(%rax),%rax
    5d85:	48 01 c1             	add    %rax,%rcx
					old_elf_file->program_headers[i].p_vaddr + old_elf_file->program_headers[i].p_memsz)
    5d88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5d8c:	48 8b 70 68          	mov    0x68(%rax),%rsi
    5d90:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    5d93:	48 63 d0             	movslq %eax,%rdx
    5d96:	48 89 d0             	mov    %rdx,%rax
    5d99:	48 c1 e0 03          	shl    $0x3,%rax
    5d9d:	48 29 d0             	sub    %rdx,%rax
    5da0:	48 c1 e0 03          	shl    $0x3,%rax
    5da4:	48 01 f0             	add    %rsi,%rax
    5da7:	48 8b 70 10          	mov    0x10(%rax),%rsi
    5dab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5daf:	48 8b 78 68          	mov    0x68(%rax),%rdi
    5db3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    5db6:	48 63 d0             	movslq %eax,%rdx
    5db9:	48 89 d0             	mov    %rdx,%rax
    5dbc:	48 c1 e0 03          	shl    $0x3,%rax
    5dc0:	48 29 d0             	sub    %rdx,%rax
    5dc3:	48 c1 e0 03          	shl    $0x3,%rax
    5dc7:	48 01 f8             	add    %rdi,%rax
    5dca:	48 8b 40 28          	mov    0x28(%rax),%rax
    5dce:	48 01 f0             	add    %rsi,%rax
			if (new_elf_file->section_tables[k].sh_address > old_elf_file->program_headers[i].p_vaddr &&
    5dd1:	48 39 c1             	cmp    %rax,%rcx
    5dd4:	77 09                	ja     5ddf <strip_program_headers+0x137>
			{
				has_sections = 1;
    5dd6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%rbp)
				break;
    5ddd:	eb 18                	jmp    5df7 <strip_program_headers+0x14f>
		for (int k = 0; k < old_elf_file->e_shnum; k++)
    5ddf:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
    5de3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5de7:	0f b7 40 56          	movzwl 0x56(%rax),%eax
    5deb:	0f b7 c0             	movzwl %ax,%eax
    5dee:	39 45 ec             	cmp    %eax,-0x14(%rbp)
    5df1:	0f 8c fc fe ff ff    	jl     5cf3 <strip_program_headers+0x4b>
			}
		}
		
		// Si le segment ne contient pas de sections, ne l'ajoute pas aux nouveaux en-ttes de programme
		if (has_sections)
    5df7:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
    5dfb:	0f 84 d3 00 00 00    	je     5ed4 <strip_program_headers+0x22c>
		{
			new_elf_file->program_headers = ft_realloc(new_elf_file->program_headers, sizeof(t_elf_program_header) * (j + 1));
    5e01:	8b 45 e0             	mov    -0x20(%rbp),%eax
    5e04:	83 c0 01             	add    $0x1,%eax
    5e07:	48 63 d0             	movslq %eax,%rdx
    5e0a:	48 89 d0             	mov    %rdx,%rax
    5e0d:	48 c1 e0 03          	shl    $0x3,%rax
    5e11:	48 29 d0             	sub    %rdx,%rax
    5e14:	48 c1 e0 03          	shl    $0x3,%rax
    5e18:	48 89 c2             	mov    %rax,%rdx
    5e1b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5e1f:	48 8b 40 68          	mov    0x68(%rax),%rax
    5e23:	48 89 d6             	mov    %rdx,%rsi
    5e26:	48 89 c7             	mov    %rax,%rdi
    5e29:	e8 53 e6 ff ff       	call   4481 <ft_realloc>
    5e2e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    5e32:	48 89 42 68          	mov    %rax,0x68(%rdx)
			if (!new_elf_file->program_headers)
    5e36:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5e3a:	48 8b 40 68          	mov    0x68(%rax),%rax
    5e3e:	48 85 c0             	test   %rax,%rax
    5e41:	75 16                	jne    5e59 <strip_program_headers+0x1b1>
				return (ft_error(WD_PREFIX "Could not allocate memory.\n"), 1);
    5e43:	48 8d 3d 6e 2b 00 00 	lea    0x2b6e(%rip),%rdi        # 89b8 <rcon+0x1d8>
    5e4a:	e8 51 d2 ff ff       	call   30a0 <ft_error>
    5e4f:	b8 01 00 00 00       	mov    $0x1,%eax
    5e54:	e9 a5 00 00 00       	jmp    5efe <strip_program_headers+0x256>
			new_elf_file->program_headers[j++] = old_elf_file->program_headers[i];
    5e59:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5e5d:	48 8b 48 68          	mov    0x68(%rax),%rcx
    5e61:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    5e64:	48 63 d0             	movslq %eax,%rdx
    5e67:	48 89 d0             	mov    %rdx,%rax
    5e6a:	48 c1 e0 03          	shl    $0x3,%rax
    5e6e:	48 29 d0             	sub    %rdx,%rax
    5e71:	48 c1 e0 03          	shl    $0x3,%rax
    5e75:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
    5e79:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5e7d:	48 8b 70 68          	mov    0x68(%rax),%rsi
    5e81:	8b 45 e0             	mov    -0x20(%rbp),%eax
    5e84:	8d 48 01             	lea    0x1(%rax),%ecx
    5e87:	89 4d e0             	mov    %ecx,-0x20(%rbp)
    5e8a:	48 63 c8             	movslq %eax,%rcx
    5e8d:	48 89 c8             	mov    %rcx,%rax
    5e90:	48 c1 e0 03          	shl    $0x3,%rax
    5e94:	48 29 c8             	sub    %rcx,%rax
    5e97:	48 c1 e0 03          	shl    $0x3,%rax
    5e9b:	48 01 f0             	add    %rsi,%rax
    5e9e:	48 8b 0a             	mov    (%rdx),%rcx
    5ea1:	48 8b 5a 08          	mov    0x8(%rdx),%rbx
    5ea5:	48 89 08             	mov    %rcx,(%rax)
    5ea8:	48 89 58 08          	mov    %rbx,0x8(%rax)
    5eac:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
    5eb0:	48 8b 5a 18          	mov    0x18(%rdx),%rbx
    5eb4:	48 89 48 10          	mov    %rcx,0x10(%rax)
    5eb8:	48 89 58 18          	mov    %rbx,0x18(%rax)
    5ebc:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
    5ec0:	48 8b 5a 28          	mov    0x28(%rdx),%rbx
    5ec4:	48 89 48 20          	mov    %rcx,0x20(%rax)
    5ec8:	48 89 58 28          	mov    %rbx,0x28(%rax)
    5ecc:	48 8b 52 30          	mov    0x30(%rdx),%rdx
    5ed0:	48 89 50 30          	mov    %rdx,0x30(%rax)
	for (int i = 0; i < old_elf_file->e_phnum; i++)
    5ed4:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
    5ed8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    5edc:	0f b7 40 52          	movzwl 0x52(%rax),%eax
    5ee0:	0f b7 c0             	movzwl %ax,%eax
    5ee3:	39 45 e4             	cmp    %eax,-0x1c(%rbp)
    5ee6:	0f 8c f4 fd ff ff    	jl     5ce0 <strip_program_headers+0x38>
		}
	}
	
	new_elf_file->e_phnum = j;
    5eec:	8b 45 e0             	mov    -0x20(%rbp),%eax
    5eef:	89 c2                	mov    %eax,%edx
    5ef1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5ef5:	66 89 50 52          	mov    %dx,0x52(%rax)
	return (0);
    5ef9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    5efe:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    5f02:	c9                   	leave  
    5f03:	c3                   	ret    

0000000000005f04 <packer>:

int	packer(t_elf_file *old_elf_file, t_elf_file *new_elf_file, t_binary_reader *reader)
{
    5f04:	f3 0f 1e fa          	endbr64 
    5f08:	55                   	push   %rbp
    5f09:	48 89 e5             	mov    %rsp,%rbp
    5f0c:	48 83 ec 30          	sub    $0x30,%rsp
    5f10:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    5f14:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    5f18:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int fd = open("woody", O_CREAT | O_WRONLY | O_TRUNC, 0755);
    5f1c:	ba ed 01 00 00       	mov    $0x1ed,%edx
    5f21:	be 41 02 00 00       	mov    $0x241,%esi
    5f26:	48 8d 3d ae 2a 00 00 	lea    0x2aae(%rip),%rdi        # 89db <rcon+0x1fb>
    5f2d:	b8 00 00 00 00       	mov    $0x0,%eax
    5f32:	e8 09 c2 ff ff       	call   2140 <open@plt>
    5f37:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (fd == -1)
    5f3a:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
    5f3e:	75 16                	jne    5f56 <packer+0x52>
		return (ft_error(WD_PREFIX"Could not open file.\n"), 1);
    5f40:	48 8d 3d 9a 2a 00 00 	lea    0x2a9a(%rip),%rdi        # 89e1 <rcon+0x201>
    5f47:	e8 54 d1 ff ff       	call   30a0 <ft_error>
    5f4c:	b8 01 00 00 00       	mov    $0x1,%eax
    5f51:	e9 07 02 00 00       	jmp    615d <packer+0x259>

	uint32_t magic = 0x464C457F;
    5f56:	c7 45 fc 7f 45 4c 46 	movl   $0x464c457f,-0x4(%rbp)
	write(fd, new_elf_file->e_ident.raw, 16);
    5f5d:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
    5f61:	8b 45 f8             	mov    -0x8(%rbp),%eax
    5f64:	ba 10 00 00 00       	mov    $0x10,%edx
    5f69:	48 89 ce             	mov    %rcx,%rsi
    5f6c:	89 c7                	mov    %eax,%edi
    5f6e:	e8 ed c0 ff ff       	call   2060 <write@plt>
	write(fd, &new_elf_file->e_type, 2);
    5f73:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    5f77:	48 8d 48 10          	lea    0x10(%rax),%rcx
    5f7b:	8b 45 f8             	mov    -0x8(%rbp),%eax
    5f7e:	ba 02 00 00 00       	mov    $0x2,%edx
    5f83:	48 89 ce             	mov    %rcx,%rsi
    5f86:	89 c7                	mov    %eax,%edi
    5f88:	e8 d3 c0 ff ff       	call   2060 <write@plt>
	write(fd, &new_elf_file->e_machine, 2);
    5f8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    5f91:	48 8d 48 20          	lea    0x20(%rax),%rcx
    5f95:	8b 45 f8             	mov    -0x8(%rbp),%eax
    5f98:	ba 02 00 00 00       	mov    $0x2,%edx
    5f9d:	48 89 ce             	mov    %rcx,%rsi
    5fa0:	89 c7                	mov    %eax,%edi
    5fa2:	e8 b9 c0 ff ff       	call   2060 <write@plt>
	write(fd, &new_elf_file->e_version, 4);
    5fa7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    5fab:	48 8d 48 24          	lea    0x24(%rax),%rcx
    5faf:	8b 45 f8             	mov    -0x8(%rbp),%eax
    5fb2:	ba 04 00 00 00       	mov    $0x4,%edx
    5fb7:	48 89 ce             	mov    %rcx,%rsi
    5fba:	89 c7                	mov    %eax,%edi
    5fbc:	e8 9f c0 ff ff       	call   2060 <write@plt>
	write(fd, "\0\0\0\0\0\0\0\0", new_elf_file->e_ident.ei_class == WD_32BITS ? 4 : 8); // entry
    5fc1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    5fc5:	0f b6 40 04          	movzbl 0x4(%rax),%eax
    5fc9:	3c 01                	cmp    $0x1,%al
    5fcb:	75 07                	jne    5fd4 <packer+0xd0>
    5fcd:	ba 04 00 00 00       	mov    $0x4,%edx
    5fd2:	eb 05                	jmp    5fd9 <packer+0xd5>
    5fd4:	ba 08 00 00 00       	mov    $0x8,%edx
    5fd9:	8b 45 f8             	mov    -0x8(%rbp),%eax
    5fdc:	48 8d 35 1b 2a 00 00 	lea    0x2a1b(%rip),%rsi        # 89fe <rcon+0x21e>
    5fe3:	89 c7                	mov    %eax,%edi
    5fe5:	e8 76 c0 ff ff       	call   2060 <write@plt>
	write(fd, "\0\0\0\0\0\0\0\0", new_elf_file->e_ident.ei_class == WD_32BITS ? 4 : 8); // phoff
    5fea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    5fee:	0f b6 40 04          	movzbl 0x4(%rax),%eax
    5ff2:	3c 01                	cmp    $0x1,%al
    5ff4:	75 07                	jne    5ffd <packer+0xf9>
    5ff6:	ba 04 00 00 00       	mov    $0x4,%edx
    5ffb:	eb 05                	jmp    6002 <packer+0xfe>
    5ffd:	ba 08 00 00 00       	mov    $0x8,%edx
    6002:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6005:	48 8d 35 f2 29 00 00 	lea    0x29f2(%rip),%rsi        # 89fe <rcon+0x21e>
    600c:	89 c7                	mov    %eax,%edi
    600e:	e8 4d c0 ff ff       	call   2060 <write@plt>
	write(fd, "\0\0\0\0\0\0\0\0", new_elf_file->e_ident.ei_class == WD_32BITS ? 4 : 8); // shoff
    6013:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    6017:	0f b6 40 04          	movzbl 0x4(%rax),%eax
    601b:	3c 01                	cmp    $0x1,%al
    601d:	75 07                	jne    6026 <packer+0x122>
    601f:	ba 04 00 00 00       	mov    $0x4,%edx
    6024:	eb 05                	jmp    602b <packer+0x127>
    6026:	ba 08 00 00 00       	mov    $0x8,%edx
    602b:	8b 45 f8             	mov    -0x8(%rbp),%eax
    602e:	48 8d 35 c9 29 00 00 	lea    0x29c9(%rip),%rsi        # 89fe <rcon+0x21e>
    6035:	89 c7                	mov    %eax,%edi
    6037:	e8 24 c0 ff ff       	call   2060 <write@plt>
	write(fd, &new_elf_file->e_flags, 4);
    603c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    6040:	48 8d 48 40          	lea    0x40(%rax),%rcx
    6044:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6047:	ba 04 00 00 00       	mov    $0x4,%edx
    604c:	48 89 ce             	mov    %rcx,%rsi
    604f:	89 c7                	mov    %eax,%edi
    6051:	e8 0a c0 ff ff       	call   2060 <write@plt>
	write(fd, &new_elf_file->e_ehsize, 2);
    6056:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    605a:	48 8d 48 48          	lea    0x48(%rax),%rcx
    605e:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6061:	ba 02 00 00 00       	mov    $0x2,%edx
    6066:	48 89 ce             	mov    %rcx,%rsi
    6069:	89 c7                	mov    %eax,%edi
    606b:	e8 f0 bf ff ff       	call   2060 <write@plt>
	write(fd, &new_elf_file->e_phentsize, 2);
    6070:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    6074:	48 8d 48 50          	lea    0x50(%rax),%rcx
    6078:	8b 45 f8             	mov    -0x8(%rbp),%eax
    607b:	ba 02 00 00 00       	mov    $0x2,%edx
    6080:	48 89 ce             	mov    %rcx,%rsi
    6083:	89 c7                	mov    %eax,%edi
    6085:	e8 d6 bf ff ff       	call   2060 <write@plt>
	write(fd, &new_elf_file->e_phnum, 2);
    608a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    608e:	48 8d 48 52          	lea    0x52(%rax),%rcx
    6092:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6095:	ba 02 00 00 00       	mov    $0x2,%edx
    609a:	48 89 ce             	mov    %rcx,%rsi
    609d:	89 c7                	mov    %eax,%edi
    609f:	e8 bc bf ff ff       	call   2060 <write@plt>
	write(fd, &new_elf_file->e_shentsize, 2);
    60a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    60a8:	48 8d 48 54          	lea    0x54(%rax),%rcx
    60ac:	8b 45 f8             	mov    -0x8(%rbp),%eax
    60af:	ba 02 00 00 00       	mov    $0x2,%edx
    60b4:	48 89 ce             	mov    %rcx,%rsi
    60b7:	89 c7                	mov    %eax,%edi
    60b9:	e8 a2 bf ff ff       	call   2060 <write@plt>
	write(fd, "\0\0", 2);
    60be:	8b 45 f8             	mov    -0x8(%rbp),%eax
    60c1:	ba 02 00 00 00       	mov    $0x2,%edx
    60c6:	48 8d 35 3a 29 00 00 	lea    0x293a(%rip),%rsi        # 8a07 <rcon+0x227>
    60cd:	89 c7                	mov    %eax,%edi
    60cf:	e8 8c bf ff ff       	call   2060 <write@plt>
	write(fd, "\0\0", 2);
    60d4:	8b 45 f8             	mov    -0x8(%rbp),%eax
    60d7:	ba 02 00 00 00       	mov    $0x2,%edx
    60dc:	48 8d 35 24 29 00 00 	lea    0x2924(%rip),%rsi        # 8a07 <rcon+0x227>
    60e3:	89 c7                	mov    %eax,%edi
    60e5:	e8 76 bf ff ff       	call   2060 <write@plt>

	if (strip_sections(old_elf_file, new_elf_file, reader))
    60ea:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    60ee:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
    60f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    60f6:	48 89 ce             	mov    %rcx,%rsi
    60f9:	48 89 c7             	mov    %rax,%rdi
    60fc:	e8 4d fa ff ff       	call   5b4e <strip_sections>
    6101:	85 c0                	test   %eax,%eax
    6103:	74 11                	je     6116 <packer+0x212>
	{
		close(fd);
    6105:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6108:	89 c7                	mov    %eax,%edi
    610a:	e8 b1 bf ff ff       	call   20c0 <close@plt>
		return (1);
    610f:	b8 01 00 00 00       	mov    $0x1,%eax
    6114:	eb 47                	jmp    615d <packer+0x259>
	}

	if (strip_program_headers(old_elf_file, new_elf_file, reader))
    6116:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    611a:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
    611e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6122:	48 89 ce             	mov    %rcx,%rsi
    6125:	48 89 c7             	mov    %rax,%rdi
    6128:	e8 7b fb ff ff       	call   5ca8 <strip_program_headers>
    612d:	85 c0                	test   %eax,%eax
    612f:	74 11                	je     6142 <packer+0x23e>
	{
		close(fd);
    6131:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6134:	89 c7                	mov    %eax,%edi
    6136:	e8 85 bf ff ff       	call   20c0 <close@plt>
		return (1);
    613b:	b8 01 00 00 00       	mov    $0x1,%eax
    6140:	eb 1b                	jmp    615d <packer+0x259>
	}

	print_elf_file(new_elf_file);
    6142:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    6146:	48 89 c7             	mov    %rax,%rdi
    6149:	e8 c3 f1 ff ff       	call   5311 <print_elf_file>

	close(fd);
    614e:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6151:	89 c7                	mov    %eax,%edi
    6153:	e8 68 bf ff ff       	call   20c0 <close@plt>
	return (0);
    6158:	b8 00 00 00 00       	mov    $0x0,%eax
}
    615d:	c9                   	leave  
    615e:	c3                   	ret    

000000000000615f <AES_encrypt>:

void	printbytes(uint8_t *bytes, size_t size);

//take the plaintext and the key as arguments, fixed size of each, will die otherwise
uint8_t **AES_encrypt(uint8_t *plaintext, char *key)
{
    615f:	f3 0f 1e fa          	endbr64 
    6163:	55                   	push   %rbp
    6164:	48 89 e5             	mov    %rsp,%rbp
    6167:	48 83 ec 30          	sub    $0x30,%rsp
    616b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    616f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	if (!plaintext || !key)
    6173:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
    6178:	74 07                	je     6181 <AES_encrypt+0x22>
    617a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    617f:	75 0a                	jne    618b <AES_encrypt+0x2c>
		return (NULL);
    6181:	b8 00 00 00 00       	mov    $0x0,%eax
    6186:	e9 30 01 00 00       	jmp    62bb <AES_encrypt+0x15c>


	// printf("key -> %s\n", key);
	uint8_t *key_schedule = calloc(240, sizeof(uint8_t));
    618b:	be 01 00 00 00       	mov    $0x1,%esi
    6190:	bf f0 00 00 00       	mov    $0xf0,%edi
    6195:	e8 56 bf ff ff       	call   20f0 <calloc@plt>
    619a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	get_key_schedule(key, key_schedule);
    619e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    61a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    61a6:	48 89 d6             	mov    %rdx,%rsi
    61a9:	48 89 c7             	mov    %rax,%rdi
    61ac:	e8 b0 13 00 00       	call   7561 <get_key_schedule>

	uint8_t ***state = toState(plaintext);
    61b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    61b5:	48 89 c7             	mov    %rax,%rdi
    61b8:	e8 6f 10 00 00       	call   722c <toState>
    61bd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	AddRoundKey(state, getWord(key_schedule, 0));
    61c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    61c5:	be 00 00 00 00       	mov    $0x0,%esi
    61ca:	48 89 c7             	mov    %rax,%rdi
    61cd:	e8 6c 0c 00 00       	call   6e3e <getWord>
    61d2:	48 89 c2             	mov    %rax,%rdx
    61d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    61d9:	48 89 d6             	mov    %rdx,%rsi
    61dc:	48 89 c7             	mov    %rax,%rdi
    61df:	e8 7b 0c 00 00       	call   6e5f <AddRoundKey>

	for (int i = 1; i < 14; i++)
    61e4:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%rbp)
    61eb:	eb 52                	jmp    623f <AES_encrypt+0xe0>
	{

		SubBytes(state);
    61ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    61f1:	48 89 c7             	mov    %rax,%rdi
    61f4:	e8 ef 0c 00 00       	call   6ee8 <SubBytes>
		ShiftRows(state);
    61f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    61fd:	48 89 c7             	mov    %rax,%rdi
    6200:	e8 7b 0e 00 00       	call   7080 <ShiftRows>
		MixColumns(state);
    6205:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6209:	48 89 c7             	mov    %rax,%rdi
    620c:	e8 41 06 00 00       	call   6852 <MixColumns>
		AddRoundKey(state, getWord(key_schedule, i * 4));
    6211:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    6214:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
    621b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    621f:	89 d6                	mov    %edx,%esi
    6221:	48 89 c7             	mov    %rax,%rdi
    6224:	e8 15 0c 00 00       	call   6e3e <getWord>
    6229:	48 89 c2             	mov    %rax,%rdx
    622c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6230:	48 89 d6             	mov    %rdx,%rsi
    6233:	48 89 c7             	mov    %rax,%rdi
    6236:	e8 24 0c 00 00       	call   6e5f <AddRoundKey>
	for (int i = 1; i < 14; i++)
    623b:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
    623f:	83 7d e4 0d          	cmpl   $0xd,-0x1c(%rbp)
    6243:	7e a8                	jle    61ed <AES_encrypt+0x8e>
	}

	SubBytes(state);
    6245:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6249:	48 89 c7             	mov    %rax,%rdi
    624c:	e8 97 0c 00 00       	call   6ee8 <SubBytes>
	ShiftRows(state);
    6251:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6255:	48 89 c7             	mov    %rax,%rdi
    6258:	e8 23 0e 00 00       	call   7080 <ShiftRows>
	AddRoundKey(state, getWord(key_schedule, 56));
    625d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6261:	be 38 00 00 00       	mov    $0x38,%esi
    6266:	48 89 c7             	mov    %rax,%rdi
    6269:	e8 d0 0b 00 00       	call   6e3e <getWord>
    626e:	48 89 c2             	mov    %rax,%rdx
    6271:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6275:	48 89 d6             	mov    %rdx,%rsi
    6278:	48 89 c7             	mov    %rax,%rdi
    627b:	e8 df 0b 00 00       	call   6e5f <AddRoundKey>

    uint8_t** ciphertext;
	ciphertext = fromState(state);
    6280:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6284:	48 89 c7             	mov    %rax,%rdi
    6287:	e8 70 10 00 00       	call   72fc <fromState>
    628c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	freeState(*state);
    6290:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6294:	48 8b 00             	mov    (%rax),%rax
    6297:	48 89 c7             	mov    %rax,%rdi
    629a:	e8 27 0e 00 00       	call   70c6 <freeState>
	free(state);
    629f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    62a3:	48 89 c7             	mov    %rax,%rdi
    62a6:	e8 85 bd ff ff       	call   2030 <free@plt>
	free(key_schedule);
    62ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    62af:	48 89 c7             	mov    %rax,%rdi
    62b2:	e8 79 bd ff ff       	call   2030 <free@plt>

	return (ciphertext);
    62b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    62bb:	c9                   	leave  
    62bc:	c3                   	ret    

00000000000062bd <AES_decrypt>:

uint8_t **AES_decrypt(uint8_t *plaintext, char *key)
{
    62bd:	f3 0f 1e fa          	endbr64 
    62c1:	55                   	push   %rbp
    62c2:	48 89 e5             	mov    %rsp,%rbp
    62c5:	48 83 ec 30          	sub    $0x30,%rsp
    62c9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    62cd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    if (!plaintext || !key)
    62d1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
    62d6:	74 07                	je     62df <AES_decrypt+0x22>
    62d8:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    62dd:	75 0a                	jne    62e9 <AES_decrypt+0x2c>
		return (NULL);
    62df:	b8 00 00 00 00       	mov    $0x0,%eax
    62e4:	e9 30 01 00 00       	jmp    6419 <AES_decrypt+0x15c>

	uint8_t *key_schedule = calloc(240, sizeof(uint8_t));
    62e9:	be 01 00 00 00       	mov    $0x1,%esi
    62ee:	bf f0 00 00 00       	mov    $0xf0,%edi
    62f3:	e8 f8 bd ff ff       	call   20f0 <calloc@plt>
    62f8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	get_key_schedule(key, key_schedule);
    62fc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    6300:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    6304:	48 89 d6             	mov    %rdx,%rsi
    6307:	48 89 c7             	mov    %rax,%rdi
    630a:	e8 52 12 00 00       	call   7561 <get_key_schedule>

	// printf("key 2 -> %s\n", key);
	uint8_t ***state = toState(plaintext);
    630f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    6313:	48 89 c7             	mov    %rax,%rdi
    6316:	e8 11 0f 00 00       	call   722c <toState>
    631b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	AddRoundKey(state, getWord(key_schedule, 56));
    631f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6323:	be 38 00 00 00       	mov    $0x38,%esi
    6328:	48 89 c7             	mov    %rax,%rdi
    632b:	e8 0e 0b 00 00       	call   6e3e <getWord>
    6330:	48 89 c2             	mov    %rax,%rdx
    6333:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6337:	48 89 d6             	mov    %rdx,%rsi
    633a:	48 89 c7             	mov    %rax,%rdi
    633d:	e8 1d 0b 00 00       	call   6e5f <AddRoundKey>

	for (int i = 13; i > 0; i--)
    6342:	c7 45 e4 0d 00 00 00 	movl   $0xd,-0x1c(%rbp)
    6349:	eb 52                	jmp    639d <AES_decrypt+0xe0>
	{

		InvShiftRows(state);
    634b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    634f:	48 89 c7             	mov    %rax,%rdi
    6352:	e8 4c 0d 00 00       	call   70a3 <InvShiftRows>
		InvSubBytes(state);
    6357:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    635b:	48 89 c7             	mov    %rax,%rdi
    635e:	e8 aa 0b 00 00       	call   6f0d <InvSubBytes>
		AddRoundKey(state, getWord(key_schedule, i * 4));
    6363:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    6366:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
    636d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6371:	89 d6                	mov    %edx,%esi
    6373:	48 89 c7             	mov    %rax,%rdi
    6376:	e8 c3 0a 00 00       	call   6e3e <getWord>
    637b:	48 89 c2             	mov    %rax,%rdx
    637e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6382:	48 89 d6             	mov    %rdx,%rsi
    6385:	48 89 c7             	mov    %rax,%rdi
    6388:	e8 d2 0a 00 00       	call   6e5f <AddRoundKey>
		InvMixColumns(state);
    638d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6391:	48 89 c7             	mov    %rax,%rdi
    6394:	e8 77 07 00 00       	call   6b10 <InvMixColumns>
	for (int i = 13; i > 0; i--)
    6399:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
    639d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
    63a1:	7f a8                	jg     634b <AES_decrypt+0x8e>
	}

	InvShiftRows(state);
    63a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    63a7:	48 89 c7             	mov    %rax,%rdi
    63aa:	e8 f4 0c 00 00       	call   70a3 <InvShiftRows>
	InvSubBytes(state);
    63af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    63b3:	48 89 c7             	mov    %rax,%rdi
    63b6:	e8 52 0b 00 00       	call   6f0d <InvSubBytes>
	AddRoundKey(state, getWord(key_schedule, 0));
    63bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    63bf:	be 00 00 00 00       	mov    $0x0,%esi
    63c4:	48 89 c7             	mov    %rax,%rdi
    63c7:	e8 72 0a 00 00       	call   6e3e <getWord>
    63cc:	48 89 c2             	mov    %rax,%rdx
    63cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    63d3:	48 89 d6             	mov    %rdx,%rsi
    63d6:	48 89 c7             	mov    %rax,%rdi
    63d9:	e8 81 0a 00 00       	call   6e5f <AddRoundKey>

    uint8_t** ciphertext;
	ciphertext = fromState(state);
    63de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    63e2:	48 89 c7             	mov    %rax,%rdi
    63e5:	e8 12 0f 00 00       	call   72fc <fromState>
    63ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	freeState(*state);
    63ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    63f2:	48 8b 00             	mov    (%rax),%rax
    63f5:	48 89 c7             	mov    %rax,%rdi
    63f8:	e8 c9 0c 00 00       	call   70c6 <freeState>
	free(state);
    63fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    6401:	48 89 c7             	mov    %rax,%rdi
    6404:	e8 27 bc ff ff       	call   2030 <free@plt>
	free(key_schedule);
    6409:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    640d:	48 89 c7             	mov    %rax,%rdi
    6410:	e8 1b bc ff ff       	call   2030 <free@plt>
	return (ciphertext);
    6415:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    6419:	c9                   	leave  
    641a:	c3                   	ret    

000000000000641b <AES_file>:
#include <stdint.h>
#include <stdio.h>
#include <woody.h>

int AES_file(char *file, char *key, int mode)
{
    641b:	f3 0f 1e fa          	endbr64 
    641f:	55                   	push   %rbp
    6420:	48 89 e5             	mov    %rsp,%rbp
    6423:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
    642a:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    6431:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
    6438:	89 95 4c ff ff ff    	mov    %edx,-0xb4(%rbp)
    643e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6445:	00 00 
    6447:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    644b:	31 c0                	xor    %eax,%eax
	int file_id;
	file_id = 1;
    644d:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%rbp)
    6454:	00 00 00 
	if (strlen(key) != 32){
    6457:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
    645e:	48 89 c7             	mov    %rax,%rdi
    6461:	e8 0a bc ff ff       	call   2070 <strlen@plt>
    6466:	48 83 f8 20          	cmp    $0x20,%rax
    646a:	74 16                	je     6482 <AES_file+0x67>
		printf("Error: Key must be 64 characters long\n");
    646c:	48 8d 3d c5 27 00 00 	lea    0x27c5(%rip),%rdi        # 8c38 <rcon+0x1d8>
    6473:	e8 d8 bb ff ff       	call   2050 <puts@plt>
		return(-1);
    6478:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    647d:	e9 ba 03 00 00       	jmp    683c <AES_file+0x421>
	}
	if (mode == 1)
    6482:	83 bd 4c ff ff ff 01 	cmpl   $0x1,-0xb4(%rbp)
    6489:	0f 85 2c 03 00 00    	jne    67bb <AES_file+0x3a0>
	{
		int tmp_fd = open(file, O_RDONLY);
    648f:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
    6496:	be 00 00 00 00       	mov    $0x0,%esi
    649b:	48 89 c7             	mov    %rax,%rdi
    649e:	b8 00 00 00 00       	mov    $0x0,%eax
    64a3:	e8 98 bc ff ff       	call   2140 <open@plt>
    64a8:	89 45 88             	mov    %eax,-0x78(%rbp)
		int crashtest_fd = open("encoded", O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, 0777);
    64ab:	ba ff 01 00 00       	mov    $0x1ff,%edx
    64b0:	be 41 02 00 00       	mov    $0x241,%esi
    64b5:	48 8d 3d a2 27 00 00 	lea    0x27a2(%rip),%rdi        # 8c5e <rcon+0x1fe>
    64bc:	b8 00 00 00 00       	mov    $0x0,%eax
    64c1:	e8 7a bc ff ff       	call   2140 <open@plt>
    64c6:	89 45 8c             	mov    %eax,-0x74(%rbp)
		t_binary_reader *reader_tmp = new_binary_reader(tmp_fd);
    64c9:	8b 45 88             	mov    -0x78(%rbp),%eax
    64cc:	89 c7                	mov    %eax,%edi
    64ce:	e8 b1 c8 ff ff       	call   2d84 <new_binary_reader>
    64d3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		if (!reader_tmp)
    64d7:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
    64dc:	75 25                	jne    6503 <AES_file+0xe8>
		{
			printf("Error: Cannot read file %s\n", file);
    64de:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
    64e5:	48 89 c6             	mov    %rax,%rsi
    64e8:	48 8d 3d 77 27 00 00 	lea    0x2777(%rip),%rdi        # 8c66 <rcon+0x206>
    64ef:	b8 00 00 00 00       	mov    $0x0,%eax
    64f4:	e8 a7 bb ff ff       	call   20a0 <printf@plt>
			return (1);
    64f9:	b8 01 00 00 00       	mov    $0x1,%eax
    64fe:	e9 39 03 00 00       	jmp    683c <AES_file+0x421>
		}
		uint8_t tm[17];
		size_t round = 0;
    6503:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
    650a:	00 
		while (round * 16 < 16)
    650b:	e9 94 02 00 00       	jmp    67a4 <AES_file+0x389>
		{
			for (int i = 0; i < 16; i++)
    6510:	c7 85 6c ff ff ff 00 	movl   $0x0,-0x94(%rbp)
    6517:	00 00 00 
    651a:	eb 48                	jmp    6564 <AES_file+0x149>
			{
				tm[i] = reader_tmp->get_uint8(reader_tmp);
    651c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    6520:	48 8b 50 28          	mov    0x28(%rax),%rdx
    6524:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    6528:	48 89 c7             	mov    %rax,%rdi
    652b:	ff d2                	call   *%rdx
    652d:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
    6533:	48 63 d2             	movslq %edx,%rdx
    6536:	88 44 15 d0          	mov    %al,-0x30(%rbp,%rdx,1)
				printf("%03i ", tm[i]);
    653a:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
    6540:	48 98                	cltq   
    6542:	0f b6 44 05 d0       	movzbl -0x30(%rbp,%rax,1),%eax
    6547:	0f b6 c0             	movzbl %al,%eax
    654a:	89 c6                	mov    %eax,%esi
    654c:	48 8d 3d 2f 27 00 00 	lea    0x272f(%rip),%rdi        # 8c82 <rcon+0x222>
    6553:	b8 00 00 00 00       	mov    $0x0,%eax
    6558:	e8 43 bb ff ff       	call   20a0 <printf@plt>
			for (int i = 0; i < 16; i++)
    655d:	83 85 6c ff ff ff 01 	addl   $0x1,-0x94(%rbp)
    6564:	83 bd 6c ff ff ff 0f 	cmpl   $0xf,-0x94(%rbp)
    656b:	7e af                	jle    651c <AES_file+0x101>
			}
			printf("\n");
    656d:	bf 0a 00 00 00       	mov    $0xa,%edi
    6572:	e8 c9 ba ff ff       	call   2040 <putchar@plt>
			tm[16] = 0;
    6577:	c6 45 e0 00          	movb   $0x0,-0x20(%rbp)
			char *tmp = calloc(1, 256);
    657b:	be 00 01 00 00       	mov    $0x100,%esi
    6580:	bf 01 00 00 00       	mov    $0x1,%edi
    6585:	e8 66 bb ff ff       	call   20f0 <calloc@plt>
    658a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
			BytesToString(tm, tmp);
    658e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    6592:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    6596:	48 89 d6             	mov    %rdx,%rsi
    6599:	48 89 c7             	mov    %rax,%rdi
    659c:	e8 5f 11 00 00       	call   7700 <BytesToString>
			printf("before : %s\n", tmp);
    65a1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    65a5:	48 89 c6             	mov    %rax,%rsi
    65a8:	48 8d 3d d9 26 00 00 	lea    0x26d9(%rip),%rdi        # 8c88 <rcon+0x228>
    65af:	b8 00 00 00 00       	mov    $0x0,%eax
    65b4:	e8 e7 ba ff ff       	call   20a0 <printf@plt>
			uint8_t **encoded = AES_encrypt(tmp, key);
    65b9:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
    65c0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    65c4:	48 89 d6             	mov    %rdx,%rsi
    65c7:	48 89 c7             	mov    %rax,%rdi
    65ca:	e8 90 fb ff ff       	call   615f <AES_encrypt>
    65cf:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			if (encoded == NULL)
    65d3:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
    65d8:	75 16                	jne    65f0 <AES_file+0x1d5>
			{
				printf("error\n");
    65da:	48 8d 3d b4 26 00 00 	lea    0x26b4(%rip),%rdi        # 8c95 <rcon+0x235>
    65e1:	e8 6a ba ff ff       	call   2050 <puts@plt>
				return (0);
    65e6:	b8 00 00 00 00       	mov    $0x0,%eax
			return (1);
    65eb:	e9 4c 02 00 00       	jmp    683c <AES_file+0x421>
			}
			char str1[32];
			for (int i = 0; i < 16; i++)
    65f0:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%rbp)
    65f7:	00 00 00 
    65fa:	eb 60                	jmp    665c <AES_file+0x241>
			{
				dprintf(crashtest_fd, "%c", (* encoded)[i]);
    65fc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    6600:	48 8b 10             	mov    (%rax),%rdx
    6603:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
    6609:	48 98                	cltq   
    660b:	48 01 d0             	add    %rdx,%rax
    660e:	0f b6 00             	movzbl (%rax),%eax
    6611:	0f b6 d0             	movzbl %al,%edx
    6614:	8b 45 8c             	mov    -0x74(%rbp),%eax
    6617:	48 8d 35 7d 26 00 00 	lea    0x267d(%rip),%rsi        # 8c9b <rcon+0x23b>
    661e:	89 c7                	mov    %eax,%edi
    6620:	b8 00 00 00 00       	mov    $0x0,%eax
    6625:	e8 a6 ba ff ff       	call   20d0 <dprintf@plt>
				printf("%03i ", (* encoded)[i]);
    662a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    662e:	48 8b 10             	mov    (%rax),%rdx
    6631:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
    6637:	48 98                	cltq   
    6639:	48 01 d0             	add    %rdx,%rax
    663c:	0f b6 00             	movzbl (%rax),%eax
    663f:	0f b6 c0             	movzbl %al,%eax
    6642:	89 c6                	mov    %eax,%esi
    6644:	48 8d 3d 37 26 00 00 	lea    0x2637(%rip),%rdi        # 8c82 <rcon+0x222>
    664b:	b8 00 00 00 00       	mov    $0x0,%eax
    6650:	e8 4b ba ff ff       	call   20a0 <printf@plt>
			for (int i = 0; i < 16; i++)
    6655:	83 85 70 ff ff ff 01 	addl   $0x1,-0x90(%rbp)
    665c:	83 bd 70 ff ff ff 0f 	cmpl   $0xf,-0x90(%rbp)
    6663:	7e 97                	jle    65fc <AES_file+0x1e1>
			}
			round++;
    6665:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)

			//this work
			int tmp_fd2 = open("encoded", O_RDONLY);
    666a:	be 00 00 00 00       	mov    $0x0,%esi
    666f:	48 8d 3d e8 25 00 00 	lea    0x25e8(%rip),%rdi        # 8c5e <rcon+0x1fe>
    6676:	b8 00 00 00 00       	mov    $0x0,%eax
    667b:	e8 c0 ba ff ff       	call   2140 <open@plt>
    6680:	89 45 90             	mov    %eax,-0x70(%rbp)
			t_binary_reader *reader_tmp2 = new_binary_reader(tmp_fd2);
    6683:	8b 45 90             	mov    -0x70(%rbp),%eax
    6686:	89 c7                	mov    %eax,%edi
    6688:	e8 f7 c6 ff ff       	call   2d84 <new_binary_reader>
    668d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			int crashtest_fd2 = open("decoded", O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, 0777);
    6691:	ba ff 01 00 00       	mov    $0x1ff,%edx
    6696:	be 41 02 00 00       	mov    $0x241,%esi
    669b:	48 8d 3d fc 25 00 00 	lea    0x25fc(%rip),%rdi        # 8c9e <rcon+0x23e>
    66a2:	b8 00 00 00 00       	mov    $0x0,%eax
    66a7:	e8 94 ba ff ff       	call   2140 <open@plt>
    66ac:	89 45 94             	mov    %eax,-0x6c(%rbp)
			printf("\ndecoded\n");
    66af:	48 8d 3d f0 25 00 00 	lea    0x25f0(%rip),%rdi        # 8ca6 <rcon+0x246>
    66b6:	e8 95 b9 ff ff       	call   2050 <puts@plt>
			for (int i = 0; i < 16; i++)
    66bb:	c7 85 74 ff ff ff 00 	movl   $0x0,-0x8c(%rbp)
    66c2:	00 00 00 
    66c5:	eb 48                	jmp    670f <AES_file+0x2f4>
			{
				tm[i] = reader_tmp2->get_uint8(reader_tmp2);
    66c7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    66cb:	48 8b 50 28          	mov    0x28(%rax),%rdx
    66cf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    66d3:	48 89 c7             	mov    %rax,%rdi
    66d6:	ff d2                	call   *%rdx
    66d8:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
    66de:	48 63 d2             	movslq %edx,%rdx
    66e1:	88 44 15 d0          	mov    %al,-0x30(%rbp,%rdx,1)
				printf("%03i ", tm[i]);
    66e5:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
    66eb:	48 98                	cltq   
    66ed:	0f b6 44 05 d0       	movzbl -0x30(%rbp,%rax,1),%eax
    66f2:	0f b6 c0             	movzbl %al,%eax
    66f5:	89 c6                	mov    %eax,%esi
    66f7:	48 8d 3d 84 25 00 00 	lea    0x2584(%rip),%rdi        # 8c82 <rcon+0x222>
    66fe:	b8 00 00 00 00       	mov    $0x0,%eax
    6703:	e8 98 b9 ff ff       	call   20a0 <printf@plt>
			for (int i = 0; i < 16; i++)
    6708:	83 85 74 ff ff ff 01 	addl   $0x1,-0x8c(%rbp)
    670f:	83 bd 74 ff ff ff 0f 	cmpl   $0xf,-0x8c(%rbp)
    6716:	7e af                	jle    66c7 <AES_file+0x2ac>
			}
			tm[17] = 0;
    6718:	c6 45 e1 00          	movb   $0x0,-0x1f(%rbp)
			printf("\n");
    671c:	bf 0a 00 00 00       	mov    $0xa,%edi
    6721:	e8 1a b9 ff ff       	call   2040 <putchar@plt>
			BytesToString(tm, tmp);
    6726:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    672a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    672e:	48 89 d6             	mov    %rdx,%rsi
    6731:	48 89 c7             	mov    %rax,%rdi
    6734:	e8 c7 0f 00 00       	call   7700 <BytesToString>
			uint8_t **decoded = AES_decrypt(tmp, key);
    6739:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
    6740:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    6744:	48 89 d6             	mov    %rdx,%rsi
    6747:	48 89 c7             	mov    %rax,%rdi
    674a:	e8 6e fb ff ff       	call   62bd <AES_decrypt>
    674f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			// stringToBytes(decoded, tmp, 32);
			for (int i = 0; i < 16; i++)
    6753:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%rbp)
    675a:	00 00 00 
    675d:	eb 32                	jmp    6791 <AES_file+0x376>
			{	
				// dprintf(crashtest_fd2, "%c", (*decoded)[i]);
				printf("%03i ", (*decoded)[i]);
    675f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6763:	48 8b 10             	mov    (%rax),%rdx
    6766:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
    676c:	48 98                	cltq   
    676e:	48 01 d0             	add    %rdx,%rax
    6771:	0f b6 00             	movzbl (%rax),%eax
    6774:	0f b6 c0             	movzbl %al,%eax
    6777:	89 c6                	mov    %eax,%esi
    6779:	48 8d 3d 02 25 00 00 	lea    0x2502(%rip),%rdi        # 8c82 <rcon+0x222>
    6780:	b8 00 00 00 00       	mov    $0x0,%eax
    6785:	e8 16 b9 ff ff       	call   20a0 <printf@plt>
			for (int i = 0; i < 16; i++)
    678a:	83 85 78 ff ff ff 01 	addl   $0x1,-0x88(%rbp)
    6791:	83 bd 78 ff ff ff 0f 	cmpl   $0xf,-0x88(%rbp)
    6798:	7e c5                	jle    675f <AES_file+0x344>
			}
			printf("\n");
    679a:	bf 0a 00 00 00       	mov    $0xa,%edi
    679f:	e8 9c b8 ff ff       	call   2040 <putchar@plt>
		while (round * 16 < 16)
    67a4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    67a8:	48 c1 e0 04          	shl    $0x4,%rax
    67ac:	48 83 f8 0f          	cmp    $0xf,%rax
    67b0:	0f 86 5a fd ff ff    	jbe    6510 <AES_file+0xf5>
    67b6:	e9 81 00 00 00       	jmp    683c <AES_file+0x421>
		}
	}
	else if (mode == 2)
    67bb:	83 bd 4c ff ff ff 02 	cmpl   $0x2,-0xb4(%rbp)
    67c2:	75 78                	jne    683c <AES_file+0x421>
	{
		file_id = 2;
    67c4:	c7 85 7c ff ff ff 02 	movl   $0x2,-0x84(%rbp)
    67cb:	00 00 00 
		int tmp_fd = open("encoded", O_RDONLY);
    67ce:	be 00 00 00 00       	mov    $0x0,%esi
    67d3:	48 8d 3d 84 24 00 00 	lea    0x2484(%rip),%rdi        # 8c5e <rcon+0x1fe>
    67da:	b8 00 00 00 00       	mov    $0x0,%eax
    67df:	e8 5c b9 ff ff       	call   2140 <open@plt>
    67e4:	89 45 80             	mov    %eax,-0x80(%rbp)
		int crashtest_fd = open("decoded", O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, 0777);
    67e7:	ba ff 01 00 00       	mov    $0x1ff,%edx
    67ec:	be 41 02 00 00       	mov    $0x241,%esi
    67f1:	48 8d 3d a6 24 00 00 	lea    0x24a6(%rip),%rdi        # 8c9e <rcon+0x23e>
    67f8:	b8 00 00 00 00       	mov    $0x0,%eax
    67fd:	e8 3e b9 ff ff       	call   2140 <open@plt>
    6802:	89 45 84             	mov    %eax,-0x7c(%rbp)
		t_binary_reader *reader_tmp = new_binary_reader(tmp_fd);
    6805:	8b 45 80             	mov    -0x80(%rbp),%eax
    6808:	89 c7                	mov    %eax,%edi
    680a:	e8 75 c5 ff ff       	call   2d84 <new_binary_reader>
    680f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		if (!reader_tmp)
    6813:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
    6818:	75 22                	jne    683c <AES_file+0x421>
		{
			printf("Error: Cannot read file %s\n", file);
    681a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
    6821:	48 89 c6             	mov    %rax,%rsi
    6824:	48 8d 3d 3b 24 00 00 	lea    0x243b(%rip),%rdi        # 8c66 <rcon+0x206>
    682b:	b8 00 00 00 00       	mov    $0x0,%eax
    6830:	e8 6b b8 ff ff       	call   20a0 <printf@plt>
			return (1);
    6835:	b8 01 00 00 00       	mov    $0x1,%eax
    683a:	eb 00                	jmp    683c <AES_file+0x421>
		}
	}
}
    683c:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    6840:	64 48 2b 0c 25 28 00 	sub    %fs:0x28,%rcx
    6847:	00 00 
    6849:	74 05                	je     6850 <AES_file+0x435>
    684b:	e8 30 b8 ff ff       	call   2080 <__stack_chk_fail@plt>
    6850:	c9                   	leave  
    6851:	c3                   	ret    

0000000000006852 <MixColumns>:
#include "aes.h"
#include <stdint.h>
#include <string.h>

void MixColumns(uint8_t ***state){
    6852:	f3 0f 1e fa          	endbr64 
    6856:	55                   	push   %rbp
    6857:	48 89 e5             	mov    %rsp,%rbp
    685a:	53                   	push   %rbx
    685b:	48 83 ec 38          	sub    $0x38,%rsp
    685f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    6863:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    686a:	00 00 
    686c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    6870:	31 c0                	xor    %eax,%eax
	int c, r;
	for(c = 0; c < 4; c++){
    6872:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
    6879:	e9 6d 02 00 00       	jmp    6aeb <MixColumns+0x299>
		uint8_t temp[4];
		temp[0] = galoisMultiply(state[0][0][c], 2) ^ galoisMultiply(state[0][1][c], 3) ^ state[0][2][c] ^ state[0][3][c];
    687e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6882:	48 8b 00             	mov    (%rax),%rax
    6885:	48 8b 10             	mov    (%rax),%rdx
    6888:	8b 45 dc             	mov    -0x24(%rbp),%eax
    688b:	48 98                	cltq   
    688d:	48 01 d0             	add    %rdx,%rax
    6890:	0f b6 00             	movzbl (%rax),%eax
    6893:	0f b6 c0             	movzbl %al,%eax
    6896:	be 02 00 00 00       	mov    $0x2,%esi
    689b:	89 c7                	mov    %eax,%edi
    689d:	e8 75 08 00 00       	call   7117 <galoisMultiply>
    68a2:	89 c3                	mov    %eax,%ebx
    68a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    68a8:	48 8b 00             	mov    (%rax),%rax
    68ab:	48 83 c0 08          	add    $0x8,%rax
    68af:	48 8b 10             	mov    (%rax),%rdx
    68b2:	8b 45 dc             	mov    -0x24(%rbp),%eax
    68b5:	48 98                	cltq   
    68b7:	48 01 d0             	add    %rdx,%rax
    68ba:	0f b6 00             	movzbl (%rax),%eax
    68bd:	0f b6 c0             	movzbl %al,%eax
    68c0:	be 03 00 00 00       	mov    $0x3,%esi
    68c5:	89 c7                	mov    %eax,%edi
    68c7:	e8 4b 08 00 00       	call   7117 <galoisMultiply>
    68cc:	89 d9                	mov    %ebx,%ecx
    68ce:	31 c1                	xor    %eax,%ecx
    68d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    68d4:	48 8b 00             	mov    (%rax),%rax
    68d7:	48 83 c0 10          	add    $0x10,%rax
    68db:	48 8b 10             	mov    (%rax),%rdx
    68de:	8b 45 dc             	mov    -0x24(%rbp),%eax
    68e1:	48 98                	cltq   
    68e3:	48 01 d0             	add    %rdx,%rax
    68e6:	0f b6 00             	movzbl (%rax),%eax
    68e9:	31 c1                	xor    %eax,%ecx
    68eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    68ef:	48 8b 00             	mov    (%rax),%rax
    68f2:	48 83 c0 18          	add    $0x18,%rax
    68f6:	48 8b 10             	mov    (%rax),%rdx
    68f9:	8b 45 dc             	mov    -0x24(%rbp),%eax
    68fc:	48 98                	cltq   
    68fe:	48 01 d0             	add    %rdx,%rax
    6901:	0f b6 00             	movzbl (%rax),%eax
    6904:	31 c8                	xor    %ecx,%eax
    6906:	88 45 e4             	mov    %al,-0x1c(%rbp)
		temp[1] = state[0][0][c] ^ galoisMultiply(state[0][1][c], 2) ^ galoisMultiply(state[0][2][c], 3) ^ state[0][3][c];
    6909:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    690d:	48 8b 00             	mov    (%rax),%rax
    6910:	48 8b 10             	mov    (%rax),%rdx
    6913:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6916:	48 98                	cltq   
    6918:	48 01 d0             	add    %rdx,%rax
    691b:	0f b6 00             	movzbl (%rax),%eax
    691e:	89 c3                	mov    %eax,%ebx
    6920:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6924:	48 8b 00             	mov    (%rax),%rax
    6927:	48 83 c0 08          	add    $0x8,%rax
    692b:	48 8b 10             	mov    (%rax),%rdx
    692e:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6931:	48 98                	cltq   
    6933:	48 01 d0             	add    %rdx,%rax
    6936:	0f b6 00             	movzbl (%rax),%eax
    6939:	0f b6 c0             	movzbl %al,%eax
    693c:	be 02 00 00 00       	mov    $0x2,%esi
    6941:	89 c7                	mov    %eax,%edi
    6943:	e8 cf 07 00 00       	call   7117 <galoisMultiply>
    6948:	31 c3                	xor    %eax,%ebx
    694a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    694e:	48 8b 00             	mov    (%rax),%rax
    6951:	48 83 c0 10          	add    $0x10,%rax
    6955:	48 8b 10             	mov    (%rax),%rdx
    6958:	8b 45 dc             	mov    -0x24(%rbp),%eax
    695b:	48 98                	cltq   
    695d:	48 01 d0             	add    %rdx,%rax
    6960:	0f b6 00             	movzbl (%rax),%eax
    6963:	0f b6 c0             	movzbl %al,%eax
    6966:	be 03 00 00 00       	mov    $0x3,%esi
    696b:	89 c7                	mov    %eax,%edi
    696d:	e8 a5 07 00 00       	call   7117 <galoisMultiply>
    6972:	31 c3                	xor    %eax,%ebx
    6974:	89 d9                	mov    %ebx,%ecx
    6976:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    697a:	48 8b 00             	mov    (%rax),%rax
    697d:	48 83 c0 18          	add    $0x18,%rax
    6981:	48 8b 10             	mov    (%rax),%rdx
    6984:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6987:	48 98                	cltq   
    6989:	48 01 d0             	add    %rdx,%rax
    698c:	0f b6 00             	movzbl (%rax),%eax
    698f:	31 c8                	xor    %ecx,%eax
    6991:	88 45 e5             	mov    %al,-0x1b(%rbp)
		temp[2] = state[0][0][c] ^ state[0][1][c] ^ galoisMultiply(state[0][2][c], 2) ^ galoisMultiply(state[0][3][c], 3);
    6994:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6998:	48 8b 00             	mov    (%rax),%rax
    699b:	48 8b 10             	mov    (%rax),%rdx
    699e:	8b 45 dc             	mov    -0x24(%rbp),%eax
    69a1:	48 98                	cltq   
    69a3:	48 01 d0             	add    %rdx,%rax
    69a6:	0f b6 10             	movzbl (%rax),%edx
    69a9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    69ad:	48 8b 00             	mov    (%rax),%rax
    69b0:	48 83 c0 08          	add    $0x8,%rax
    69b4:	48 8b 08             	mov    (%rax),%rcx
    69b7:	8b 45 dc             	mov    -0x24(%rbp),%eax
    69ba:	48 98                	cltq   
    69bc:	48 01 c8             	add    %rcx,%rax
    69bf:	0f b6 00             	movzbl (%rax),%eax
    69c2:	31 d0                	xor    %edx,%eax
    69c4:	89 c3                	mov    %eax,%ebx
    69c6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    69ca:	48 8b 00             	mov    (%rax),%rax
    69cd:	48 83 c0 10          	add    $0x10,%rax
    69d1:	48 8b 10             	mov    (%rax),%rdx
    69d4:	8b 45 dc             	mov    -0x24(%rbp),%eax
    69d7:	48 98                	cltq   
    69d9:	48 01 d0             	add    %rdx,%rax
    69dc:	0f b6 00             	movzbl (%rax),%eax
    69df:	0f b6 c0             	movzbl %al,%eax
    69e2:	be 02 00 00 00       	mov    $0x2,%esi
    69e7:	89 c7                	mov    %eax,%edi
    69e9:	e8 29 07 00 00       	call   7117 <galoisMultiply>
    69ee:	31 c3                	xor    %eax,%ebx
    69f0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    69f4:	48 8b 00             	mov    (%rax),%rax
    69f7:	48 83 c0 18          	add    $0x18,%rax
    69fb:	48 8b 10             	mov    (%rax),%rdx
    69fe:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6a01:	48 98                	cltq   
    6a03:	48 01 d0             	add    %rdx,%rax
    6a06:	0f b6 00             	movzbl (%rax),%eax
    6a09:	0f b6 c0             	movzbl %al,%eax
    6a0c:	be 03 00 00 00       	mov    $0x3,%esi
    6a11:	89 c7                	mov    %eax,%edi
    6a13:	e8 ff 06 00 00       	call   7117 <galoisMultiply>
    6a18:	31 d8                	xor    %ebx,%eax
    6a1a:	88 45 e6             	mov    %al,-0x1a(%rbp)
		temp[3] = galoisMultiply(state[0][0][c], 3) ^ state[0][1][c] ^ state[0][2][c] ^ galoisMultiply(state[0][3][c], 2);
    6a1d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6a21:	48 8b 00             	mov    (%rax),%rax
    6a24:	48 8b 10             	mov    (%rax),%rdx
    6a27:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6a2a:	48 98                	cltq   
    6a2c:	48 01 d0             	add    %rdx,%rax
    6a2f:	0f b6 00             	movzbl (%rax),%eax
    6a32:	0f b6 c0             	movzbl %al,%eax
    6a35:	be 03 00 00 00       	mov    $0x3,%esi
    6a3a:	89 c7                	mov    %eax,%edi
    6a3c:	e8 d6 06 00 00       	call   7117 <galoisMultiply>
    6a41:	89 c2                	mov    %eax,%edx
    6a43:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6a47:	48 8b 00             	mov    (%rax),%rax
    6a4a:	48 83 c0 08          	add    $0x8,%rax
    6a4e:	48 8b 08             	mov    (%rax),%rcx
    6a51:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6a54:	48 98                	cltq   
    6a56:	48 01 c8             	add    %rcx,%rax
    6a59:	0f b6 00             	movzbl (%rax),%eax
    6a5c:	89 d1                	mov    %edx,%ecx
    6a5e:	31 c1                	xor    %eax,%ecx
    6a60:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6a64:	48 8b 00             	mov    (%rax),%rax
    6a67:	48 83 c0 10          	add    $0x10,%rax
    6a6b:	48 8b 10             	mov    (%rax),%rdx
    6a6e:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6a71:	48 98                	cltq   
    6a73:	48 01 d0             	add    %rdx,%rax
    6a76:	0f b6 00             	movzbl (%rax),%eax
    6a79:	89 cb                	mov    %ecx,%ebx
    6a7b:	31 c3                	xor    %eax,%ebx
    6a7d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6a81:	48 8b 00             	mov    (%rax),%rax
    6a84:	48 83 c0 18          	add    $0x18,%rax
    6a88:	48 8b 10             	mov    (%rax),%rdx
    6a8b:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6a8e:	48 98                	cltq   
    6a90:	48 01 d0             	add    %rdx,%rax
    6a93:	0f b6 00             	movzbl (%rax),%eax
    6a96:	0f b6 c0             	movzbl %al,%eax
    6a99:	be 02 00 00 00       	mov    $0x2,%esi
    6a9e:	89 c7                	mov    %eax,%edi
    6aa0:	e8 72 06 00 00       	call   7117 <galoisMultiply>
    6aa5:	31 d8                	xor    %ebx,%eax
    6aa7:	88 45 e7             	mov    %al,-0x19(%rbp)
		for(r = 0; r < 4; r++){
    6aaa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    6ab1:	eb 2e                	jmp    6ae1 <MixColumns+0x28f>
			state[0][r][c] = temp[r];
    6ab3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6ab7:	48 8b 10             	mov    (%rax),%rdx
    6aba:	8b 45 e0             	mov    -0x20(%rbp),%eax
    6abd:	48 98                	cltq   
    6abf:	48 c1 e0 03          	shl    $0x3,%rax
    6ac3:	48 01 d0             	add    %rdx,%rax
    6ac6:	48 8b 10             	mov    (%rax),%rdx
    6ac9:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6acc:	48 98                	cltq   
    6ace:	48 01 c2             	add    %rax,%rdx
    6ad1:	8b 45 e0             	mov    -0x20(%rbp),%eax
    6ad4:	48 98                	cltq   
    6ad6:	0f b6 44 05 e4       	movzbl -0x1c(%rbp,%rax,1),%eax
    6adb:	88 02                	mov    %al,(%rdx)
		for(r = 0; r < 4; r++){
    6add:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
    6ae1:	83 7d e0 03          	cmpl   $0x3,-0x20(%rbp)
    6ae5:	7e cc                	jle    6ab3 <MixColumns+0x261>
	for(c = 0; c < 4; c++){
    6ae7:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
    6aeb:	83 7d dc 03          	cmpl   $0x3,-0x24(%rbp)
    6aef:	0f 8e 89 fd ff ff    	jle    687e <MixColumns+0x2c>
		}
	}
}
    6af5:	90                   	nop
    6af6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6afa:	64 48 2b 04 25 28 00 	sub    %fs:0x28,%rax
    6b01:	00 00 
    6b03:	74 05                	je     6b0a <MixColumns+0x2b8>
    6b05:	e8 76 b5 ff ff       	call   2080 <__stack_chk_fail@plt>
    6b0a:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    6b0e:	c9                   	leave  
    6b0f:	c3                   	ret    

0000000000006b10 <InvMixColumns>:

void InvMixColumns(uint8_t ***state){
    6b10:	f3 0f 1e fa          	endbr64 
    6b14:	55                   	push   %rbp
    6b15:	48 89 e5             	mov    %rsp,%rbp
    6b18:	53                   	push   %rbx
    6b19:	48 83 ec 38          	sub    $0x38,%rsp
    6b1d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    6b21:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6b28:	00 00 
    6b2a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    6b2e:	31 c0                	xor    %eax,%eax
	int c, r;
	for(c = 0; c < 4; c++){
    6b30:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
    6b37:	e9 dd 02 00 00       	jmp    6e19 <InvMixColumns+0x309>
		uint8_t temp[4];
		temp[0] = galoisMultiply(state[0][0][c], 14) ^ galoisMultiply(state[0][1][c], 11) ^ galoisMultiply(state[0][2][c], 13) ^ galoisMultiply(state[0][3][c], 9);
    6b3c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6b40:	48 8b 00             	mov    (%rax),%rax
    6b43:	48 8b 10             	mov    (%rax),%rdx
    6b46:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6b49:	48 98                	cltq   
    6b4b:	48 01 d0             	add    %rdx,%rax
    6b4e:	0f b6 00             	movzbl (%rax),%eax
    6b51:	0f b6 c0             	movzbl %al,%eax
    6b54:	be 0e 00 00 00       	mov    $0xe,%esi
    6b59:	89 c7                	mov    %eax,%edi
    6b5b:	e8 b7 05 00 00       	call   7117 <galoisMultiply>
    6b60:	89 c3                	mov    %eax,%ebx
    6b62:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6b66:	48 8b 00             	mov    (%rax),%rax
    6b69:	48 83 c0 08          	add    $0x8,%rax
    6b6d:	48 8b 10             	mov    (%rax),%rdx
    6b70:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6b73:	48 98                	cltq   
    6b75:	48 01 d0             	add    %rdx,%rax
    6b78:	0f b6 00             	movzbl (%rax),%eax
    6b7b:	0f b6 c0             	movzbl %al,%eax
    6b7e:	be 0b 00 00 00       	mov    $0xb,%esi
    6b83:	89 c7                	mov    %eax,%edi
    6b85:	e8 8d 05 00 00       	call   7117 <galoisMultiply>
    6b8a:	31 c3                	xor    %eax,%ebx
    6b8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6b90:	48 8b 00             	mov    (%rax),%rax
    6b93:	48 83 c0 10          	add    $0x10,%rax
    6b97:	48 8b 10             	mov    (%rax),%rdx
    6b9a:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6b9d:	48 98                	cltq   
    6b9f:	48 01 d0             	add    %rdx,%rax
    6ba2:	0f b6 00             	movzbl (%rax),%eax
    6ba5:	0f b6 c0             	movzbl %al,%eax
    6ba8:	be 0d 00 00 00       	mov    $0xd,%esi
    6bad:	89 c7                	mov    %eax,%edi
    6baf:	e8 63 05 00 00       	call   7117 <galoisMultiply>
    6bb4:	31 c3                	xor    %eax,%ebx
    6bb6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6bba:	48 8b 00             	mov    (%rax),%rax
    6bbd:	48 83 c0 18          	add    $0x18,%rax
    6bc1:	48 8b 10             	mov    (%rax),%rdx
    6bc4:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6bc7:	48 98                	cltq   
    6bc9:	48 01 d0             	add    %rdx,%rax
    6bcc:	0f b6 00             	movzbl (%rax),%eax
    6bcf:	0f b6 c0             	movzbl %al,%eax
    6bd2:	be 09 00 00 00       	mov    $0x9,%esi
    6bd7:	89 c7                	mov    %eax,%edi
    6bd9:	e8 39 05 00 00       	call   7117 <galoisMultiply>
    6bde:	31 d8                	xor    %ebx,%eax
    6be0:	88 45 e4             	mov    %al,-0x1c(%rbp)
		temp[1] = galoisMultiply(state[0][0][c], 9)  ^ galoisMultiply(state[0][1][c], 14) ^ galoisMultiply(state[0][2][c], 11) ^ galoisMultiply(state[0][3][c], 13);
    6be3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6be7:	48 8b 00             	mov    (%rax),%rax
    6bea:	48 8b 10             	mov    (%rax),%rdx
    6bed:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6bf0:	48 98                	cltq   
    6bf2:	48 01 d0             	add    %rdx,%rax
    6bf5:	0f b6 00             	movzbl (%rax),%eax
    6bf8:	0f b6 c0             	movzbl %al,%eax
    6bfb:	be 09 00 00 00       	mov    $0x9,%esi
    6c00:	89 c7                	mov    %eax,%edi
    6c02:	e8 10 05 00 00       	call   7117 <galoisMultiply>
    6c07:	89 c3                	mov    %eax,%ebx
    6c09:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6c0d:	48 8b 00             	mov    (%rax),%rax
    6c10:	48 83 c0 08          	add    $0x8,%rax
    6c14:	48 8b 10             	mov    (%rax),%rdx
    6c17:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6c1a:	48 98                	cltq   
    6c1c:	48 01 d0             	add    %rdx,%rax
    6c1f:	0f b6 00             	movzbl (%rax),%eax
    6c22:	0f b6 c0             	movzbl %al,%eax
    6c25:	be 0e 00 00 00       	mov    $0xe,%esi
    6c2a:	89 c7                	mov    %eax,%edi
    6c2c:	e8 e6 04 00 00       	call   7117 <galoisMultiply>
    6c31:	31 c3                	xor    %eax,%ebx
    6c33:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6c37:	48 8b 00             	mov    (%rax),%rax
    6c3a:	48 83 c0 10          	add    $0x10,%rax
    6c3e:	48 8b 10             	mov    (%rax),%rdx
    6c41:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6c44:	48 98                	cltq   
    6c46:	48 01 d0             	add    %rdx,%rax
    6c49:	0f b6 00             	movzbl (%rax),%eax
    6c4c:	0f b6 c0             	movzbl %al,%eax
    6c4f:	be 0b 00 00 00       	mov    $0xb,%esi
    6c54:	89 c7                	mov    %eax,%edi
    6c56:	e8 bc 04 00 00       	call   7117 <galoisMultiply>
    6c5b:	31 c3                	xor    %eax,%ebx
    6c5d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6c61:	48 8b 00             	mov    (%rax),%rax
    6c64:	48 83 c0 18          	add    $0x18,%rax
    6c68:	48 8b 10             	mov    (%rax),%rdx
    6c6b:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6c6e:	48 98                	cltq   
    6c70:	48 01 d0             	add    %rdx,%rax
    6c73:	0f b6 00             	movzbl (%rax),%eax
    6c76:	0f b6 c0             	movzbl %al,%eax
    6c79:	be 0d 00 00 00       	mov    $0xd,%esi
    6c7e:	89 c7                	mov    %eax,%edi
    6c80:	e8 92 04 00 00       	call   7117 <galoisMultiply>
    6c85:	31 d8                	xor    %ebx,%eax
    6c87:	88 45 e5             	mov    %al,-0x1b(%rbp)
		temp[2] = galoisMultiply(state[0][0][c], 13) ^ galoisMultiply(state[0][1][c], 9)  ^ galoisMultiply(state[0][2][c], 14) ^ galoisMultiply(state[0][3][c], 11);
    6c8a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6c8e:	48 8b 00             	mov    (%rax),%rax
    6c91:	48 8b 10             	mov    (%rax),%rdx
    6c94:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6c97:	48 98                	cltq   
    6c99:	48 01 d0             	add    %rdx,%rax
    6c9c:	0f b6 00             	movzbl (%rax),%eax
    6c9f:	0f b6 c0             	movzbl %al,%eax
    6ca2:	be 0d 00 00 00       	mov    $0xd,%esi
    6ca7:	89 c7                	mov    %eax,%edi
    6ca9:	e8 69 04 00 00       	call   7117 <galoisMultiply>
    6cae:	89 c3                	mov    %eax,%ebx
    6cb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6cb4:	48 8b 00             	mov    (%rax),%rax
    6cb7:	48 83 c0 08          	add    $0x8,%rax
    6cbb:	48 8b 10             	mov    (%rax),%rdx
    6cbe:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6cc1:	48 98                	cltq   
    6cc3:	48 01 d0             	add    %rdx,%rax
    6cc6:	0f b6 00             	movzbl (%rax),%eax
    6cc9:	0f b6 c0             	movzbl %al,%eax
    6ccc:	be 09 00 00 00       	mov    $0x9,%esi
    6cd1:	89 c7                	mov    %eax,%edi
    6cd3:	e8 3f 04 00 00       	call   7117 <galoisMultiply>
    6cd8:	31 c3                	xor    %eax,%ebx
    6cda:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6cde:	48 8b 00             	mov    (%rax),%rax
    6ce1:	48 83 c0 10          	add    $0x10,%rax
    6ce5:	48 8b 10             	mov    (%rax),%rdx
    6ce8:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6ceb:	48 98                	cltq   
    6ced:	48 01 d0             	add    %rdx,%rax
    6cf0:	0f b6 00             	movzbl (%rax),%eax
    6cf3:	0f b6 c0             	movzbl %al,%eax
    6cf6:	be 0e 00 00 00       	mov    $0xe,%esi
    6cfb:	89 c7                	mov    %eax,%edi
    6cfd:	e8 15 04 00 00       	call   7117 <galoisMultiply>
    6d02:	31 c3                	xor    %eax,%ebx
    6d04:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6d08:	48 8b 00             	mov    (%rax),%rax
    6d0b:	48 83 c0 18          	add    $0x18,%rax
    6d0f:	48 8b 10             	mov    (%rax),%rdx
    6d12:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6d15:	48 98                	cltq   
    6d17:	48 01 d0             	add    %rdx,%rax
    6d1a:	0f b6 00             	movzbl (%rax),%eax
    6d1d:	0f b6 c0             	movzbl %al,%eax
    6d20:	be 0b 00 00 00       	mov    $0xb,%esi
    6d25:	89 c7                	mov    %eax,%edi
    6d27:	e8 eb 03 00 00       	call   7117 <galoisMultiply>
    6d2c:	31 d8                	xor    %ebx,%eax
    6d2e:	88 45 e6             	mov    %al,-0x1a(%rbp)
		temp[3] = galoisMultiply(state[0][0][c], 11) ^ galoisMultiply(state[0][1][c], 13) ^ galoisMultiply(state[0][2][c], 9)  ^ galoisMultiply(state[0][3][c], 14);
    6d31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6d35:	48 8b 00             	mov    (%rax),%rax
    6d38:	48 8b 10             	mov    (%rax),%rdx
    6d3b:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6d3e:	48 98                	cltq   
    6d40:	48 01 d0             	add    %rdx,%rax
    6d43:	0f b6 00             	movzbl (%rax),%eax
    6d46:	0f b6 c0             	movzbl %al,%eax
    6d49:	be 0b 00 00 00       	mov    $0xb,%esi
    6d4e:	89 c7                	mov    %eax,%edi
    6d50:	e8 c2 03 00 00       	call   7117 <galoisMultiply>
    6d55:	89 c3                	mov    %eax,%ebx
    6d57:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6d5b:	48 8b 00             	mov    (%rax),%rax
    6d5e:	48 83 c0 08          	add    $0x8,%rax
    6d62:	48 8b 10             	mov    (%rax),%rdx
    6d65:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6d68:	48 98                	cltq   
    6d6a:	48 01 d0             	add    %rdx,%rax
    6d6d:	0f b6 00             	movzbl (%rax),%eax
    6d70:	0f b6 c0             	movzbl %al,%eax
    6d73:	be 0d 00 00 00       	mov    $0xd,%esi
    6d78:	89 c7                	mov    %eax,%edi
    6d7a:	e8 98 03 00 00       	call   7117 <galoisMultiply>
    6d7f:	31 c3                	xor    %eax,%ebx
    6d81:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6d85:	48 8b 00             	mov    (%rax),%rax
    6d88:	48 83 c0 10          	add    $0x10,%rax
    6d8c:	48 8b 10             	mov    (%rax),%rdx
    6d8f:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6d92:	48 98                	cltq   
    6d94:	48 01 d0             	add    %rdx,%rax
    6d97:	0f b6 00             	movzbl (%rax),%eax
    6d9a:	0f b6 c0             	movzbl %al,%eax
    6d9d:	be 09 00 00 00       	mov    $0x9,%esi
    6da2:	89 c7                	mov    %eax,%edi
    6da4:	e8 6e 03 00 00       	call   7117 <galoisMultiply>
    6da9:	31 c3                	xor    %eax,%ebx
    6dab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6daf:	48 8b 00             	mov    (%rax),%rax
    6db2:	48 83 c0 18          	add    $0x18,%rax
    6db6:	48 8b 10             	mov    (%rax),%rdx
    6db9:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6dbc:	48 98                	cltq   
    6dbe:	48 01 d0             	add    %rdx,%rax
    6dc1:	0f b6 00             	movzbl (%rax),%eax
    6dc4:	0f b6 c0             	movzbl %al,%eax
    6dc7:	be 0e 00 00 00       	mov    $0xe,%esi
    6dcc:	89 c7                	mov    %eax,%edi
    6dce:	e8 44 03 00 00       	call   7117 <galoisMultiply>
    6dd3:	31 d8                	xor    %ebx,%eax
    6dd5:	88 45 e7             	mov    %al,-0x19(%rbp)
		for(r = 0; r < 4; r++){
    6dd8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    6ddf:	eb 2e                	jmp    6e0f <InvMixColumns+0x2ff>
			state[0][r][c] = temp[r];
    6de1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6de5:	48 8b 10             	mov    (%rax),%rdx
    6de8:	8b 45 e0             	mov    -0x20(%rbp),%eax
    6deb:	48 98                	cltq   
    6ded:	48 c1 e0 03          	shl    $0x3,%rax
    6df1:	48 01 d0             	add    %rdx,%rax
    6df4:	48 8b 10             	mov    (%rax),%rdx
    6df7:	8b 45 dc             	mov    -0x24(%rbp),%eax
    6dfa:	48 98                	cltq   
    6dfc:	48 01 c2             	add    %rax,%rdx
    6dff:	8b 45 e0             	mov    -0x20(%rbp),%eax
    6e02:	48 98                	cltq   
    6e04:	0f b6 44 05 e4       	movzbl -0x1c(%rbp,%rax,1),%eax
    6e09:	88 02                	mov    %al,(%rdx)
		for(r = 0; r < 4; r++){
    6e0b:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
    6e0f:	83 7d e0 03          	cmpl   $0x3,-0x20(%rbp)
    6e13:	7e cc                	jle    6de1 <InvMixColumns+0x2d1>
	for(c = 0; c < 4; c++){
    6e15:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
    6e19:	83 7d dc 03          	cmpl   $0x3,-0x24(%rbp)
    6e1d:	0f 8e 19 fd ff ff    	jle    6b3c <InvMixColumns+0x2c>
		}
	}
}
    6e23:	90                   	nop
    6e24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6e28:	64 48 2b 04 25 28 00 	sub    %fs:0x28,%rax
    6e2f:	00 00 
    6e31:	74 05                	je     6e38 <InvMixColumns+0x328>
    6e33:	e8 48 b2 ff ff       	call   2080 <__stack_chk_fail@plt>
    6e38:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    6e3c:	c9                   	leave  
    6e3d:	c3                   	ret    

0000000000006e3e <getWord>:


uint8_t* getWord(uint8_t* w, int i)
{
    6e3e:	f3 0f 1e fa          	endbr64 
    6e42:	55                   	push   %rbp
    6e43:	48 89 e5             	mov    %rsp,%rbp
    6e46:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    6e4a:	89 75 f4             	mov    %esi,-0xc(%rbp)
	return &w[4*i];
    6e4d:	8b 45 f4             	mov    -0xc(%rbp),%eax
    6e50:	c1 e0 02             	shl    $0x2,%eax
    6e53:	48 63 d0             	movslq %eax,%rdx
    6e56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    6e5a:	48 01 d0             	add    %rdx,%rax
}
    6e5d:	5d                   	pop    %rbp
    6e5e:	c3                   	ret    

0000000000006e5f <AddRoundKey>:

void AddRoundKey(uint8_t ***state, uint8_t *keyCypher)
{
    6e5f:	f3 0f 1e fa          	endbr64 
    6e63:	55                   	push   %rbp
    6e64:	48 89 e5             	mov    %rsp,%rbp
    6e67:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    6e6b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int c, r;
	for(c = 0; c < 4; c++){
    6e6f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    6e76:	eb 66                	jmp    6ede <AddRoundKey+0x7f>
		for(r = 0; r < 4; r++){
    6e78:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    6e7f:	eb 53                	jmp    6ed4 <AddRoundKey+0x75>
			state[0][r][c] ^= *keyCypher;
    6e81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6e85:	48 8b 10             	mov    (%rax),%rdx
    6e88:	8b 45 fc             	mov    -0x4(%rbp),%eax
    6e8b:	48 98                	cltq   
    6e8d:	48 c1 e0 03          	shl    $0x3,%rax
    6e91:	48 01 d0             	add    %rdx,%rax
    6e94:	48 8b 10             	mov    (%rax),%rdx
    6e97:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6e9a:	48 98                	cltq   
    6e9c:	48 01 d0             	add    %rdx,%rax
    6e9f:	0f b6 08             	movzbl (%rax),%ecx
    6ea2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    6ea6:	0f b6 10             	movzbl (%rax),%edx
    6ea9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6ead:	48 8b 30             	mov    (%rax),%rsi
    6eb0:	8b 45 fc             	mov    -0x4(%rbp),%eax
    6eb3:	48 98                	cltq   
    6eb5:	48 c1 e0 03          	shl    $0x3,%rax
    6eb9:	48 01 f0             	add    %rsi,%rax
    6ebc:	48 8b 30             	mov    (%rax),%rsi
    6ebf:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6ec2:	48 98                	cltq   
    6ec4:	48 01 f0             	add    %rsi,%rax
    6ec7:	31 ca                	xor    %ecx,%edx
    6ec9:	88 10                	mov    %dl,(%rax)
			keyCypher++;
    6ecb:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
		for(r = 0; r < 4; r++){
    6ed0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    6ed4:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
    6ed8:	7e a7                	jle    6e81 <AddRoundKey+0x22>
	for(c = 0; c < 4; c++){
    6eda:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
    6ede:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
    6ee2:	7e 94                	jle    6e78 <AddRoundKey+0x19>
		}
	}
}
    6ee4:	90                   	nop
    6ee5:	90                   	nop
    6ee6:	5d                   	pop    %rbp
    6ee7:	c3                   	ret    

0000000000006ee8 <SubBytes>:

void SubBytes(uint8_t ***state){
    6ee8:	f3 0f 1e fa          	endbr64 
    6eec:	55                   	push   %rbp
    6eed:	48 89 e5             	mov    %rsp,%rbp
    6ef0:	48 83 ec 10          	sub    $0x10,%rsp
    6ef4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return(_SubBytes(state, sbox));
    6ef8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    6efc:	48 8d 35 bd 5e 00 00 	lea    0x5ebd(%rip),%rsi        # cdc0 <sbox>
    6f03:	48 89 c7             	mov    %rax,%rdi
    6f06:	e8 27 00 00 00       	call   6f32 <_SubBytes>
}
    6f0b:	c9                   	leave  
    6f0c:	c3                   	ret    

0000000000006f0d <InvSubBytes>:

void InvSubBytes(uint8_t ***state){
    6f0d:	f3 0f 1e fa          	endbr64 
    6f11:	55                   	push   %rbp
    6f12:	48 89 e5             	mov    %rsp,%rbp
    6f15:	48 83 ec 10          	sub    $0x10,%rsp
    6f19:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return(_SubBytes(state, isbox));
    6f1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    6f21:	48 8d 35 98 5f 00 00 	lea    0x5f98(%rip),%rsi        # cec0 <isbox>
    6f28:	48 89 c7             	mov    %rax,%rdi
    6f2b:	e8 02 00 00 00       	call   6f32 <_SubBytes>
}
    6f30:	c9                   	leave  
    6f31:	c3                   	ret    

0000000000006f32 <_SubBytes>:

void _SubBytes(uint8_t ***state, const uint8_t* box){
    6f32:	f3 0f 1e fa          	endbr64 
    6f36:	55                   	push   %rbp
    6f37:	48 89 e5             	mov    %rsp,%rbp
    6f3a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    6f3e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i, j;
	uint8_t new;
	for(i = 0; i < 4; i++){
    6f42:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    6f49:	eb 6c                	jmp    6fb7 <_SubBytes+0x85>
		for(j = 0; j < 4; j++){
    6f4b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    6f52:	eb 59                	jmp    6fad <_SubBytes+0x7b>
			new = box[state[0][i][j]];
    6f54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6f58:	48 8b 10             	mov    (%rax),%rdx
    6f5b:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6f5e:	48 98                	cltq   
    6f60:	48 c1 e0 03          	shl    $0x3,%rax
    6f64:	48 01 d0             	add    %rdx,%rax
    6f67:	48 8b 10             	mov    (%rax),%rdx
    6f6a:	8b 45 fc             	mov    -0x4(%rbp),%eax
    6f6d:	48 98                	cltq   
    6f6f:	48 01 d0             	add    %rdx,%rax
    6f72:	0f b6 00             	movzbl (%rax),%eax
    6f75:	0f b6 d0             	movzbl %al,%edx
    6f78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    6f7c:	48 01 d0             	add    %rdx,%rax
    6f7f:	0f b6 00             	movzbl (%rax),%eax
    6f82:	88 45 f7             	mov    %al,-0x9(%rbp)
			state[0][i][j] = new;
    6f85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    6f89:	48 8b 10             	mov    (%rax),%rdx
    6f8c:	8b 45 f8             	mov    -0x8(%rbp),%eax
    6f8f:	48 98                	cltq   
    6f91:	48 c1 e0 03          	shl    $0x3,%rax
    6f95:	48 01 d0             	add    %rdx,%rax
    6f98:	48 8b 10             	mov    (%rax),%rdx
    6f9b:	8b 45 fc             	mov    -0x4(%rbp),%eax
    6f9e:	48 98                	cltq   
    6fa0:	48 01 c2             	add    %rax,%rdx
    6fa3:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
    6fa7:	88 02                	mov    %al,(%rdx)
		for(j = 0; j < 4; j++){
    6fa9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    6fad:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
    6fb1:	7e a1                	jle    6f54 <_SubBytes+0x22>
	for(i = 0; i < 4; i++){
    6fb3:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
    6fb7:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
    6fbb:	7e 8e                	jle    6f4b <_SubBytes+0x19>
		}
	}
}
    6fbd:	90                   	nop
    6fbe:	90                   	nop
    6fbf:	5d                   	pop    %rbp
    6fc0:	c3                   	ret    

0000000000006fc1 <_ShiftRows>:

void _ShiftRows(uint8_t ***state, int multiplier)
{
    6fc1:	f3 0f 1e fa          	endbr64 
    6fc5:	55                   	push   %rbp
    6fc6:	48 89 e5             	mov    %rsp,%rbp
    6fc9:	48 83 ec 30          	sub    $0x30,%rsp
    6fcd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    6fd1:	89 75 d4             	mov    %esi,-0x2c(%rbp)
    6fd4:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6fdb:	00 00 
    6fdd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    6fe1:	31 c0                	xor    %eax,%eax
	int i, j;
	for(i = 0; i < 4; i++){
    6fe3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    6fea:	eb 77                	jmp    7063 <_ShiftRows+0xa2>
		uint8_t temp[4];
		for(j = 0; j < 4; j++){
    6fec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
    6ff3:	eb 49                	jmp    703e <_ShiftRows+0x7d>
			temp[((j + 4) + (multiplier * i)) % 4] = state[0][i][j];
    6ff5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    6ff9:	48 8b 10             	mov    (%rax),%rdx
    6ffc:	8b 45 ec             	mov    -0x14(%rbp),%eax
    6fff:	48 98                	cltq   
    7001:	48 c1 e0 03          	shl    $0x3,%rax
    7005:	48 01 d0             	add    %rdx,%rax
    7008:	48 8b 10             	mov    (%rax),%rdx
    700b:	8b 45 f0             	mov    -0x10(%rbp),%eax
    700e:	48 98                	cltq   
    7010:	48 01 c2             	add    %rax,%rdx
    7013:	8b 45 f0             	mov    -0x10(%rbp),%eax
    7016:	8d 48 04             	lea    0x4(%rax),%ecx
    7019:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    701c:	0f af 45 ec          	imul   -0x14(%rbp),%eax
    7020:	01 c8                	add    %ecx,%eax
    7022:	89 c1                	mov    %eax,%ecx
    7024:	c1 f9 1f             	sar    $0x1f,%ecx
    7027:	c1 e9 1e             	shr    $0x1e,%ecx
    702a:	01 c8                	add    %ecx,%eax
    702c:	83 e0 03             	and    $0x3,%eax
    702f:	29 c8                	sub    %ecx,%eax
    7031:	0f b6 12             	movzbl (%rdx),%edx
    7034:	48 98                	cltq   
    7036:	88 54 05 f4          	mov    %dl,-0xc(%rbp,%rax,1)
		for(j = 0; j < 4; j++){
    703a:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
    703e:	83 7d f0 03          	cmpl   $0x3,-0x10(%rbp)
    7042:	7e b1                	jle    6ff5 <_ShiftRows+0x34>
		}
		memcpy(state[0][i], temp, 4);
    7044:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    7048:	48 8b 10             	mov    (%rax),%rdx
    704b:	8b 45 ec             	mov    -0x14(%rbp),%eax
    704e:	48 98                	cltq   
    7050:	48 c1 e0 03          	shl    $0x3,%rax
    7054:	48 01 d0             	add    %rdx,%rax
    7057:	48 8b 00             	mov    (%rax),%rax
    705a:	8b 55 f4             	mov    -0xc(%rbp),%edx
    705d:	89 10                	mov    %edx,(%rax)
	for(i = 0; i < 4; i++){
    705f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
    7063:	83 7d ec 03          	cmpl   $0x3,-0x14(%rbp)
    7067:	7e 83                	jle    6fec <_ShiftRows+0x2b>
	}
}
    7069:	90                   	nop
    706a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    706e:	64 48 2b 04 25 28 00 	sub    %fs:0x28,%rax
    7075:	00 00 
    7077:	74 05                	je     707e <_ShiftRows+0xbd>
    7079:	e8 02 b0 ff ff       	call   2080 <__stack_chk_fail@plt>
    707e:	c9                   	leave  
    707f:	c3                   	ret    

0000000000007080 <ShiftRows>:

void ShiftRows(uint8_t ***state)
{
    7080:	f3 0f 1e fa          	endbr64 
    7084:	55                   	push   %rbp
    7085:	48 89 e5             	mov    %rsp,%rbp
    7088:	48 83 ec 10          	sub    $0x10,%rsp
    708c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return(_ShiftRows(state, -1));
    7090:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    7094:	be ff ff ff ff       	mov    $0xffffffff,%esi
    7099:	48 89 c7             	mov    %rax,%rdi
    709c:	e8 20 ff ff ff       	call   6fc1 <_ShiftRows>
}
    70a1:	c9                   	leave  
    70a2:	c3                   	ret    

00000000000070a3 <InvShiftRows>:

void InvShiftRows(uint8_t ***state)
{
    70a3:	f3 0f 1e fa          	endbr64 
    70a7:	55                   	push   %rbp
    70a8:	48 89 e5             	mov    %rsp,%rbp
    70ab:	48 83 ec 10          	sub    $0x10,%rsp
    70af:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return(_ShiftRows(state, 1));
    70b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    70b7:	be 01 00 00 00       	mov    $0x1,%esi
    70bc:	48 89 c7             	mov    %rax,%rdi
    70bf:	e8 fd fe ff ff       	call   6fc1 <_ShiftRows>
}
    70c4:	c9                   	leave  
    70c5:	c3                   	ret    

00000000000070c6 <freeState>:

void freeState(uint8_t **state){
    70c6:	f3 0f 1e fa          	endbr64 
    70ca:	55                   	push   %rbp
    70cb:	48 89 e5             	mov    %rsp,%rbp
    70ce:	48 83 ec 20          	sub    $0x20,%rsp
    70d2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	for(i = 0; i < 4; i++)
    70d6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    70dd:	eb 23                	jmp    7102 <freeState+0x3c>
		free(state[i]);
    70df:	8b 45 fc             	mov    -0x4(%rbp),%eax
    70e2:	48 98                	cltq   
    70e4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    70eb:	00 
    70ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    70f0:	48 01 d0             	add    %rdx,%rax
    70f3:	48 8b 00             	mov    (%rax),%rax
    70f6:	48 89 c7             	mov    %rax,%rdi
    70f9:	e8 32 af ff ff       	call   2030 <free@plt>
	for(i = 0; i < 4; i++)
    70fe:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    7102:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
    7106:	7e d7                	jle    70df <freeState+0x19>
	free(state);
    7108:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    710c:	48 89 c7             	mov    %rax,%rdi
    710f:	e8 1c af ff ff       	call   2030 <free@plt>
}
    7114:	90                   	nop
    7115:	c9                   	leave  
    7116:	c3                   	ret    

0000000000007117 <galoisMultiply>:

int8_t galoisMultiply(uint8_t a, uint8_t b)
{
    7117:	f3 0f 1e fa          	endbr64 
    711b:	55                   	push   %rbp
    711c:	48 89 e5             	mov    %rsp,%rbp
    711f:	89 fa                	mov    %edi,%edx
    7121:	89 f0                	mov    %esi,%eax
    7123:	88 55 ec             	mov    %dl,-0x14(%rbp)
    7126:	88 45 e8             	mov    %al,-0x18(%rbp)
	uint8_t p = 0;
    7129:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
	int i;
	int carry;
	for(i = 0; i < 8; i++){
    712d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    7134:	eb 35                	jmp    716b <galoisMultiply+0x54>
		if((b & 1) == 1){
    7136:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
    713a:	83 e0 01             	and    $0x1,%eax
    713d:	85 c0                	test   %eax,%eax
    713f:	74 07                	je     7148 <galoisMultiply+0x31>
			p ^= a;
    7141:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
    7145:	30 45 f7             	xor    %al,-0x9(%rbp)
		}
		b >>= 1;
    7148:	d0 6d e8             	shrb   -0x18(%rbp)
		carry = a & 0x80;
    714b:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
    714f:	25 80 00 00 00       	and    $0x80,%eax
    7154:	89 45 fc             	mov    %eax,-0x4(%rbp)
		a <<= 1;
    7157:	d0 65 ec             	shlb   -0x14(%rbp)
		if(carry == 0x80){
    715a:	81 7d fc 80 00 00 00 	cmpl   $0x80,-0x4(%rbp)
    7161:	75 04                	jne    7167 <galoisMultiply+0x50>
			a ^= 0x1b;
    7163:	80 75 ec 1b          	xorb   $0x1b,-0x14(%rbp)
	for(i = 0; i < 8; i++){
    7167:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
    716b:	83 7d f8 07          	cmpl   $0x7,-0x8(%rbp)
    716f:	7e c5                	jle    7136 <galoisMultiply+0x1f>
		}
	}
	return p;
    7171:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
    7175:	5d                   	pop    %rbp
    7176:	c3                   	ret    

0000000000007177 <stringToBytes>:

void stringToBytes(char* str, uint8_t* bytes)
{
    7177:	f3 0f 1e fa          	endbr64 
    717b:	55                   	push   %rbp
    717c:	48 89 e5             	mov    %rsp,%rbp
    717f:	48 83 ec 30          	sub    $0x30,%rsp
    7183:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    7187:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    718b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    7192:	00 00 
    7194:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    7198:	31 c0                	xor    %eax,%eax
	char pair[3];
	for(size_t i = 0; i < strlen(str) - 1; i += 2){
    719a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    71a1:	00 
    71a2:	eb 5b                	jmp    71ff <stringToBytes+0x88>
		pair[0] = str[i];
    71a4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    71a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    71ac:	48 01 d0             	add    %rdx,%rax
    71af:	0f b6 00             	movzbl (%rax),%eax
    71b2:	88 45 f5             	mov    %al,-0xb(%rbp)
		pair[1] = str[i + 1];
    71b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    71b9:	48 8d 50 01          	lea    0x1(%rax),%rdx
    71bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    71c1:	48 01 d0             	add    %rdx,%rax
    71c4:	0f b6 00             	movzbl (%rax),%eax
    71c7:	88 45 f6             	mov    %al,-0xa(%rbp)
		pair[2] = '\0';
    71ca:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
		bytes[i/2] = strtol(pair, NULL, 16);
    71ce:	48 8d 45 f5          	lea    -0xb(%rbp),%rax
    71d2:	ba 10 00 00 00       	mov    $0x10,%edx
    71d7:	be 00 00 00 00       	mov    $0x0,%esi
    71dc:	48 89 c7             	mov    %rax,%rdi
    71df:	e8 2c af ff ff       	call   2110 <strtol@plt>
    71e4:	48 89 c2             	mov    %rax,%rdx
    71e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    71eb:	48 d1 e8             	shr    %rax
    71ee:	48 89 c1             	mov    %rax,%rcx
    71f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    71f5:	48 01 c8             	add    %rcx,%rax
    71f8:	88 10                	mov    %dl,(%rax)
	for(size_t i = 0; i < strlen(str) - 1; i += 2){
    71fa:	48 83 45 e8 02       	addq   $0x2,-0x18(%rbp)
    71ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    7203:	48 89 c7             	mov    %rax,%rdi
    7206:	e8 65 ae ff ff       	call   2070 <strlen@plt>
    720b:	48 83 e8 01          	sub    $0x1,%rax
    720f:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
    7213:	72 8f                	jb     71a4 <stringToBytes+0x2d>
	}
}
    7215:	90                   	nop
    7216:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    721a:	64 48 2b 04 25 28 00 	sub    %fs:0x28,%rax
    7221:	00 00 
    7223:	74 05                	je     722a <stringToBytes+0xb3>
    7225:	e8 56 ae ff ff       	call   2080 <__stack_chk_fail@plt>
    722a:	c9                   	leave  
    722b:	c3                   	ret    

000000000000722c <toState>:

uint8_t ***toState(uint8_t* input)
{
    722c:	f3 0f 1e fa          	endbr64 
    7230:	55                   	push   %rbp
    7231:	48 89 e5             	mov    %rsp,%rbp
    7234:	53                   	push   %rbx
    7235:	48 83 ec 38          	sub    $0x38,%rsp
    7239:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int i, j;
	uint8_t *** stateptr = malloc(sizeof(uint8_t **));
    723d:	bf 08 00 00 00       	mov    $0x8,%edi
    7242:	e8 d9 ae ff ff       	call   2120 <malloc@plt>
    7247:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	*stateptr = malloc(4 * sizeof(uint8_t*));
    724b:	bf 20 00 00 00       	mov    $0x20,%edi
    7250:	e8 cb ae ff ff       	call   2120 <malloc@plt>
    7255:	48 89 c2             	mov    %rax,%rdx
    7258:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    725c:	48 89 10             	mov    %rdx,(%rax)
	uint8_t ** state = *stateptr;
    725f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    7263:	48 8b 00             	mov    (%rax),%rax
    7266:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for(i = 0; i < 4; i++){
    726a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
    7271:	eb 26                	jmp    7299 <toState+0x6d>
		state[i] = malloc(4 * sizeof(uint8_t));
    7273:	8b 45 d8             	mov    -0x28(%rbp),%eax
    7276:	48 98                	cltq   
    7278:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    727f:	00 
    7280:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    7284:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
    7288:	bf 04 00 00 00       	mov    $0x4,%edi
    728d:	e8 8e ae ff ff       	call   2120 <malloc@plt>
    7292:	48 89 03             	mov    %rax,(%rbx)
	for(i = 0; i < 4; i++){
    7295:	83 45 d8 01          	addl   $0x1,-0x28(%rbp)
    7299:	83 7d d8 03          	cmpl   $0x3,-0x28(%rbp)
    729d:	7e d4                	jle    7273 <toState+0x47>
	}
	for(i = 0; i < 4; i++){
    729f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
    72a6:	eb 44                	jmp    72ec <toState+0xc0>
		for(j = 0; j < 4; j++){
    72a8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
    72af:	eb 31                	jmp    72e2 <toState+0xb6>
			state[j][i] = *input;
    72b1:	8b 45 dc             	mov    -0x24(%rbp),%eax
    72b4:	48 98                	cltq   
    72b6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    72bd:	00 
    72be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    72c2:	48 01 d0             	add    %rdx,%rax
    72c5:	48 8b 10             	mov    (%rax),%rdx
    72c8:	8b 45 d8             	mov    -0x28(%rbp),%eax
    72cb:	48 98                	cltq   
    72cd:	48 01 c2             	add    %rax,%rdx
    72d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    72d4:	0f b6 00             	movzbl (%rax),%eax
    72d7:	88 02                	mov    %al,(%rdx)
			input++;
    72d9:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
		for(j = 0; j < 4; j++){
    72de:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
    72e2:	83 7d dc 03          	cmpl   $0x3,-0x24(%rbp)
    72e6:	7e c9                	jle    72b1 <toState+0x85>
	for(i = 0; i < 4; i++){
    72e8:	83 45 d8 01          	addl   $0x1,-0x28(%rbp)
    72ec:	83 7d d8 03          	cmpl   $0x3,-0x28(%rbp)
    72f0:	7e b6                	jle    72a8 <toState+0x7c>
		}
	}
	return stateptr;
    72f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
    72f6:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    72fa:	c9                   	leave  
    72fb:	c3                   	ret    

00000000000072fc <fromState>:

uint8_t** fromState(uint8_t ***state)
{
    72fc:	f3 0f 1e fa          	endbr64 
    7300:	55                   	push   %rbp
    7301:	48 89 e5             	mov    %rsp,%rbp
    7304:	48 83 ec 30          	sub    $0x30,%rsp
    7308:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int i, j;
	uint8_t** outputptr = calloc(1, sizeof(uint8_t*));
    730c:	be 08 00 00 00       	mov    $0x8,%esi
    7311:	bf 01 00 00 00       	mov    $0x1,%edi
    7316:	e8 d5 ad ff ff       	call   20f0 <calloc@plt>
    731b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	*outputptr = calloc(1, sizeof(uint8_t) * 17);
    731f:	be 11 00 00 00       	mov    $0x11,%esi
    7324:	bf 01 00 00 00       	mov    $0x1,%edi
    7329:	e8 c2 ad ff ff       	call   20f0 <calloc@plt>
    732e:	48 89 c2             	mov    %rax,%rdx
    7331:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    7335:	48 89 10             	mov    %rdx,(%rax)
	uint8_t* output = *outputptr;
    7338:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    733c:	48 8b 00             	mov    (%rax),%rax
    733f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for(i = 0; i < 4; i++){
    7343:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    734a:	eb 43                	jmp    738f <fromState+0x93>
		for(j = 0; j < 4; j++){
    734c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    7353:	eb 30                	jmp    7385 <fromState+0x89>
			*output = (*state)[j][i];
    7355:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    7359:	48 8b 10             	mov    (%rax),%rdx
    735c:	8b 45 ec             	mov    -0x14(%rbp),%eax
    735f:	48 98                	cltq   
    7361:	48 c1 e0 03          	shl    $0x3,%rax
    7365:	48 01 d0             	add    %rdx,%rax
    7368:	48 8b 10             	mov    (%rax),%rdx
    736b:	8b 45 e8             	mov    -0x18(%rbp),%eax
    736e:	48 98                	cltq   
    7370:	48 01 d0             	add    %rdx,%rax
    7373:	0f b6 10             	movzbl (%rax),%edx
    7376:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    737a:	88 10                	mov    %dl,(%rax)
			output++;
    737c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
		for(j = 0; j < 4; j++){
    7381:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
    7385:	83 7d ec 03          	cmpl   $0x3,-0x14(%rbp)
    7389:	7e ca                	jle    7355 <fromState+0x59>
	for(i = 0; i < 4; i++){
    738b:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
    738f:	83 7d e8 03          	cmpl   $0x3,-0x18(%rbp)
    7393:	7e b7                	jle    734c <fromState+0x50>
		}
	}

	return outputptr;
    7395:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    7399:	c9                   	leave  
    739a:	c3                   	ret    

000000000000739b <Rcon>:

static uint8_t* Rcon(int a)
{
    739b:	f3 0f 1e fa          	endbr64 
    739f:	55                   	push   %rbp
    73a0:	48 89 e5             	mov    %rsp,%rbp
    73a3:	48 83 ec 20          	sub    $0x20,%rsp
    73a7:	89 7d ec             	mov    %edi,-0x14(%rbp)
	uint8_t rcon = 0x8d;
    73aa:	c6 45 f3 8d          	movb   $0x8d,-0xd(%rbp)
	int i;
	for(i = 0; i < a; i++){
    73ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    73b5:	eb 1b                	jmp    73d2 <Rcon+0x37>
		rcon = ((rcon << 1) ^ (0x11b & - (rcon >> 7)));
    73b7:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
    73bb:	01 c0                	add    %eax,%eax
    73bd:	89 c2                	mov    %eax,%edx
    73bf:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
    73c3:	c0 f8 07             	sar    $0x7,%al
    73c6:	83 e0 1b             	and    $0x1b,%eax
    73c9:	31 d0                	xor    %edx,%eax
    73cb:	88 45 f3             	mov    %al,-0xd(%rbp)
	for(i = 0; i < a; i++){
    73ce:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
    73d2:	8b 45 f4             	mov    -0xc(%rbp),%eax
    73d5:	3b 45 ec             	cmp    -0x14(%rbp),%eax
    73d8:	7c dd                	jl     73b7 <Rcon+0x1c>
	}
	uint8_t* word = calloc(4, sizeof(uint8_t));
    73da:	be 01 00 00 00       	mov    $0x1,%esi
    73df:	bf 04 00 00 00       	mov    $0x4,%edi
    73e4:	e8 07 ad ff ff       	call   20f0 <calloc@plt>
    73e9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	word[0] = rcon;
    73ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    73f1:	0f b6 55 f3          	movzbl -0xd(%rbp),%edx
    73f5:	88 10                	mov    %dl,(%rax)
	return word;
    73f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    73fb:	c9                   	leave  
    73fc:	c3                   	ret    

00000000000073fd <xorWords>:

static uint8_t* xorWords(uint8_t* a, uint8_t* b)
{
    73fd:	f3 0f 1e fa          	endbr64 
    7401:	55                   	push   %rbp
    7402:	48 89 e5             	mov    %rsp,%rbp
    7405:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    7409:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	uint8_t* init = a;
    740d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    7411:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for(i = 0; i < 4; i++, a++, b++){
    7415:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    741c:	eb 24                	jmp    7442 <xorWords+0x45>
		*a ^= *b;
    741e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    7422:	0f b6 10             	movzbl (%rax),%edx
    7425:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    7429:	0f b6 00             	movzbl (%rax),%eax
    742c:	31 c2                	xor    %eax,%edx
    742e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    7432:	88 10                	mov    %dl,(%rax)
	for(i = 0; i < 4; i++, a++, b++){
    7434:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
    7438:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
    743d:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
    7442:	83 7d f4 03          	cmpl   $0x3,-0xc(%rbp)
    7446:	7e d6                	jle    741e <xorWords+0x21>
	}
	return init;
    7448:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    744c:	5d                   	pop    %rbp
    744d:	c3                   	ret    

000000000000744e <copyWord>:

static uint8_t* copyWord(uint8_t* start)
{
    744e:	f3 0f 1e fa          	endbr64 
    7452:	55                   	push   %rbp
    7453:	48 89 e5             	mov    %rsp,%rbp
    7456:	48 83 ec 20          	sub    $0x20,%rsp
    745a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	uint8_t* word = calloc(1, sizeof(uint8_t) * 5);
    745e:	be 05 00 00 00       	mov    $0x5,%esi
    7463:	bf 01 00 00 00       	mov    $0x1,%edi
    7468:	e8 83 ac ff ff       	call   20f0 <calloc@plt>
    746d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for(i = 0; i < 4; i++, start++){
    7471:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    7478:	eb 1f                	jmp    7499 <copyWord+0x4b>
		word[i] = *start;
    747a:	8b 45 f4             	mov    -0xc(%rbp),%eax
    747d:	48 63 d0             	movslq %eax,%rdx
    7480:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    7484:	48 01 c2             	add    %rax,%rdx
    7487:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    748b:	0f b6 00             	movzbl (%rax),%eax
    748e:	88 02                	mov    %al,(%rdx)
	for(i = 0; i < 4; i++, start++){
    7490:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
    7494:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
    7499:	83 7d f4 03          	cmpl   $0x3,-0xc(%rbp)
    749d:	7e db                	jle    747a <copyWord+0x2c>
	}
	return word;
    749f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    74a3:	c9                   	leave  
    74a4:	c3                   	ret    

00000000000074a5 <SubWord>:

static uint8_t* SubWord(uint8_t* a)
{
    74a5:	f3 0f 1e fa          	endbr64 
    74a9:	55                   	push   %rbp
    74aa:	48 89 e5             	mov    %rsp,%rbp
    74ad:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	uint8_t* init = a;
    74b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    74b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for(i = 0; i < 4; i++){
    74b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    74c0:	eb 26                	jmp    74e8 <SubWord+0x43>
		*a = sbox[*a];
    74c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    74c6:	0f b6 00             	movzbl (%rax),%eax
    74c9:	0f b6 c0             	movzbl %al,%eax
    74cc:	48 98                	cltq   
    74ce:	48 8d 15 eb 58 00 00 	lea    0x58eb(%rip),%rdx        # cdc0 <sbox>
    74d5:	0f b6 14 10          	movzbl (%rax,%rdx,1),%edx
    74d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    74dd:	88 10                	mov    %dl,(%rax)
		a++;
    74df:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for(i = 0; i < 4; i++){
    74e4:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
    74e8:	83 7d f4 03          	cmpl   $0x3,-0xc(%rbp)
    74ec:	7e d4                	jle    74c2 <SubWord+0x1d>
	}
	return init;
    74ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
    74f2:	5d                   	pop    %rbp
    74f3:	c3                   	ret    

00000000000074f4 <RotWord>:

static uint8_t* RotWord(uint8_t* a)
{
    74f4:	f3 0f 1e fa          	endbr64 
    74f8:	55                   	push   %rbp
    74f9:	48 89 e5             	mov    %rsp,%rbp
    74fc:	48 83 ec 20          	sub    $0x20,%rsp
    7500:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    7504:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    750b:	00 00 
    750d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    7511:	31 c0                	xor    %eax,%eax
	uint8_t rot[] = {a[1], a[2], a[3], a[0]};
    7513:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    7517:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    751b:	88 45 f4             	mov    %al,-0xc(%rbp)
    751e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    7522:	0f b6 40 02          	movzbl 0x2(%rax),%eax
    7526:	88 45 f5             	mov    %al,-0xb(%rbp)
    7529:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    752d:	0f b6 40 03          	movzbl 0x3(%rax),%eax
    7531:	88 45 f6             	mov    %al,-0xa(%rbp)
    7534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    7538:	0f b6 00             	movzbl (%rax),%eax
    753b:	88 45 f7             	mov    %al,-0x9(%rbp)
    753e:	8b 55 f4             	mov    -0xc(%rbp),%edx
	memcpy(a, rot, 4);
    7541:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    7545:	89 10                	mov    %edx,(%rax)
	return a;
    7547:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
    754b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    754f:	64 48 2b 0c 25 28 00 	sub    %fs:0x28,%rcx
    7556:	00 00 
    7558:	74 05                	je     755f <RotWord+0x6b>
    755a:	e8 21 ab ff ff       	call   2080 <__stack_chk_fail@plt>
    755f:	c9                   	leave  
    7560:	c3                   	ret    

0000000000007561 <get_key_schedule>:

void get_key_schedule(uint8_t* key, uint8_t* key_schedule){
    7561:	f3 0f 1e fa          	endbr64 
    7565:	55                   	push   %rbp
    7566:	48 89 e5             	mov    %rsp,%rbp
    7569:	48 83 ec 40          	sub    $0x40,%rsp
    756d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    7571:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	int i, j;
	uint8_t *wi, *wk, *temp, *rconval;
	for(i = 0; i < 8; i++){
    7575:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
    757c:	eb 4e                	jmp    75cc <get_key_schedule+0x6b>
		for(j = 0; j < 4; j++){
    757e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
    7585:	eb 3b                	jmp    75c2 <get_key_schedule+0x61>
			key_schedule[4*i+j] = key[4*i+j];
    7587:	8b 45 d8             	mov    -0x28(%rbp),%eax
    758a:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
    7591:	8b 45 dc             	mov    -0x24(%rbp),%eax
    7594:	01 d0                	add    %edx,%eax
    7596:	48 63 d0             	movslq %eax,%rdx
    7599:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    759d:	48 01 d0             	add    %rdx,%rax
    75a0:	8b 55 d8             	mov    -0x28(%rbp),%edx
    75a3:	8d 0c 95 00 00 00 00 	lea    0x0(,%rdx,4),%ecx
    75aa:	8b 55 dc             	mov    -0x24(%rbp),%edx
    75ad:	01 ca                	add    %ecx,%edx
    75af:	48 63 ca             	movslq %edx,%rcx
    75b2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
    75b6:	48 01 ca             	add    %rcx,%rdx
    75b9:	0f b6 00             	movzbl (%rax),%eax
    75bc:	88 02                	mov    %al,(%rdx)
		for(j = 0; j < 4; j++){
    75be:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
    75c2:	83 7d dc 03          	cmpl   $0x3,-0x24(%rbp)
    75c6:	7e bf                	jle    7587 <get_key_schedule+0x26>
	for(i = 0; i < 8; i++){
    75c8:	83 45 d8 01          	addl   $0x1,-0x28(%rbp)
    75cc:	83 7d d8 07          	cmpl   $0x7,-0x28(%rbp)
    75d0:	7e ac                	jle    757e <get_key_schedule+0x1d>
		}
	}
	i = 8;
    75d2:	c7 45 d8 08 00 00 00 	movl   $0x8,-0x28(%rbp)
 	 while(i < 60){
    75d9:	e9 f6 00 00 00       	jmp    76d4 <get_key_schedule+0x173>
		temp = copyWord(getWord(key_schedule, i-1));
    75de:	8b 45 d8             	mov    -0x28(%rbp),%eax
    75e1:	8d 50 ff             	lea    -0x1(%rax),%edx
    75e4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    75e8:	89 d6                	mov    %edx,%esi
    75ea:	48 89 c7             	mov    %rax,%rdi
    75ed:	e8 4c f8 ff ff       	call   6e3e <getWord>
    75f2:	48 89 c7             	mov    %rax,%rdi
    75f5:	e8 54 fe ff ff       	call   744e <copyWord>
    75fa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(i % 8 == 0){
    75fe:	8b 45 d8             	mov    -0x28(%rbp),%eax
    7601:	83 e0 07             	and    $0x7,%eax
    7604:	85 c0                	test   %eax,%eax
    7606:	75 4d                	jne    7655 <get_key_schedule+0xf4>
			rconval = Rcon(i/8);
    7608:	8b 45 d8             	mov    -0x28(%rbp),%eax
    760b:	8d 50 07             	lea    0x7(%rax),%edx
    760e:	85 c0                	test   %eax,%eax
    7610:	0f 48 c2             	cmovs  %edx,%eax
    7613:	c1 f8 03             	sar    $0x3,%eax
    7616:	89 c7                	mov    %eax,%edi
    7618:	e8 7e fd ff ff       	call   739b <Rcon>
    761d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			xorWords(SubWord(RotWord(temp)), rconval);
    7621:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    7625:	48 89 c7             	mov    %rax,%rdi
    7628:	e8 c7 fe ff ff       	call   74f4 <RotWord>
    762d:	48 89 c7             	mov    %rax,%rdi
    7630:	e8 70 fe ff ff       	call   74a5 <SubWord>
    7635:	48 89 c2             	mov    %rax,%rdx
    7638:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    763c:	48 89 c6             	mov    %rax,%rsi
    763f:	48 89 d7             	mov    %rdx,%rdi
    7642:	e8 b6 fd ff ff       	call   73fd <xorWords>
			free(rconval);
    7647:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    764b:	48 89 c7             	mov    %rax,%rdi
    764e:	e8 dd a9 ff ff       	call   2030 <free@plt>
    7653:	eb 27                	jmp    767c <get_key_schedule+0x11b>
		} else if(i % 8 == 4){
    7655:	8b 45 d8             	mov    -0x28(%rbp),%eax
    7658:	99                   	cltd   
    7659:	c1 ea 1d             	shr    $0x1d,%edx
    765c:	01 d0                	add    %edx,%eax
    765e:	83 e0 07             	and    $0x7,%eax
    7661:	29 d0                	sub    %edx,%eax
    7663:	83 f8 04             	cmp    $0x4,%eax
    7666:	75 14                	jne    767c <get_key_schedule+0x11b>
			memcpy(temp, SubWord(temp), 4);
    7668:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    766c:	48 89 c7             	mov    %rax,%rdi
    766f:	e8 31 fe ff ff       	call   74a5 <SubWord>
    7674:	8b 10                	mov    (%rax),%edx
    7676:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    767a:	89 10                	mov    %edx,(%rax)
		}
		wi = getWord(key_schedule, i);
    767c:	8b 55 d8             	mov    -0x28(%rbp),%edx
    767f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    7683:	89 d6                	mov    %edx,%esi
    7685:	48 89 c7             	mov    %rax,%rdi
    7688:	e8 b1 f7 ff ff       	call   6e3e <getWord>
    768d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		wk = getWord(key_schedule, i - 8);
    7691:	8b 45 d8             	mov    -0x28(%rbp),%eax
    7694:	8d 50 f8             	lea    -0x8(%rax),%edx
    7697:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    769b:	89 d6                	mov    %edx,%esi
    769d:	48 89 c7             	mov    %rax,%rdi
    76a0:	e8 99 f7 ff ff       	call   6e3e <getWord>
    76a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		memcpy(wi, xorWords(temp, wk), 4);
    76a9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    76ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    76b1:	48 89 d6             	mov    %rdx,%rsi
    76b4:	48 89 c7             	mov    %rax,%rdi
    76b7:	e8 41 fd ff ff       	call   73fd <xorWords>
    76bc:	8b 10                	mov    (%rax),%edx
    76be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    76c2:	89 10                	mov    %edx,(%rax)
		free(temp);
    76c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    76c8:	48 89 c7             	mov    %rax,%rdi
    76cb:	e8 60 a9 ff ff       	call   2030 <free@plt>
		i++;
    76d0:	83 45 d8 01          	addl   $0x1,-0x28(%rbp)
 	 while(i < 60){
    76d4:	83 7d d8 3b          	cmpl   $0x3b,-0x28(%rbp)
    76d8:	0f 8e 00 ff ff ff    	jle    75de <get_key_schedule+0x7d>
	}
	memmove(key, key_schedule + 208, 32);
    76de:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    76e2:	48 8d 88 d0 00 00 00 	lea    0xd0(%rax),%rcx
    76e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    76ed:	ba 20 00 00 00       	mov    $0x20,%edx
    76f2:	48 89 ce             	mov    %rcx,%rsi
    76f5:	48 89 c7             	mov    %rax,%rdi
    76f8:	e8 33 aa ff ff       	call   2130 <memmove@plt>
}
    76fd:	90                   	nop
    76fe:	c9                   	leave  
    76ff:	c3                   	ret    

0000000000007700 <BytesToString>:

void BytesToString(uint8_t* bytes, char* str){
    7700:	f3 0f 1e fa          	endbr64 
    7704:	55                   	push   %rbp
    7705:	48 89 e5             	mov    %rsp,%rbp
    7708:	48 83 ec 20          	sub    $0x20,%rsp
    770c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    7710:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	for(int i = 0; i < 16; i++){
    7714:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    771b:	eb 3c                	jmp    7759 <BytesToString+0x59>
		sprintf(str + (i * 2), "%02x", bytes[i]);
    771d:	8b 45 fc             	mov    -0x4(%rbp),%eax
    7720:	48 63 d0             	movslq %eax,%rdx
    7723:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    7727:	48 01 d0             	add    %rdx,%rax
    772a:	0f b6 00             	movzbl (%rax),%eax
    772d:	0f b6 c0             	movzbl %al,%eax
    7730:	8b 55 fc             	mov    -0x4(%rbp),%edx
    7733:	01 d2                	add    %edx,%edx
    7735:	48 63 ca             	movslq %edx,%rcx
    7738:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    773c:	48 01 d1             	add    %rdx,%rcx
    773f:	89 c2                	mov    %eax,%edx
    7741:	48 8d 35 a4 15 00 00 	lea    0x15a4(%rip),%rsi        # 8cec <rcon+0x2c>
    7748:	48 89 cf             	mov    %rcx,%rdi
    774b:	b8 00 00 00 00       	mov    $0x0,%eax
    7750:	e8 fb a9 ff ff       	call   2150 <sprintf@plt>
	for(int i = 0; i < 16; i++){
    7755:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    7759:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
    775d:	7e be                	jle    771d <BytesToString+0x1d>
	}
}
    775f:	90                   	nop
    7760:	90                   	nop
    7761:	c9                   	leave  
    7762:	c3                   	ret    

0000000000007763 <usage>:

char *optarg = NULL; 
int optind = 1;

static void	usage(void)
{
    7763:	f3 0f 1e fa          	endbr64 
    7767:	55                   	push   %rbp
    7768:	48 89 e5             	mov    %rsp,%rbp
	(void)fprintf(stderr, "%s\n", "usage: woody_woodpacker [-e key] [-d key] file");
    776b:	48 8b 05 4e 5c 00 00 	mov    0x5c4e(%rip),%rax        # d3c0 <stderr@GLIBC_2.2.5>
    7772:	48 8d 15 5f 17 00 00 	lea    0x175f(%rip),%rdx        # 8ed8 <rcon+0x1d8>
    7779:	48 8d 35 87 17 00 00 	lea    0x1787(%rip),%rsi        # 8f07 <rcon+0x207>
    7780:	48 89 c7             	mov    %rax,%rdi
    7783:	b8 00 00 00 00       	mov    $0x0,%eax
    7788:	e8 73 a9 ff ff       	call   2100 <fprintf@plt>
	exit(64);
    778d:	bf 40 00 00 00       	mov    $0x40,%edi
    7792:	e8 c9 a9 ff ff       	call   2160 <exit@plt>

0000000000007797 <ft_getopt>:
}

int ft_getopt(int argc, char * const argv[], const char *optstring) {
    7797:	f3 0f 1e fa          	endbr64 
    779b:	55                   	push   %rbp
    779c:	48 89 e5             	mov    %rsp,%rbp
    779f:	48 83 ec 30          	sub    $0x30,%rsp
    77a3:	89 7d ec             	mov    %edi,-0x14(%rbp)
    77a6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    77aa:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *optchar;

	if (optind >= argc || argv[optind][0] != '-') {
    77ae:	8b 05 0c 5a 00 00    	mov    0x5a0c(%rip),%eax        # d1c0 <optind>
    77b4:	39 45 ec             	cmp    %eax,-0x14(%rbp)
    77b7:	7e 21                	jle    77da <ft_getopt+0x43>
    77b9:	8b 05 01 5a 00 00    	mov    0x5a01(%rip),%eax        # d1c0 <optind>
    77bf:	48 98                	cltq   
    77c1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    77c8:	00 
    77c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    77cd:	48 01 d0             	add    %rdx,%rax
    77d0:	48 8b 00             	mov    (%rax),%rax
    77d3:	0f b6 00             	movzbl (%rax),%eax
    77d6:	3c 2d                	cmp    $0x2d,%al
    77d8:	74 0a                	je     77e4 <ft_getopt+0x4d>
		return -1; // Pas plus d'options ou ce n'est pas une option
    77da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    77df:	e9 45 01 00 00       	jmp    7929 <ft_getopt+0x192>
	}

	optchar = strchr(optstring, argv[optind][1]);
    77e4:	8b 05 d6 59 00 00    	mov    0x59d6(%rip),%eax        # d1c0 <optind>
    77ea:	48 98                	cltq   
    77ec:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    77f3:	00 
    77f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    77f8:	48 01 d0             	add    %rdx,%rax
    77fb:	48 8b 00             	mov    (%rax),%rax
    77fe:	48 83 c0 01          	add    $0x1,%rax
    7802:	0f b6 00             	movzbl (%rax),%eax
    7805:	0f be d0             	movsbl %al,%edx
    7808:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    780c:	89 d6                	mov    %edx,%esi
    780e:	48 89 c7             	mov    %rax,%rdi
    7811:	e8 7a a8 ff ff       	call   2090 <strchr@plt>
    7816:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (optchar == NULL) {
    781a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    781f:	75 58                	jne    7879 <ft_getopt+0xe2>
		fprintf(stderr, "Unknown option: %c\n", argv[optind][1]);
    7821:	8b 05 99 59 00 00    	mov    0x5999(%rip),%eax        # d1c0 <optind>
    7827:	48 98                	cltq   
    7829:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    7830:	00 
    7831:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    7835:	48 01 d0             	add    %rdx,%rax
    7838:	48 8b 00             	mov    (%rax),%rax
    783b:	48 83 c0 01          	add    $0x1,%rax
    783f:	0f b6 00             	movzbl (%rax),%eax
    7842:	0f be d0             	movsbl %al,%edx
    7845:	48 8b 05 74 5b 00 00 	mov    0x5b74(%rip),%rax        # d3c0 <stderr@GLIBC_2.2.5>
    784c:	48 8d 35 b8 16 00 00 	lea    0x16b8(%rip),%rsi        # 8f0b <rcon+0x20b>
    7853:	48 89 c7             	mov    %rax,%rdi
    7856:	b8 00 00 00 00       	mov    $0x0,%eax
    785b:	e8 a0 a8 ff ff       	call   2100 <fprintf@plt>
		optind++;
    7860:	8b 05 5a 59 00 00    	mov    0x595a(%rip),%eax        # d1c0 <optind>
    7866:	83 c0 01             	add    $0x1,%eax
    7869:	89 05 51 59 00 00    	mov    %eax,0x5951(%rip)        # d1c0 <optind>
		return '?';
    786f:	b8 3f 00 00 00       	mov    $0x3f,%eax
    7874:	e9 b0 00 00 00       	jmp    7929 <ft_getopt+0x192>
	}

	if (optchar[1] == ':') { // L'option ncessite un argument
    7879:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    787d:	48 83 c0 01          	add    $0x1,%rax
    7881:	0f b6 00             	movzbl (%rax),%eax
    7884:	3c 3a                	cmp    $0x3a,%al
    7886:	0f 85 84 00 00 00    	jne    7910 <ft_getopt+0x179>
		if (optind + 1 < argc) {
    788c:	8b 05 2e 59 00 00    	mov    0x592e(%rip),%eax        # d1c0 <optind>
    7892:	83 c0 01             	add    $0x1,%eax
    7895:	39 45 ec             	cmp    %eax,-0x14(%rbp)
    7898:	7e 40                	jle    78da <ft_getopt+0x143>
			optarg = argv[optind + 1];
    789a:	8b 05 20 59 00 00    	mov    0x5920(%rip),%eax        # d1c0 <optind>
    78a0:	48 98                	cltq   
    78a2:	48 83 c0 01          	add    $0x1,%rax
    78a6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    78ad:	00 
    78ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    78b2:	48 01 d0             	add    %rdx,%rax
    78b5:	48 8b 00             	mov    (%rax),%rax
    78b8:	48 89 05 11 5b 00 00 	mov    %rax,0x5b11(%rip)        # d3d0 <optarg>
			optind += 2;
    78bf:	8b 05 fb 58 00 00    	mov    0x58fb(%rip),%eax        # d1c0 <optind>
    78c5:	83 c0 02             	add    $0x2,%eax
    78c8:	89 05 f2 58 00 00    	mov    %eax,0x58f2(%rip)        # d1c0 <optind>
			return optchar[0];
    78ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    78d2:	0f b6 00             	movzbl (%rax),%eax
    78d5:	0f be c0             	movsbl %al,%eax
    78d8:	eb 4f                	jmp    7929 <ft_getopt+0x192>
		} else {
			fprintf(stderr, "Option requires an argument.\n");
    78da:	48 8b 05 df 5a 00 00 	mov    0x5adf(%rip),%rax        # d3c0 <stderr@GLIBC_2.2.5>
    78e1:	48 89 c1             	mov    %rax,%rcx
    78e4:	ba 1d 00 00 00       	mov    $0x1d,%edx
    78e9:	be 01 00 00 00       	mov    $0x1,%esi
    78ee:	48 8d 3d 2a 16 00 00 	lea    0x162a(%rip),%rdi        # 8f1f <rcon+0x21f>
    78f5:	e8 76 a8 ff ff       	call   2170 <fwrite@plt>
			optind++;
    78fa:	8b 05 c0 58 00 00    	mov    0x58c0(%rip),%eax        # d1c0 <optind>
    7900:	83 c0 01             	add    $0x1,%eax
    7903:	89 05 b7 58 00 00    	mov    %eax,0x58b7(%rip)        # d1c0 <optind>
			return '?';
    7909:	b8 3f 00 00 00       	mov    $0x3f,%eax
    790e:	eb 19                	jmp    7929 <ft_getopt+0x192>
		}
	} else { // L'option ne ncessite pas d'argument
		optind++;
    7910:	8b 05 aa 58 00 00    	mov    0x58aa(%rip),%eax        # d1c0 <optind>
    7916:	83 c0 01             	add    $0x1,%eax
    7919:	89 05 a1 58 00 00    	mov    %eax,0x58a1(%rip)        # d1c0 <optind>
		return optchar[0];
    791f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    7923:	0f b6 00             	movzbl (%rax),%eax
    7926:	0f be c0             	movsbl %al,%eax
	}
}
    7929:	c9                   	leave  
    792a:	c3                   	ret    

000000000000792b <printbytes>:

void	printbytes(uint8_t *bytes, size_t size)
{
    792b:	f3 0f 1e fa          	endbr64 
    792f:	55                   	push   %rbp
    7930:	48 89 e5             	mov    %rsp,%rbp
    7933:	48 83 ec 20          	sub    $0x20,%rsp
    7937:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    793b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	size_t i = 0;
    793f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    7946:	00 
	while (i < size)
    7947:	eb 29                	jmp    7972 <printbytes+0x47>
	{
		printf("%02x ", bytes[i]);
    7949:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    794d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    7951:	48 01 d0             	add    %rdx,%rax
    7954:	0f b6 00             	movzbl (%rax),%eax
    7957:	0f b6 c0             	movzbl %al,%eax
    795a:	89 c6                	mov    %eax,%esi
    795c:	48 8d 3d da 15 00 00 	lea    0x15da(%rip),%rdi        # 8f3d <rcon+0x23d>
    7963:	b8 00 00 00 00       	mov    $0x0,%eax
    7968:	e8 33 a7 ff ff       	call   20a0 <printf@plt>
		i++;
    796d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	while (i < size)
    7972:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    7976:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
    797a:	72 cd                	jb     7949 <printbytes+0x1e>
	}
	printf("\n");
    797c:	bf 0a 00 00 00       	mov    $0xa,%edi
    7981:	e8 ba a6 ff ff       	call   2040 <putchar@plt>
}
    7986:	90                   	nop
    7987:	c9                   	leave  
    7988:	c3                   	ret    

0000000000007989 <main>:

int	main(int ac, char **av)
{
    7989:	f3 0f 1e fa          	endbr64 
    798d:	55                   	push   %rbp
    798e:	48 89 e5             	mov    %rsp,%rbp
    7991:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
    7998:	89 bd 4c ff ff ff    	mov    %edi,-0xb4(%rbp)
    799e:	48 89 b5 40 ff ff ff 	mov    %rsi,-0xc0(%rbp)
    79a5:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    79ac:	00 00 
    79ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    79b2:	31 c0                	xor    %eax,%eax
	char *target;
	int ch, option = 0;
    79b4:	c7 85 54 ff ff ff 00 	movl   $0x0,-0xac(%rbp)
    79bb:	00 00 00 
	char key[] = "0123456789abcdef0123456789abcdef";
    79be:	48 b8 30 31 32 33 34 	movabs $0x3736353433323130,%rax
    79c5:	35 36 37 
    79c8:	48 ba 38 39 61 62 63 	movabs $0x6665646362613938,%rdx
    79cf:	64 65 66 
    79d2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    79d6:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
    79da:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    79de:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    79e2:	c6 45 c0 00          	movb   $0x0,-0x40(%rbp)
	
	while ((ch = ft_getopt(ac, av, "e:d:k:h")) != -1) {
    79e6:	eb 7c                	jmp    7a64 <main+0xdb>
		switch (ch) {
    79e8:	83 bd 58 ff ff ff 6b 	cmpl   $0x6b,-0xa8(%rbp)
    79ef:	74 2f                	je     7a20 <main+0x97>
    79f1:	83 bd 58 ff ff ff 6b 	cmpl   $0x6b,-0xa8(%rbp)
    79f8:	7f 65                	jg     7a5f <main+0xd6>
    79fa:	83 bd 58 ff ff ff 68 	cmpl   $0x68,-0xa8(%rbp)
    7a01:	74 41                	je     7a44 <main+0xbb>
    7a03:	83 bd 58 ff ff ff 68 	cmpl   $0x68,-0xa8(%rbp)
    7a0a:	7f 53                	jg     7a5f <main+0xd6>
    7a0c:	83 bd 58 ff ff ff 64 	cmpl   $0x64,-0xa8(%rbp)
    7a13:	74 41                	je     7a56 <main+0xcd>
    7a15:	83 bd 58 ff ff ff 65 	cmpl   $0x65,-0xa8(%rbp)
    7a1c:	74 2f                	je     7a4d <main+0xc4>
    7a1e:	eb 3f                	jmp    7a5f <main+0xd6>
			case 'k':
				option |= F_KEY;
    7a20:	83 8d 54 ff ff ff 01 	orl    $0x1,-0xac(%rbp)
				memmove(key, optarg, 32);
    7a27:	48 8b 0d a2 59 00 00 	mov    0x59a2(%rip),%rcx        # d3d0 <optarg>
    7a2e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
    7a32:	ba 20 00 00 00       	mov    $0x20,%edx
    7a37:	48 89 ce             	mov    %rcx,%rsi
    7a3a:	48 89 c7             	mov    %rax,%rdi
    7a3d:	e8 ee a6 ff ff       	call   2130 <memmove@plt>
				break;
    7a42:	eb 20                	jmp    7a64 <main+0xdb>
			case 'h':
				option |= F_HEADER;
    7a44:	83 8d 54 ff ff ff 02 	orl    $0x2,-0xac(%rbp)
				break;
    7a4b:	eb 17                	jmp    7a64 <main+0xdb>
			case 'e':
				option |= F_ENCRYPT;
    7a4d:	83 8d 54 ff ff ff 10 	orl    $0x10,-0xac(%rbp)
				break;
    7a54:	eb 0e                	jmp    7a64 <main+0xdb>
			case 'd':
				option |= F_DECRYPT;
    7a56:	83 8d 54 ff ff ff 20 	orl    $0x20,-0xac(%rbp)
				break;
    7a5d:	eb 05                	jmp    7a64 <main+0xdb>
			default:
				usage();
    7a5f:	e8 ff fc ff ff       	call   7763 <usage>
	while ((ch = ft_getopt(ac, av, "e:d:k:h")) != -1) {
    7a64:	48 8b 8d 40 ff ff ff 	mov    -0xc0(%rbp),%rcx
    7a6b:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
    7a71:	48 8d 15 cb 14 00 00 	lea    0x14cb(%rip),%rdx        # 8f43 <rcon+0x243>
    7a78:	48 89 ce             	mov    %rcx,%rsi
    7a7b:	89 c7                	mov    %eax,%edi
    7a7d:	e8 15 fd ff ff       	call   7797 <ft_getopt>
    7a82:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%rbp)
    7a88:	83 bd 58 ff ff ff ff 	cmpl   $0xffffffff,-0xa8(%rbp)
    7a8f:	0f 85 53 ff ff ff    	jne    79e8 <main+0x5f>
		}
	}

	if (ac - optind != 1)
    7a95:	8b 15 25 57 00 00    	mov    0x5725(%rip),%edx        # d1c0 <optind>
    7a9b:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
    7aa1:	29 d0                	sub    %edx,%eax
    7aa3:	83 f8 01             	cmp    $0x1,%eax
    7aa6:	74 05                	je     7aad <main+0x124>
		usage();
    7aa8:	e8 b6 fc ff ff       	call   7763 <usage>
	target = av[optind];
    7aad:	8b 05 0d 57 00 00    	mov    0x570d(%rip),%eax        # d1c0 <optind>
    7ab3:	48 98                	cltq   
    7ab5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
    7abc:	00 
    7abd:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    7ac4:	48 01 d0             	add    %rdx,%rax
    7ac7:	48 8b 00             	mov    (%rax),%rax
    7aca:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)

	printf("Target: %s\n", target);
    7ad1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    7ad8:	48 89 c6             	mov    %rax,%rsi
    7adb:	48 8d 3d 69 14 00 00 	lea    0x1469(%rip),%rdi        # 8f4b <rcon+0x24b>
    7ae2:	b8 00 00 00 00       	mov    $0x0,%eax
    7ae7:	e8 b4 a5 ff ff       	call   20a0 <printf@plt>

	if (option & F_KEY) {
    7aec:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
    7af2:	83 e0 01             	and    $0x1,%eax
    7af5:	85 c0                	test   %eax,%eax
    7af7:	74 1b                	je     7b14 <main+0x18b>
		printf("Option k: %s\n", optarg);
    7af9:	48 8b 05 d0 58 00 00 	mov    0x58d0(%rip),%rax        # d3d0 <optarg>
    7b00:	48 89 c6             	mov    %rax,%rsi
    7b03:	48 8d 3d 4d 14 00 00 	lea    0x144d(%rip),%rdi        # 8f57 <rcon+0x257>
    7b0a:	b8 00 00 00 00       	mov    $0x0,%eax
    7b0f:	e8 8c a5 ff ff       	call   20a0 <printf@plt>
	}

	int fd = open(target, O_RDONLY);
    7b14:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    7b1b:	be 00 00 00 00       	mov    $0x0,%esi
    7b20:	48 89 c7             	mov    %rax,%rdi
    7b23:	b8 00 00 00 00       	mov    $0x0,%eax
    7b28:	e8 13 a6 ff ff       	call   2140 <open@plt>
    7b2d:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
	if (fd == -1)
    7b33:	83 bd 5c ff ff ff ff 	cmpl   $0xffffffff,-0xa4(%rbp)
    7b3a:	75 25                	jne    7b61 <main+0x1d8>
	{
		printf("Error: Cannot open file %s\n", target);
    7b3c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    7b43:	48 89 c6             	mov    %rax,%rsi
    7b46:	48 8d 3d 18 14 00 00 	lea    0x1418(%rip),%rdi        # 8f65 <rcon+0x265>
    7b4d:	b8 00 00 00 00       	mov    $0x0,%eax
    7b52:	e8 49 a5 ff ff       	call   20a0 <printf@plt>
		return (1);
    7b57:	b8 01 00 00 00       	mov    $0x1,%eax
    7b5c:	e9 35 02 00 00       	jmp    7d96 <main+0x40d>
	}

	/**
	 * Create new reader
	 */
	t_binary_reader *reader = new_binary_reader(fd);
    7b61:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
    7b67:	89 c7                	mov    %eax,%edi
    7b69:	e8 16 b2 ff ff       	call   2d84 <new_binary_reader>
    7b6e:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	if (!reader)
    7b75:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
    7b7c:	00 
    7b7d:	75 25                	jne    7ba4 <main+0x21b>
	{
		printf("Error: Cannot read file %s\n", target);
    7b7f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    7b86:	48 89 c6             	mov    %rax,%rsi
    7b89:	48 8d 3d f1 13 00 00 	lea    0x13f1(%rip),%rdi        # 8f81 <rcon+0x281>
    7b90:	b8 00 00 00 00       	mov    $0x0,%eax
    7b95:	e8 06 a5 ff ff       	call   20a0 <printf@plt>
		return (1);
    7b9a:	b8 01 00 00 00       	mov    $0x1,%eax
    7b9f:	e9 f2 01 00 00       	jmp    7d96 <main+0x40d>
	}
	// Get the file e_type reading 3 bytes as a string
	t_elf_file *elf_file = new_elf_file(reader);
    7ba4:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7bab:	48 89 c7             	mov    %rax,%rdi
    7bae:	e8 cb d2 ff ff       	call   4e7e <new_elf_file>
    7bb3:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	if (elf_file == NULL)
    7bba:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
    7bc1:	00 
    7bc2:	75 25                	jne    7be9 <main+0x260>
	{
		printf("Error: Cannot get format for file %s\n", target);
    7bc4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    7bcb:	48 89 c6             	mov    %rax,%rsi
    7bce:	48 8d 3d cb 13 00 00 	lea    0x13cb(%rip),%rdi        # 8fa0 <rcon+0x2a0>
    7bd5:	b8 00 00 00 00       	mov    $0x0,%eax
    7bda:	e8 c1 a4 ff ff       	call   20a0 <printf@plt>
		return (1);
    7bdf:	b8 01 00 00 00       	mov    $0x1,%eax
    7be4:	e9 ad 01 00 00       	jmp    7d96 <main+0x40d>
	 * 
	 * olalaaaaaa ke sai pa bo !!!!!!!!!!
	 *
	 */
	
	int ffd = open("woody_encrypted", O_CREAT | O_RDWR | O_TRUNC, 0755);
    7be9:	ba ed 01 00 00       	mov    $0x1ed,%edx
    7bee:	be 42 02 00 00       	mov    $0x242,%esi
    7bf3:	48 8d 3d cc 13 00 00 	lea    0x13cc(%rip),%rdi        # 8fc6 <rcon+0x2c6>
    7bfa:	b8 00 00 00 00       	mov    $0x0,%eax
    7bff:	e8 3c a5 ff ff       	call   2140 <open@plt>
    7c04:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)

	uint8_t input[16];
	reader->seek(reader, 0x0);
    7c0a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7c11:	48 8b 50 18          	mov    0x18(%rax),%rdx
    7c15:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7c1c:	be 00 00 00 00       	mov    $0x0,%esi
    7c21:	48 89 c7             	mov    %rax,%rdi
    7c24:	ff d2                	call   *%rdx
	char key2[33];
	memmove(key2, key, 32);
    7c26:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
    7c2a:	48 8d 75 a0          	lea    -0x60(%rbp),%rsi
    7c2e:	48 8b 06             	mov    (%rsi),%rax
    7c31:	48 8b 56 08          	mov    0x8(%rsi),%rdx
    7c35:	48 89 01             	mov    %rax,(%rcx)
    7c38:	48 89 51 08          	mov    %rdx,0x8(%rcx)
    7c3c:	48 8b 46 10          	mov    0x10(%rsi),%rax
    7c40:	48 8b 56 18          	mov    0x18(%rsi),%rdx
    7c44:	48 89 41 10          	mov    %rax,0x10(%rcx)
    7c48:	48 89 51 18          	mov    %rdx,0x18(%rcx)
	while (reader->get_bytes(reader, input, 16))
    7c4c:	eb 33                	jmp    7c81 <main+0x2f8>
	{
		char *res = *AES_encrypt(input, key2);
    7c4e:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
    7c52:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    7c56:	48 89 d6             	mov    %rdx,%rsi
    7c59:	48 89 c7             	mov    %rax,%rdi
    7c5c:	e8 fe e4 ff ff       	call   615f <AES_encrypt>
    7c61:	48 8b 00             	mov    (%rax),%rax
    7c64:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		write(ffd, res, 16);
    7c68:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
    7c6c:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
    7c72:	ba 10 00 00 00       	mov    $0x10,%edx
    7c77:	48 89 ce             	mov    %rcx,%rsi
    7c7a:	89 c7                	mov    %eax,%edi
    7c7c:	e8 df a3 ff ff       	call   2060 <write@plt>
	while (reader->get_bytes(reader, input, 16))
    7c81:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7c88:	4c 8b 80 90 00 00 00 	mov    0x90(%rax),%r8
    7c8f:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
    7c93:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7c9a:	ba 10 00 00 00       	mov    $0x10,%edx
    7c9f:	48 89 ce             	mov    %rcx,%rsi
    7ca2:	48 89 c7             	mov    %rax,%rdi
    7ca5:	41 ff d0             	call   *%r8
    7ca8:	48 85 c0             	test   %rax,%rax
    7cab:	75 a1                	jne    7c4e <main+0x2c5>
	}
	printf("key -> %s\n", key);
    7cad:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
    7cb1:	48 89 c6             	mov    %rax,%rsi
    7cb4:	48 8d 3d 1b 13 00 00 	lea    0x131b(%rip),%rdi        # 8fd6 <rcon+0x2d6>
    7cbb:	b8 00 00 00 00       	mov    $0x0,%eax
    7cc0:	e8 db a3 ff ff       	call   20a0 <printf@plt>
	int ffdd = open("woody_decrypted", O_CREAT | O_WRONLY | O_TRUNC, 0755);
    7cc5:	ba ed 01 00 00       	mov    $0x1ed,%edx
    7cca:	be 41 02 00 00       	mov    $0x241,%esi
    7ccf:	48 8d 3d 0b 13 00 00 	lea    0x130b(%rip),%rdi        # 8fe1 <rcon+0x2e1>
    7cd6:	b8 00 00 00 00       	mov    $0x0,%eax
    7cdb:	e8 60 a4 ff ff       	call   2140 <open@plt>
    7ce0:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)

	reader = new_binary_reader(ffd);
    7ce6:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
    7cec:	89 c7                	mov    %eax,%edi
    7cee:	e8 91 b0 ff ff       	call   2d84 <new_binary_reader>
    7cf3:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	reader->seek(reader, 0x0);
    7cfa:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7d01:	48 8b 50 18          	mov    0x18(%rax),%rdx
    7d05:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7d0c:	be 00 00 00 00       	mov    $0x0,%esi
    7d11:	48 89 c7             	mov    %rax,%rdi
    7d14:	ff d2                	call   *%rdx
	while (reader->get_bytes(reader, input, 16))
    7d16:	eb 33                	jmp    7d4b <main+0x3c2>
	{
		char *res = *AES_decrypt(input, key);
    7d18:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
    7d1c:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    7d20:	48 89 d6             	mov    %rdx,%rsi
    7d23:	48 89 c7             	mov    %rax,%rdi
    7d26:	e8 92 e5 ff ff       	call   62bd <AES_decrypt>
    7d2b:	48 8b 00             	mov    (%rax),%rax
    7d2e:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		write(ffdd, res, 16);
    7d32:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
    7d36:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
    7d3c:	ba 10 00 00 00       	mov    $0x10,%edx
    7d41:	48 89 ce             	mov    %rcx,%rsi
    7d44:	89 c7                	mov    %eax,%edi
    7d46:	e8 15 a3 ff ff       	call   2060 <write@plt>
	while (reader->get_bytes(reader, input, 16))
    7d4b:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7d52:	4c 8b 80 90 00 00 00 	mov    0x90(%rax),%r8
    7d59:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
    7d5d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7d64:	ba 10 00 00 00       	mov    $0x10,%edx
    7d69:	48 89 ce             	mov    %rcx,%rsi
    7d6c:	48 89 c7             	mov    %rax,%rdi
    7d6f:	41 ff d0             	call   *%r8
    7d72:	48 85 c0             	test   %rax,%rax
    7d75:	75 a1                	jne    7d18 <main+0x38f>
	}

	close(ffd);
    7d77:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
    7d7d:	89 c7                	mov    %eax,%edi
    7d7f:	e8 3c a3 ff ff       	call   20c0 <close@plt>
	close(ffdd);
    7d84:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
    7d8a:	89 c7                	mov    %eax,%edi
    7d8c:	e8 2f a3 ff ff       	call   20c0 <close@plt>
	
	return (0);
    7d91:	b8 00 00 00 00       	mov    $0x0,%eax
	// packer(elf_file, new_elf_file, reader);

	// delete_binary_reader(reader);
	// delete_elf_file(elf_file);
	// delete_elf_file(new_elf_file);
}
    7d96:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    7d9a:	64 48 2b 0c 25 28 00 	sub    %fs:0x28,%rcx
    7da1:	00 00 
    7da3:	74 05                	je     7daa <main+0x421>
    7da5:	e8 d6 a2 ff ff       	call   2080 <__stack_chk_fail@plt>
    7daa:	c9                   	leave  
    7dab:	c3                   	ret    
    7dac:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007db0 <_payload_64>:
    7db0:	9c                   	pushf  
    7db1:	50                   	push   %rax
    7db2:	52                   	push   %rdx
    7db3:	56                   	push   %rsi
    7db4:	57                   	push   %rdi
    7db5:	eb 0f                	jmp    7dc6 <_payload_64.print_start_msg>

0000000000007db7 <_payload_64.displayed_str>:
    7db7:	2e 2e 2e 2e 57       	cs cs cs cs push %rdi
    7dbc:	4f                   	rex.WRXB
    7dbd:	4f                   	rex.WRXB
    7dbe:	44 59                	rex.R pop %rcx
    7dc0:	2e 2e 2e 2e 0a 00    	cs cs cs cs or (%rax),%al

0000000000007dc6 <_payload_64.print_start_msg>:
    7dc6:	b8 01 00 00 00       	mov    $0x1,%eax
    7dcb:	bf 01 00 00 00       	mov    $0x1,%edi
    7dd0:	48 8d 35 e0 ff ff ff 	lea    -0x20(%rip),%rsi        # 7db7 <_payload_64.displayed_str>
    7dd7:	ba 0f 00 00 00       	mov    $0xf,%edx
    7ddc:	0f 05                	syscall 

0000000000007dde <_payload_64.encrypt>:
    7dde:	48 8b 05 1c 00 00 00 	mov    0x1c(%rip),%rax        # 7e01 <_payload_64.encrypted_data_start>
    7de5:	48 8b 3d 1d 00 00 00 	mov    0x1d(%rip),%rdi        # 7e09 <_payload_64.encrypted_data_len>
    7dec:	48 8b 35 1e 00 00 00 	mov    0x1e(%rip),%rsi        # 7e11 <_payload_64.start_encode>
    7df3:	48 01 c7             	add    %rax,%rdi
    7df6:	5f                   	pop    %rdi
    7df7:	5e                   	pop    %rsi
    7df8:	5a                   	pop    %rdx
    7df9:	58                   	pop    %rax
    7dfa:	9d                   	popf   
    7dfb:	ff 25 dd ff ff ff    	jmp    *-0x23(%rip)        # 7dde <_payload_64.encrypt>

0000000000007e01 <_payload_64.encrypted_data_start>:
	...

0000000000007e09 <_payload_64.encrypted_data_len>:
	...

0000000000007e11 <_payload_64.start_encode>:
	...

0000000000007e19 <_payload_size_64>:
    7e19:	69 00 00 00 00 00    	imul   $0x0,(%rax),%eax
	...

Disassembly of section .fini:

0000000000007e24 <_fini>:
    7e24:	f3 0f 1e fa          	endbr64 
    7e28:	48 83 ec 08          	sub    $0x8,%rsp
    7e2c:	48 83 c4 08          	add    $0x8,%rsp
    7e30:	c3                   	ret    
